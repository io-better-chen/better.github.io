

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://better-io-blog.oss-cn-beijing.aliyuncs.com/netty.png">
  <link rel="icon" href="https://better-io-blog.oss-cn-beijing.aliyuncs.com/netty.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="本章简介
本章讲解如下：

HashMap 的常用方法的使用：put，set，remove
HashMap 是如何解决 hash 冲突？
HashMap 的时间复杂度/空间复杂度？
HashMap 底层源码分析

">
  
  <meta name="author" content="Better.Chen">
  <meta name="keywords" content="">
  
  <title>HashMap 解析 - IO.BETTER的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"doc.io-better.cn","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>IO.BETTER</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/back.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="HashMap 解析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-23 07:55" pubdate>
        2021年3月23日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      43
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">HashMap 解析</h1>
            
            <div class="markdown-body">
              <h2 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h2><blockquote>
<p>本章讲解如下：</p>
<ol>
<li>HashMap 的常用方法的使用：put，set，remove</li>
<li>HashMap 是如何解决 hash 冲突？</li>
<li>HashMap 的时间复杂度/空间复杂度？</li>
<li>HashMap 底层源码分析</li>
</ol>
</blockquote>
<span id="more"></span>


<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>HashMap的实例具有两个影响其性能的参数：<code>初始容量</code>和<code>负载因子</code>。容量是哈希表中存储桶的数量，初始容量只是创建哈希表时的容量。负载因子是散列表的容量自动增加之前允许其填充的完整程度的度量。当哈希表中的条目数超过负载因子和当前容量的乘积时，哈希表将被重新哈希（即，内部数据结构将被重建），因此哈希表的存储桶数约为两倍。</p>
<p>通常，默认负载因子（0.75）在时间和空间成本之间提供了一个很好的折衷方案。较高的值会减少空间开销，但会增加查找成本（在HashMap类的大多数操作中都得到体现，包括get和put）。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 默认容量</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;

<span class="hljs-comment">// 最大容量</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;

<span class="hljs-comment">// 默认加载因子</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;

<span class="hljs-comment">// 转变红黑树的阈值</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;

<span class="hljs-comment">// 不转变红黑树的阈值</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;

<span class="hljs-comment">// 红黑树最小的容量</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;</code></pre></div>



<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* ---------------- Fields -------------- */</span>

<span class="hljs-comment">// 数组，用于存放链表。第一次使用时初始化</span>
<span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;

<span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

<span class="hljs-comment">// 长度</span>
<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;

<span class="hljs-comment">// 记录 rehash 的计数</span>
<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;

<span class="hljs-comment">// 当前容量阈值</span>
<span class="hljs-keyword">int</span> threshold;

<span class="hljs-comment">// 当前加载因子</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;</code></pre></div>



<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +
                                       initialCapacity);
  <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)
    initialCapacity = MAXIMUM_CAPACITY;
  <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +
                                       loadFactor);
  <span class="hljs-keyword">this</span>.loadFactor = loadFactor;
  <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);
&#125;</code></pre></div>



<h3 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h3><h4 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;  <span class="hljs-comment">// hash 值</span>
<span class="hljs-keyword">final</span> K key;     <span class="hljs-comment">// 存储的 Key</span>
V value;   			 <span class="hljs-comment">// 存储的 Value</span>
Node&lt;K,V&gt; next;  <span class="hljs-comment">// 后继节点，形成单向链表</span></code></pre></div>



<h4 id="核心构造函数"><a href="#核心构造函数" class="headerlink" title="核心构造函数"></a>核心构造函数</h4><div class="code-wrapper"><pre><code class="hljs java">Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
  <span class="hljs-keyword">this</span>.hash = hash;
  <span class="hljs-keyword">this</span>.key = key;
  <span class="hljs-keyword">this</span>.value = value;
  <span class="hljs-keyword">this</span>.next = next;
&#125;</code></pre></div>



<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>HashMap 的核心方法这里只讲解 put，get，remove 三个方法。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p>put 方法用于向 HashMap 中添加元素，支持</p>
<h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
  <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
&#125;</code></pre></div>

<p>调用 <code>hash()</code> 方法计算 key 的 hash 值(此方法后面会讲解)。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;
  Node&lt;K,V&gt;[] tab; <span class="hljs-comment">// 当 hashMap 的数组</span>
  Node&lt;K,V&gt; p;   <span class="hljs-comment">// 数组中的节点</span>
  <span class="hljs-keyword">int</span> n, i;
  <span class="hljs-comment">// 数组为空则调用 resize 方法对 table 进行初始化</span>
  <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
    n = (tab = resize()).length;
  <span class="hljs-comment">// 通过数组长度 &amp; hash 值找到，此 hash 所在的节点</span>
  <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)
    tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
  <span class="hljs-comment">// 节点不为空</span>
  <span class="hljs-keyword">else</span> &#123;
    Node&lt;K,V&gt; e; 
    K k;
    <span class="hljs-comment">// hash 碰撞</span>
    <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
      e = p;
    <span class="hljs-comment">// 如果是 TreeNode 则调用</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);
		<span class="hljs-comment">// hash 未碰撞，向后遍历查找</span>
    <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;
        <span class="hljs-comment">// 后继节点为空，则直接创建 Node 节点</span>
        <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;
          p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
          <span class="hljs-comment">// 如果达到树节点的阈值，则调用treeifyBin将节点（链表）改为树结构</span>
          <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>
            treeifyBin(tab, hash);
          <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-comment">// 后继节点不为空且 key-value 都相同，直接结束循环</span>
        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
          <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">// 不同则继续向后查找</span>
        p = e;
      &#125;
    &#125;
   	<span class="hljs-comment">// 节点不为空，说明存在映射的 key</span>
    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;
      V oldValue = e.value;
      <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)
        e.value = value;
      afterNodeAccess(e);
      <span class="hljs-keyword">return</span> oldValue;
    &#125;
  &#125;
  <span class="hljs-comment">// 记录 rehash 的次数</span>
  ++modCount;
  <span class="hljs-comment">// 超过阈值则进行扩容</span>
  <span class="hljs-keyword">if</span> (++size &gt; threshold)
    resize();
  afterNodeInsertion(evict);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>



<h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><ol>
<li>如果 HashMap 未初始化，则调用 <code>resize</code>方法进行初始化。</li>
<li>通过 <code>数组长度(table.length - 1)</code> <strong>&amp;</strong> <code>hash 值</code>计算出 index 并判断链表头节点是否为空<ol>
<li>链表头节点为空，说明可以新增节点，成功则执行步骤 4</li>
<li>链表头节点不为空，执行步骤 3</li>
</ol>
</li>
<li>当链表头节点不为空，有一下三种结果：<ol>
<li>当前 hash 与链表头节点产生 hash 碰撞。</li>
<li>链表节点为 TreeNode，说明此时数据结构不在是链表而是树结构了</li>
<li>当前 hash 和链表头节点未产生 hash 碰撞 <ol>
<li>从链表头节点向后遍历，有两种状况：<ol>
<li>next 节点与当前 hash 未产生碰撞，继续向后遍历，计数+1</li>
<li>next 节点为空，则直接创建新节点并添加到链表中，当计数超过树阈值则当前链表结构会升级为树结构（<code>treeifyBin方法</code>）, 并结束循环。</li>
</ol>
</li>
</ol>
</li>
<li>产生碰撞后说明存在映射的 key，则替换旧值。</li>
</ol>
</li>
<li>记录 hash 次数，判断 size 是否超过阈值，超过则调用<code>resize</code>进行扩容</li>
</ol>
<h5 id="树节点"><a href="#树节点" class="headerlink" title="树节点"></a>树节点</h5><p>当遍历链表时长度超过了 8 个，链表结构就会被淘汰升级会树结构，其数据结构就是 <code>TreeNode</code>。</p>
<p>后面会讲解 TreeNode</p>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><p>get 方法用于根据指定的 key 从 HashMap 中获取 value</p>
<h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;
  Node&lt;K,V&gt; e;
  <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;
&#125;</code></pre></div>

<p>查看 getNode 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;
  Node&lt;K,V&gt;[] tab; 
  Node&lt;K,V&gt; first,
  Node&lt;K,V&gt; e; 
  <span class="hljs-keyword">int</span> n; 
  K k;
  <span class="hljs-comment">// table 不为空 且 节点不为空</span>
  <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) 
  &#123;
    <span class="hljs-comment">// 头节点hash 与当前 hash 一致</span>
    <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
      <span class="hljs-keyword">return</span> first; <span class="hljs-comment">// 直接返回</span>
    <span class="hljs-comment">// 后继节点不为空</span>
    <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// 节点为树形结构</span>
      <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)
        <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
			<span class="hljs-comment">// 开启循环， 遍历链表</span>
      <span class="hljs-keyword">do</span> &#123;
        <span class="hljs-comment">// 判断 hash 是否一致，一致则直接返回</span>
        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
          <span class="hljs-keyword">return</span> e;
      &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>

<h5 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h5><ol>
<li>判断 table 是否为空，为空直接返回 bull，不为空执行步骤 2</li>
<li>获取到链表头节点，并判断是否与当前 hash 一致，一致则直接返回，否则执行步骤 3</li>
<li>判断后继节点是否为空，为空直接返回 null ，不为空则执行步骤 4</li>
<li>链表头节点为树结构，直接转成 TreeNode 获取对象，反之执行步骤 5</li>
<li>开启循环，不断获取后继节点，不断的判断后继节点的 hash 是否与当前 hash 一致，一致则返回，反之则继续向后遍历，如果遇到后继节点为 null，则结束循环返回 null。</li>
</ol>
<h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h4><p>用于通过 key 删除 HashMap 中的数据</p>
<h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;
  Node&lt;K,V&gt; e;
  <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ?
    <span class="hljs-keyword">null</span> : e.value;
&#125;</code></pre></div>

<p>进入 removeNode 方法，查看具体的删除细节</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span>
<span class="hljs-function"><span class="hljs-params">                           <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;
  Node&lt;K,V&gt;[] tab; 
  Node&lt;K,V&gt; p; 
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">int</span> index;
  <span class="hljs-comment">// 数组不为空，且指定 hash 位置的链表不为空</span>
  <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;
      (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;
    Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, 
    Node&lt;K,V&gt; e; 
    K k;
    V v;
    <span class="hljs-comment">// 命中 hash</span>
    <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))
      node = p; <span class="hljs-comment">// 赋值</span>
    <span class="hljs-comment">// 未命中</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
        <span class="hljs-comment">// 从树形节点中获取</span>
        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
      <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">// 开启循环，直到尾节点为 null</span>
          <span class="hljs-comment">// 判断后继节点是否命中 hash</span>
          <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;
            node = e;
            <span class="hljs-keyword">break</span>;
          &#125;
          <span class="hljs-comment">// 未命中继续向后</span>
          p = e;
        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);
      &#125;
    &#125;
    <span class="hljs-comment">// node 不为空说明 hash 命中了</span>
    <span class="hljs-comment">// 是否匹配 value 值</span>
    <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||
                         (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;
      <span class="hljs-comment">// </span>
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)
        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);
			<span class="hljs-comment">// 命中了链表的头节点</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)
        tab[index] = node.next;
			<span class="hljs-comment">// 非头节点</span>
      <span class="hljs-keyword">else</span>
        p.next = node.next;
			<span class="hljs-comment">// 修改值</span>
      ++modCount;
      --size;
      afterNodeRemoval(node);
      <span class="hljs-keyword">return</span> node;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>



<h5 id="执行流程-2"><a href="#执行流程-2" class="headerlink" title="执行流程"></a>执行流程</h5><ol>
<li>判断数组是否为空，且 hash 索引处的链表是否为空，为空直接返回 null，反之执行步骤 2</li>
<li>判断hash是否命中链表的头节点，命中执行步骤 4，未命中执行步骤 3</li>
<li>开启循环，向后遍历链表，判断 hash 是否命中，命中则结束循环执行步骤 4，反之循环结束执行步骤 4</li>
<li>判断是否匹配 value<ol>
<li>链表升级为树，则调用 TreeNode 删除节点</li>
<li>命中链表头节点。</li>
<li>为命中链表头节点，修改 next 指针。</li>
</ol>
</li>
</ol>
<h4 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h4><p>hash 方法用于计算 key 的 hash 值。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;
  <span class="hljs-keyword">int</span> h;
  <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
&#125;</code></pre></div>

<p>举例：此时假设默认长度是 16，则 index 的索引计算查看低 4 为</p>
<p>key.hashCode:    1101 0100 1010 1010 1011 1111 0010 0111</p>
<p>h&gt;&gt;&gt;16:               0000 0000 0000 0000 1101 0100 1010 1010 </p>
<p>hash ^ h&gt;&gt;&gt;16:   1101 0100 1010 1010 0110 1011 1000 1101</p>
<p>hash 计算后再与<code>table.length-1</code> 进行<code>或运算</code></p>
<p>代码： <code>tab[i = (n - 1) &amp; hash]</code>，n 为数组长度， hash 则是通过或运算计算出的 hash</p>
<p>table.length-1 : 0000 0000 0000 0000 0000 0000 0000 1111</p>
<p>hash :                1101 0100 1010 1010 0110 1011 1000 1101</p>
<p>i:                        0000 0000 0000 0000 0000 0000 0000 1101  （13）</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>上面知道了当大小超过了阈值就会进行扩容，调用 resize 方法</p>
<h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;
  Node&lt;K,V&gt;[] oldTab = table;
  <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;
  <span class="hljs-keyword">int</span> oldThr = threshold;
  <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;
  
  <span class="hljs-comment">// 旧容量大于0</span>
  <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
      threshold = Integer.MAX_VALUE;
      <span class="hljs-keyword">return</span> oldTab;
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;
             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
      newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>
  &#125;
  <span class="hljs-comment">// 加载因子大于 0</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>
    newCap = oldThr;
	<span class="hljs-comment">// 加载默认配置</span>
  <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
  &#125;
  <span class="hljs-comment">// 长度阈值为 0，则重新计算</span>
  <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;
    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?
              (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);
  &#125;
  threshold = newThr;
  <span class="hljs-comment">// 创建新数组</span>
  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];
  table = newTab;
  <span class="hljs-comment">// 旧数组不为空</span>
  <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-comment">// 遍历数组中所有的链表</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;
      Node&lt;K,V&gt; e;
      <span class="hljs-comment">// 链表节点不为空</span>
      <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;
        oldTab[j] = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 后继节点为空</span>
        <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)
          newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;
        <span class="hljs-comment">// 树形结构</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)
          ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);
				<span class="hljs-comment">// 后继节点不为空</span>
        <span class="hljs-keyword">else</span> &#123;
          Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 低位头节点</span>
          Node&lt;K,V&gt; loTail = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 低位尾节点</span>
          Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 高位头节点</span>
          Node&lt;K,V&gt; hiTail = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 高位尾节点</span>
          Node&lt;K,V&gt; next;
          
          <span class="hljs-keyword">do</span> &#123;
            next = e.next;
            <span class="hljs-comment">// 索引在低位</span>
            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;
              <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)
                loHead = e;      
              <span class="hljs-keyword">else</span>
                loTail.next = e; 
              loTail = e;        <span class="hljs-comment">// 第一次赋值，tail 和 head 都是 e</span>
            &#125;
            <span class="hljs-comment">// 索引在高位</span>
            <span class="hljs-keyword">else</span> &#123;
              <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)
                hiHead = e;
              <span class="hljs-keyword">else</span>
                hiTail.next = e;
              hiTail = e;
            &#125;
            <span class="hljs-comment">// 继续下一个节点</span>
          &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);
          
          <span class="hljs-comment">// 存储低位</span>
          <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;
            loTail.next = <span class="hljs-keyword">null</span>;
            newTab[j] = loHead;
          &#125;
          <span class="hljs-comment">// 存储高位</span>
          <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;
            hiTail.next = <span class="hljs-keyword">null</span>;
            newTab[j + oldCap] = hiHead;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> newTab;
&#125;</code></pre></div>



<h4 id="执行流程-3"><a href="#执行流程-3" class="headerlink" title="执行流程"></a>执行流程</h4><ol>
<li>重新计算阈值和加载因子</li>
<li>创建新数组</li>
<li>遍历旧数组，获取到每个下标的链表，为空则跳过继续下次循环<ol>
<li>链表的后继节点为空，直接插入数组</li>
<li>链表的后继节点不为空，开启循环遍历链表<ol>
<li>声明高位头尾节点，低位头尾节点</li>
<li>通过节点的 hash 与旧数组长度与运算，判断结果是否为 0<ol>
<li>为 0 则是低位，赋值低位的头尾节点</li>
<li>不为 0 则是高位，赋值高位的头尾节点</li>
</ol>
</li>
<li>判断高低位的头尾节点是否为空，不为空直接插入数组</li>
</ol>
</li>
<li>节点为红黑树类型，调用 TreeNode.split 方法</li>
</ol>
</li>
</ol>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a target="_blank" rel="noopener" href="https://www.hollischuang.com/archives/2091">Hash 解析</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/HashMap/">HashMap</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/Map/">Map</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/23/thread/volatile-resolve/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Volatile 解析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/23/thread/aqs-source-code-resolve/">
                        <span class="hidden-mobile">AbstractQueuedSynchronizer 解析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'io-better/doc.io-better.cn.comment');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'doc.io-better.cn');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/io-better?tab=repositories" target="_blank" rel="nofollow noopener"><span>Github</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/better.github.io/img/logo.png">
  <link rel="icon" type="image/png" href="/better.github.io/img/logo.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="IO.BETTER的博客">
  <meta name="author" content="Better.Chen">
  <meta name="keywords" content="">
  <title>Reflection - IO.BETTER的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/better.github.io/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/better.github.io/">&nbsp;<strong>IO.BETTER</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/better.github.io/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/better.github.io/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/better.github.io/categories/">
              <i class="iconfont icon-category-fill"></i>
              分类</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/better.github.io/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/better.github.io/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/better.github.io/links/">
              <i class="iconfont icon-link-fill"></i>
              友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/better.github.io/img/back.webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-05-06 16:34">
                    2020年5月6日 下午
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    2k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    29
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="Jdk-Reflection"><a href="#Jdk-Reflection" class="headerlink" title="Jdk-Reflection"></a>Jdk-Reflection</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>Class的实例表示正在运行的Java应用程序的类和接口</code>。 枚举是一种类和注释是一种接口。</p>
<p>每个数组都属于一个被映射成Class对象的类，该对象由具有相同元素类型和大小的所有数组共享。 </p>
<p>原始类型<code>(boolean， byte， char， short， int， long， float，double)</code>，以及关键字<code>void</code>也表示为Class对象。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><strong>Class没有公共构造函数。 相反， Class对象由Java虚拟机的类加载并通过调用自动构造defineClass的类加载器方法</strong>。</p>
<h3 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h3><p>获取Class对象的方式一共有三种：通过<code>Class.forName(&quot;全路径包名&quot;)，类.class，类实例.getClass()</code>。</p>
<p>示例代码：</p>
<pre><code class="hljs java">Class&lt;?&gt; stringClass = Class.forName(<span class="hljs-string">"java.lang.String"</span>);
Class&lt;?&gt; integerClass = String<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
Class&lt;?&gt; stringObjClass = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>).getClass();

System.out.println(stringClass == integerClass);
System.out.println(stringObjClass == integerClass);</code></pre>

<p>输出结果：</p>
<pre><code class="hljs txt">true
true</code></pre>

<p>输出的结果证实了相同元素类型的Class实例是相同且共享的。</p>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>在这个阶段会讲述Class类中常用方法的使用</p>
<p><code>ReflectionBean</code>类：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectionBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassBean</span> </span>&#123;

  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> Integer age;
  String phone;
  <span class="hljs-keyword">protected</span> String address;
  <span class="hljs-keyword">public</span> Boolean sex;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflection</span><span class="hljs-params">()</span> </span>&#123;
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflection</span><span class="hljs-params">(String name)</span> </span>&#123;
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validInfo</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> name != <span class="hljs-keyword">null</span> &amp;&amp; name.length() &gt; <span class="hljs-number">0</span> &amp;&amp; Objects.nonNull(age);
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">(@NotNull String name)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.name = name;
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.name = name;
    <span class="hljs-keyword">this</span>.age = age;
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">()</span> </span>&#123;
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReflectionBean <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReflectionBean();
  &#125;
&#125;</code></pre>

<p><code>ClassBean</code>类：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassBean</span> </span>&#123;
    <span class="hljs-keyword">private</span> String className;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validClassName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> className != <span class="hljs-keyword">null</span> &amp;&amp; className.length() &gt; <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassBean</span><span class="hljs-params">()</span> </span>&#123;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassBean</span><span class="hljs-params">(String className)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.className = className;
    &#125;
&#125;</code></pre>

<h4 id="Construtor"><a href="#Construtor" class="headerlink" title="Construtor"></a><code>Construtor</code></h4><p>一个<code>Constructor</code>对应着类中的一个构造函数，可以使用<code>Class.getConstructors()</code>获取指定类所有的构造函数(私有无法获取)。也可以使用<code>Class.getConstructor(Class&lt;?&gt; ... paramType)</code>获取指定参数的构造方法。</p>
<p>测试代码：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;

    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
    Constructor&lt;ReflectionBean&gt; specificConstructor = reflectionBeanClass.getConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    System.out.println(specificConstructor.getName());
    System.out.println(Arrays.toString(specificConstructor.getParameterAnnotations()));
    System.out.println(specificConstructor.getParameterCount());
    System.out.println(Arrays.toString(specificConstructor.getParameterTypes()));

    Constructor&lt;?&gt;[] constructors = reflectionBeanClass.getConstructors();
    System.out.println(Arrays.toString(constructors));
&#125;</code></pre>



<p>输出结果：</p>
<pre><code class="hljs txt">io.better.jdk.reflection.ReflectionBean
[[Ljava.lang.annotation.Annotation;@1b701da1]
1
[class java.lang.String]
[public io.better.jdk.reflection.ReflectionBean(java.lang.String), public io.better.jdk.reflection.ReflectionBean()]</code></pre>

<p>上面代码中演示了<code>Class.getConstructors</code>和<code>Class.getConstructor(Class&lt;?&gt; ..params)</code>获取构造方法。</p>
<p>通过Constructor对象我们可以获取到构造方法中的<code>注解，参数，参数类型，参数数量</code>等信息，但这两种方式都不能获取私有构造方法。那如何获取私有的构造器呢？</p>
<p>使用<code>getDeclaredConstructors()</code>和<code>getDeclaredConstructor(Class&lt;?&gt; ..params)</code>可以获取到类中所有的构造方法，包括私有的。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredConstructors</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;
  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;

  <span class="hljs-comment">// 获取所有构造方法，包括私有</span>
  Constructor&lt;?&gt;[] declaredConstructors = reflectionBeanClass.getDeclaredConstructors();
  <span class="hljs-comment">// 获取指定构造方法</span>
  Constructor&lt;ReflectionBean&gt; specificDeclaredConstructor = reflectionBeanClass.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Integer</span>.<span class="hljs-title">class</span>)</span>;
&#125;</code></pre>

<p>介绍完<code>Constructor</code>对象的获取方式后，接下来通过<code>Constructor</code>对象来实例化目标对象。</p>
<p>我们可以通过<code>Constructor.newInstance(Object ...params)</code>方法传入实际的参数来创建目标对象。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConstructorInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
  <span class="hljs-comment">// 获取指定参数的公共构造方法</span>
  Constructor&lt;ReflectionBean&gt; stringConstructor = reflectionBeanClass.getConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
  <span class="hljs-comment">// 实例化</span>
  ReflectionBean reflectionBean = stringConstructor.newInstance(<span class="hljs-string">"Constructor"</span>);
  
  System.out.println(reflectionBean);
  <span class="hljs-comment">// 获取指定参数的私有构造方法</span>
  Constructor&lt;ReflectionBean&gt; declaredConstructor = reflectionBeanClass.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Integer</span>.<span class="hljs-title">class</span>)</span>;
  <span class="hljs-comment">// 设置成可访问，不设置，会出现访问私有构造方法</span>
  declaredConstructor.setAccessible(<span class="hljs-keyword">true</span>);
	<span class="hljs-comment">// 实例化</span>
  reflectionBean = declaredConstructor.newInstance(<span class="hljs-string">"DeclaredConstructor"</span>, <span class="hljs-number">1</span>);
  System.out.println(reflectionBean);
&#125;</code></pre>





<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><code>Method</code></h4><p>讲完<code>Constructor</code>的使用，已经能通过其创建对象了，那如何调用目标对象中的方法呢？</p>
<p>与Constructor类似，Class提供了<code>getMethods，getMethod(String methodName, Class&lt;?&gt; ...paramType)</code>方法分别获取执行类的<code>所有方法(包括静态方法，父类继承下来的方法)</code>和<code>指定方法</code>。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;

    Method[] methods = reflectionBeanClass.getMethods();

    Method method = reflectionBeanClass.getMethod(<span class="hljs-string">"reflection"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    System.out.println(<span class="hljs-string">"指定方法: "</span> + method.getName());

    <span class="hljs-keyword">for</span> (Method item : methods) &#123;
        System.out.println(item);
    &#125;
&#125;</code></pre>

<p>执行结果：</p>
<p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200506163345.png" srcset="/better.github.io/img/loading.gif" alt="image-20200506141809485"></p>
<p>从结果可以看出，私有方法未被获取到，和Constructor类似这两个方法不能获取私有方法，要想获取私有方法必须使用</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
		<span class="hljs-comment">// 获取所有方法，包括私有方法</span>
    Method[] methods = reflectionBeanClass.getDeclaredMethods();
		<span class="hljs-comment">// 获取指定私有方法</span>
    Method method = reflectionBeanClass.getDeclaredMethod(<span class="hljs-string">"validInfo"</span>);
    System.out.println(method.getName());
		<span class="hljs-comment">// 获取到所有方法的方法名</span>
    List&lt;String&gt; methodName = Stream.of(methods).map(Method::getName).collect(Collectors.toList());
    System.out.println(methodName);
&#125;</code></pre>

<p>执行结果：</p>
<pre><code class="hljs txt">validInfo
[equals, toString, hashCode, getName, setName, instance, reflection, reflection, validInfo, canEqual, getAge, setAge]</code></pre>

<p>获取类中方法已经了解，接下一来尝试调用执行一下方法。</p>
<p>与Constructor不太一样，要想执行方法需要调用<code>invoke(Object obj, Object... args)</code>。该方法接受两个参数，第一个为目标对象(即拥有此方法的类对象)，第二为方法所需的参数。当调用私有方法时做法与Constructor一致。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInvokedMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
  Constructor&lt;ReflectionBean&gt; constructor = reflectionBeanClass.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Integer</span>.<span class="hljs-title">class</span>)</span>;
  constructor.setAccessible(<span class="hljs-keyword">true</span>);
  ReflectionBean object = constructor.newInstance(<span class="hljs-string">"TEST"</span>, <span class="hljs-number">1</span>);

  Method method = reflectionBeanClass.getDeclaredMethod(<span class="hljs-string">"validInfo"</span>);
  method.setAccessible(<span class="hljs-keyword">true</span>);
	<span class="hljs-comment">// 执行方法，获取结果</span>
  Object methodResult = method.invoke(object);
  System.out.println(methodResult);
&#125;</code></pre>



<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a><code>Field</code></h4><p>与Method类似，我们可以使用<code>getFields，getField(String name)</code>两个方法来获取类中所有非私有的字段。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;

    Field[] fields = reflectionBeanClass.getFields();
    <span class="hljs-keyword">for</span> (Field field : fields) &#123;
        System.out.println(field);
    &#125;
&#125;

<span class="hljs-comment">// 结果：public java.lang.Boolean io.better.jdk.reflection.ReflectionBean.sex</span></code></pre>

<p>这两个方法只能获取<code>公共字段(public修饰)</code>，<code>private，default，protected</code>都获取不到。</p>
<p>我们可以使用<code>getDeclaredFields</code>，<code>getDeclaredField</code>两个方法来获取所有的字段和指定字段，</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;

    Field[] fields = reflectionBeanClass.getDeclaredFields();
    <span class="hljs-keyword">for</span> (Field field : fields) &#123;
        System.out.println(field);
    &#125;
    Field age = reflectionBeanClass.getDeclaredField(<span class="hljs-string">"age"</span>);
    System.out.println(age);
&#125;</code></pre>

<p>执行结果：</p>
<img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200506163353.png" srcset="/better.github.io/img/loading.gif" alt="image-20200506150309477" style="zoom:50%;" />

<p>如果想要获取某个字段对应的值，则需要调用<code>get(Object obj)</code>方法，传入包含此字段的目标类对象，私有字段需要调用<code>setAccessible()</code>方法。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFieldMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;

    Constructor&lt;ReflectionBean&gt; constructor = reflectionBeanClass.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Integer</span>.<span class="hljs-title">class</span>)</span>;
    constructor.setAccessible(<span class="hljs-keyword">true</span>);
    ReflectionBean object = constructor.newInstance(<span class="hljs-string">"TEST"</span>, <span class="hljs-number">1</span>);

    Field age = reflectionBeanClass.getDeclaredField(<span class="hljs-string">"age"</span>);
    age.setAccessible(<span class="hljs-keyword">true</span>);
    System.out.println(age.getDeclaringClass());
    System.out.println(age.get(object));
&#125;
<span class="hljs-comment">// 执行结果</span>
<span class="hljs-comment">// class io.better.jdk.reflection.ReflectionBean</span>
<span class="hljs-comment">// 1</span></code></pre>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Constructor，Method，Field</code>三个类分别 对应类中 的<code>构造方法、方法、字段</code>，分别提供了<code>getDeclared</code>开头的方法来获取对应所有的信息。</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance()"></a><code>newInstance()</code></h4><p>在获取到类的Class对象时，可以通过调用此方法来创建目标类对象，该方法会默认调用类的<code>无参构造方法</code>来创建对象。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNewInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;
  ReflectionBean reflectionBean = reflectionBeanClass.newInstance();
  System.out.println(reflectionBean);
&#125;</code></pre>



<h4 id="isInstance-Object-obj"><a href="#isInstance-Object-obj" class="headerlink" title="isInstance(Object obj)"></a><code>isInstance(Object obj)</code></h4><p>该方法用于断定指定Object是赋值兼容与此表示的对象Class ，等效<code>instanceof</code>运算符。</p>
<pre><code class="hljs java">Class&lt;String&gt; stringClass = String<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;

stringClass.isInstance(<span class="hljs-string">"test"</span>); <span class="hljs-comment">// 结果=true，类型匹配</span>
stringClass.isInstance(<span class="hljs-number">123456</span>); <span class="hljs-comment">// 结果=false，类型不匹配</span></code></pre>





<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="反射进行数组扩容"><a href="#反射进行数组扩容" class="headerlink" title="反射进行数组扩容"></a>反射进行数组扩容</h3><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testArrayExtension</span><span class="hljs-params">()</span> </span>&#123;
  String[] stringArray = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>&#125;;
  System.out.println(<span class="hljs-string">"原始数组长度: "</span> + stringArray.length);

  Object newStringArray = ArrayExtension(stringArray, stringArray.length * <span class="hljs-number">2</span>);
  System.out.println(<span class="hljs-string">"扩容后数组长度: "</span> + Array.getLength(newStringArray));
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">ArrayExtension</span><span class="hljs-params">(Object sourceArray, <span class="hljs-keyword">int</span> extensionLength)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (extensionLength &lt; Array.getLength(sourceArray))
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"扩展长度不合法"</span>);

  Class&lt;?&gt; componentType = sourceArray.getClass().getComponentType();
  Object newStringArray = Array.newInstance(componentType, extensionLength);
  System.arraycopy(sourceArray, <span class="hljs-number">0</span>, newStringArray, <span class="hljs-number">0</span>, Array.getLength(sourceArray));

  <span class="hljs-keyword">return</span> newStringArray;
&#125;</code></pre>



<h3 id="反射跳过泛型检查"><a href="#反射跳过泛型检查" class="headerlink" title="反射跳过泛型检查"></a>反射跳过泛型检查</h3><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJumpTypeCheck</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
  List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

  stringList.add(<span class="hljs-string">"a"</span>);
  stringList.add(<span class="hljs-string">"b"</span>);
  stringList.add(<span class="hljs-string">"c"</span>);

  Class&lt;? extends List&gt; listClass = stringList.getClass();

  Method addMethod = listClass.getMethod(<span class="hljs-string">"add"</span>, Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
  <span class="hljs-comment">// 向集合中添加了一个int类型的值</span>
  addMethod.invoke(stringList, <span class="hljs-number">1</span>);
  <span class="hljs-comment">// 结果为4</span>
  System.out.println(stringList.size());
&#125;</code></pre>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/better.github.io/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/better.github.io/tags/Reflection/">Reflection</a>
                    
                      <a class="hover-with-bg" href="/better.github.io/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="#" target="_blank" rel="nofollow noopener">
        <span>IO.BETTER</span>
      </a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/better.github.io/js/main.js" ></script>


  <script  src="/better.github.io/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/better.github.io/js/clipboard-use.js" ></script>






<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Reflection&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/better.github.io/js/local-search.js" ></script>
  <script>
    var path = "/better.github.io/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>

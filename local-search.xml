<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ioc-Spring-BeanDefinition注册</title>
    <link href="/2020/10/09/spring-bean-definition-registry/index/"/>
    <url>/2020/10/09/spring-bean-definition-registry/index/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-Bean注册"><a href="#Ioc-Bean注册" class="headerlink" title="Ioc-Bean注册"></a>Ioc-Bean注册</h1><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><blockquote><p>本文主要讲述BeanDefinitionRegistry接口是如何注册BeanDefinition？</p><p>主要讲解DefaultListableBeanFactory，AnnotationConfigApplicationContext，GenericApplicationContext三个上下文是如何对BeanDefinition进行注册的。</p></blockquote><h2 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上面讲到了BeanDefinition的读取方式，拿到BeanDefinition后需要将其注册到容器中，Spring是用什么将其注册到容器中的呢？</p><p>没错就是上面源代码中频繁提到的BeanDefinitionRegistry对象。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BeanDefinitionRegistry是包含BeanDefinition的注册的接口，这是Spring Bean工厂软件包中唯一封装Bean定义注册的接口。</p><p>标准BeanFactory接口仅涵盖对完全配置的工厂实例的访问。Spring的<code>BeanDefinitionReader</code>希望可以使用此接口的实现。</p><p>Spring核心中的已知实现者是<code>DefaultListableBeanFactory</code>和<code>GenericApplicationContext</code>。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180016.png" srcset="/img/loading.gif" alt="image-20200517161204618" style="zoom:50%;" /><p>我们看到了<code>DefaultListableBeanFactory</code>、<code>GenericApplicationContext</code>、<code>AnnotationConfigApplicationContext</code>等类。</p><p>重点关注上面几个类的实现。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AliasRegistry</span> </span>&#123;  <span class="hljs-comment">// 注册BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 根据指定的Bean名称删除BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;  <span class="hljs-comment">// 根据指定的Bean名称获取BeanDefinition</span>  <span class="hljs-function">BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;  <span class="hljs-comment">// 是否包含指定的Bean名称</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span></span>;  <span class="hljs-comment">// 返回注册器中所有的BeanDefinition名称</span>  String[] getBeanDefinitionNames(); <span class="hljs-comment">// 获取BeanDefinition的数量</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 指定的Bean名称是否被使用</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span></span>;&#125;</code></pre><p>接口中定义了BeanDefinition增删改查的接口，并继承了AliasRegistry接口。</p><h3 id="AliasRegistry"><a href="#AliasRegistry" class="headerlink" title="AliasRegistry"></a><code>AliasRegistry</code></h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>顾名思义AliasRegistry是一个别名注册器，用于注册别名。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnnotationConfigRegistry</span> </span>&#123;  <span class="hljs-comment">// 注册指定的Class数组</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span></span>;  <span class="hljs-comment">// 注册指定包路径下的Bean</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span></span>;&#125;</code></pre><h3 id="GenericApplicationContext"><a href="#GenericApplicationContext" class="headerlink" title="GenericApplicationContext"></a><code>GenericApplicationContext</code></h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>GenericApplicationContext是通用ApplicationContext实现，其内部引用了<code>DefaultListableBeanFactory</code>实例，实现BeanDefinitionRegistry接口，以便允许将任何Bean定义读取器应用于该接口。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>通用做法是通过BeanDefinitionRegistry接口注册各种Bean定义，然后调用<code>refresh()</code>以使用应用程序上下文语义来初始化这些Bean（处理org.springframework.context.ApplicationContextAware，自动检测BeanFactoryPostProcessors等）。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>与为每次刷新创建一个新的内部BeanFactory实例的其他ApplicationContext实现相反，此上下文的内部BeanFactory从一开始就可用，以便能够在其上注册BeanDefinition。<code>refresh()只能被调用一次</code>。</p><p>对于应该以可刷新方式读取特殊bean定义格式的自定义应用程序上下文实现，请考虑从<strong>AbstractRefreshableApplicationContext</strong>基类派生。</p><h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistry</span> </span>&#123;<span class="hljs-comment">// BeanFactory，此对象也实现了BeanDefinitionRegistry接口</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DefaultListableBeanFactory beanFactory;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericApplicationContext</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();  &#125;  <span class="hljs-comment">// 注册BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory.registerBeanDefinition(beanName, beanDefinition);  &#125;<span class="hljs-comment">// 删除BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory.removeBeanDefinition(beanName);  &#125;  <span class="hljs-comment">// 获取BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanFactory.getBeanDefinition(beanName);  &#125;<span class="hljs-comment">// Bean是否被使用</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanFactory.isBeanNameInUse(beanName);  &#125;  <span class="hljs-comment">// 注册bean别名</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String beanName, String alias)</span> </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory.registerAlias(beanName, alias);  &#125;<span class="hljs-comment">// 删除bean别名</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAlias</span><span class="hljs-params">(String alias)</span> </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory.removeAlias(alias);  &#125;  <span class="hljs-comment">// 是否存在别名</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlias</span><span class="hljs-params">(String beanName)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanFactory.isAlias(beanName);  &#125;  <span class="hljs-comment">// 注册Bean</span>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(@Nullable String beanName, Class&lt;T&gt; beanClass,</span></span><span class="hljs-function"><span class="hljs-params">                               @Nullable Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;    ClassDerivedBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> ClassDerivedBeanDefinition(beanClass);    <span class="hljs-keyword">if</span> (supplier != <span class="hljs-keyword">null</span>) &#123;      beanDefinition.setInstanceSupplier(supplier);    &#125;    <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;      customizer.customize(beanDefinition);    &#125;    String nameToUse = (beanName != <span class="hljs-keyword">null</span> ? beanName : beanClass.getName());    registerBeanDefinition(nameToUse, beanDefinition);  &#125;&#125;</code></pre><p><code>GenericApplicationContext</code>内部持有了<code>DefaultListableBeanFactory</code>引用，并简单的实现了<strong>BeanDefinitionRegistry</strong>的接口，不过最终操作还是交给了<code>DefaultListableBeanFactory</code>对象来进行完成。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGenericApplicationContext</span><span class="hljs-params">()</span> </span>&#123;  GenericApplicationContext applicationContext = <span class="hljs-keyword">new</span> GenericApplicationContext();  AnnotatedBeanDefinitionReader definitionReader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(applicationContext);  definitionReader.registerBean(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  applicationContext.refresh();  IocBean iocBean = applicationContext.getBean(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  System.out.println(iocBean);&#125;</code></pre><h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a><code>DefaultListableBeanFactory</code></h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>DefaultListableBeanFactory是Spring的ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现，基于BeanDefinition元数据的成熟bean工厂，可通过后处理器进行扩展。</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>典型的用法是在访问bean之前先注册所有bean定义（可能是从bean定义文件中读取）。因此，按名称查找Bean是对本地Bean定义表进行的廉价操作，该操作对预先解析的Bean定义元数据对象进行操作。对于<code>ListableBeanFactory</code>接口的替代实现，请看一下<code>StaticListableBeanFactory</code>，它管理现有的bean实例，而不是根据bean定义创建新的bean实例。</p><h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><p>代码中删除了无关的代码，因为我们关注的是<code>BeanDefinitionRegistry</code>相关的操作。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAutowireCapableBeanFactory</span></span><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigurableListableBeanFactory</span>, <span class="hljs-title">BeanDefinitionRegistry</span>, <span class="hljs-title">Serializable</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> allowBeanDefinitionOverriding = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 管理所有的BeanDefinition</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);  <span class="hljs-comment">// 管理所有的单例Bean或非单例名称，key=依赖的Class</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">64</span>);  <span class="hljs-comment">// 管理所有的单例Bean名称，key=依赖的Class</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">64</span>);  <span class="hljs-comment">// 根据注册的顺序，管理所有的BeanDefinition名称</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">256</span>);  <span class="hljs-comment">// 管理手动注册的单示例Bean</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Set&lt;String&gt; manualSingletonNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">16</span>);<span class="hljs-comment">// 构造函数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultListableBeanFactory</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>();  &#125;<span class="hljs-comment">// 注册BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<span class="hljs-comment">// 判断次BeanDefinition是否被加载过</span>    BeanDefinition existingDefinition = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 被加载过</span>      <span class="hljs-comment">// 是否允许BeanDefinition重写</span>      <span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);      &#125;      <span class="hljs-comment">// 新的BeanDefinition会覆盖就的BeanDefinition</span>      <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);    &#125;    <span class="hljs-comment">// 未被加载过</span>    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;<span class="hljs-comment">// 是否已经开始创建Bean</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) &#123;          <span class="hljs-comment">// 将BeanDefinition放入到beanDefinitionMap中</span>          <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);          List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);          updatedDefinitions.addAll(<span class="hljs-keyword">this</span>.beanDefinitionNames);          updatedDefinitions.add(beanName);          <span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;          removeManualSingletonName(beanName);        &#125;      &#125;      <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 将BeanDefinition放入到beanDefinitionMap中</span>        <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);        <span class="hljs-keyword">this</span>.beanDefinitionNames.add(beanName);        <span class="hljs-comment">// 删除</span>        removeManualSingletonName(beanName);      &#125;      <span class="hljs-keyword">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword">null</span>;    &#125;<span class="hljs-comment">// 已经存在此BeanDefinition或者此beanName已经存在</span>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span> || containsSingleton(beanName)) &#123;      <span class="hljs-comment">// 重置此BeanDefinition</span>      resetBeanDefinition(beanName);    &#125;  &#125;<span class="hljs-comment">// 删除BeanDefinition</span>  <span class="hljs-comment">// ①：删除beanDefinitionNames中name，②：调用resetBeanDefinition从beanDefinitionMap中删除</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;<span class="hljs-comment">// 从Map中删除BeanDefinition</span>    BeanDefinition bd = <span class="hljs-keyword">this</span>.beanDefinitionMap.remove(beanName);    <span class="hljs-keyword">if</span> (bd == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 删除失败（不存在此BeanDefinition），抛出异常</span>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(beanName);    &#125;<span class="hljs-comment">// 是否有Bean已经被创建</span>    <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;      <span class="hljs-comment">// 加锁</span>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) &#123;        List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);       <span class="hljs-comment">// 删除</span>        updatedDefinitions.remove(beanName);        <span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;  <span class="hljs-comment">// 重新赋值</span>      &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 直接删除</span>      <span class="hljs-keyword">this</span>.beanDefinitionNames.remove(beanName);    &#125;<span class="hljs-comment">// 重置BeanDefinition</span>    resetBeanDefinition(beanName);  &#125;<span class="hljs-comment">// 重置BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetBeanDefinition</span><span class="hljs-params">(String beanName)</span> </span>&#123;    <span class="hljs-comment">// 如果存在则删除指定Bean名称对应的合并的BeanDefinition</span>    clearMergedBeanDefinition(beanName);    destroySingleton(beanName);<span class="hljs-comment">// 执行过滤出的MergedBeanDefinitionPostProcessor</span>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;      <span class="hljs-keyword">if</span> (processor <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;        ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);      &#125;    &#125;<span class="hljs-comment">// 遍历BeanDefinition名称Map</span>    <span class="hljs-keyword">for</span> (String bdName : <span class="hljs-keyword">this</span>.beanDefinitionNames) &#123;      <span class="hljs-keyword">if</span> (!beanName.equals(bdName)) &#123;        BeanDefinition bd = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(bdName);        <span class="hljs-keyword">if</span> (bd != <span class="hljs-keyword">null</span> &amp;&amp; beanName.equals(bd.getParentName())) &#123;          <span class="hljs-comment">// 重置BeanDefinition</span>          resetBeanDefinition(bdName);        &#125;      &#125;    &#125;  &#125;<span class="hljs-comment">// 获取BeanDefinition</span><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;    <span class="hljs-comment">// 调用beanDefinitionMap.get()</span>BeanDefinition bd = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);<span class="hljs-keyword">if</span> (bd == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 没有抛出异常</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(beanName);&#125;<span class="hljs-keyword">return</span> bd;&#125;  <span class="hljs-comment">// 是否存在BeanDefinition</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span> </span>&#123;Assert.notNull(beanName, <span class="hljs-string">"Bean name must not be null"</span>);    <span class="hljs-comment">// 操作成员变量beanDefinitionMap</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanDefinitionMap.containsKey(beanName);&#125;&#125;</code></pre><p><code>DefaultListableBeanFactory</code>声明了多个<code>beanDefinitionNames（List类型）</code>，<code>beanDefinitionMap（Map类型）</code>等属性，它们分别用于存储<code>BeanDefinition名称</code>和<code>BeanDefinition</code>。</p><p>在对<code>BeanDefinitionRegistry</code>接口方法的实现中底层操作的都是这两个<code>beanDefinitionNames</code>，<code>beanDefinitionMap</code>属性。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDefaultListableBeanFactory</span><span class="hljs-params">()</span> </span>&#123;    DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();    BeanDefinition beanDefinition = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    beanFactory.registerBeanDefinition(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>(), <span class="hljs-title">beanDefinition</span>)</span>;    System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));&#125;</code></pre><h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><code>AnnotationConfigApplicationContext</code>是一个独立的应用程序上下文，接受组件类作为输入-特别是使用@Configuration注释的类，还可以使用javax.inject注释使用普通的@Component类型和符合JSR-330的类。</p><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>允许使用<code>register（Class ...）</code>方法一对一注册类，以及使用<code>scan（String ...）方法</code>进行类路径扫描，这两个方法定义在<code>AnnotationConfigRegistry</code>接口中。</p><p>如果有多个<code>@Configuration</code>类，则在<code>以后的类中定义的@Bean方法将覆盖在先前的类中定义的方法</code>。可以利用此属性通过额外的@Configuration类有意覆盖某些bean定义。</p><h4 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationConfigApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotationConfigRegistry</span> </span>&#123;<span class="hljs-comment">// 注解BeanDefinition的读取器和注册器</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotatedBeanDefinitionReader reader;<span class="hljs-comment">// ClassPath下BeanDefinition扫描器，扫描Component，Service，Controller，Repository等注解标识的类 </span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassPathBeanDefinitionScanner scanner;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword">this</span>);  &#125;<span class="hljs-comment">// 使用指定类的Class数组进行初始化</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;    <span class="hljs-keyword">this</span>();    register(componentClasses);    refresh();  &#125;  <span class="hljs-comment">// 使用指定包路径数组进行初始化</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;    <span class="hljs-keyword">this</span>();    scan(basePackages);    refresh();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;    Assert.notEmpty(componentClasses, <span class="hljs-string">"At least one component class must be specified"</span>);    <span class="hljs-comment">// 调用AnnotatedBeanDefinitionReader注册Bean</span>    <span class="hljs-keyword">this</span>.reader.register(componentClasses);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;    Assert.notEmpty(basePackages, <span class="hljs-string">"At least one base package must be specified"</span>);    <span class="hljs-keyword">this</span>.scanner.scan(basePackages);  &#125;<span class="hljs-comment">// 重写父类的registerBean方法，因为reader拥有注册Bean的功能</span>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(@Nullable String beanName, Class&lt;T&gt; beanClass,</span></span><span class="hljs-function"><span class="hljs-params">                               @Nullable Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;    <span class="hljs-keyword">this</span>.reader.registerBean(beanClass, beanName, supplier, customizers);  &#125;&#125;</code></pre><p>AnnotationConfigApplicationContext引用了<code>ClassPathBeanDefinitionScanner</code>，<code>AnnotatedBeanDefinitionReader</code>属性。</p><p>并将最终的Bean注册交予了<code>AnnotatedBeanDefinitionReader</code>来处理，而<code>ClassPathBeanDefinitionScanner</code>则用于扫描类路径下所有带<code>Component，Service，Controller，Repository</code>注解的类。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAnnotationConfigApplicationContext</span><span class="hljs-params">()</span> </span>&#123;  AnnotationConfigApplicationContext applicationContext =     <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  IocBean bean = applicationContext.getBean(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  System.out.println(bean);&#125;</code></pre><p>可以看出AnnotationConfigApplicationContext的使用非常的简单，只需简单传递一个要初始化的Bean的Class即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>GenericApplicationContext</code>：对BeanDefinitionRegistry做了通用的实现，内部引用了DefaultListableBeanFactory，将操作转发给了DefaultListableBeanFactory。</p><p><code>DefaultListableBeanFactory</code>：该类封装了处理BeanDefinition的逻辑，底层操作了许多Map。</p><p><code>AnnotationConfigApplicationContext</code>：该类虽然继承了<code>GenericApplicationContext</code>类，但却每调用父类的方法，而是将注册Bean的操作转发给了内部的AnnotatedBeanDefinitionReader对象。</p><p><code>SimpleBeanDefinitionRegistry</code>：简单的BeanDefinitionRegistry，未内置工厂，可用作测试BeanDefinition 注册。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-BeanDefinition读取</title>
    <link href="/2020/10/09/spring-bean-definition-reader/index/"/>
    <url>/2020/10/09/spring-bean-definition-reader/index/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-BeanDefinition的读取与注册"><a href="#Ioc-BeanDefinition的读取与注册" class="headerlink" title="Ioc-BeanDefinition的读取与注册"></a>Ioc-BeanDefinition的读取与注册</h1><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><blockquote><p> 本文主要讲述BeanDefinition的读取与注册，主要涉及到的接口是BeanDefinitionReader和BeanDefinitionRegistry。</p><p> 本文会从这两个接口出发，分析其实现类，不同环境的不同实现，及其优缺点。</p></blockquote><h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BeanDefinitionReader接口是个一个BeanDefinition的读取规范定义接口，定义了 “资源” 和 “字符串” 位置参数指定加载方法。</p><p>当然，具体的BeanDefinitionReader可以为BeanDefinition添加特定于其BeanDefinition格式的其他加载和注册方法。</p><p>具体的BeanDefinitionReader不必实现此接口。它仅对希望遵循标准命名约定的bean定义读者提供建议。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180030.png" srcset="/img/loading.gif" alt="image-20200516101622162"></p><p>老版本中经常使用的是<code>XMLBeanDefinitionReader</code>，注解驱动版本中经常使用<code>AnnotatedBeanDefinitionReader</code>。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;  <span class="hljs-comment">// 返回一个BeanFactory注册BeanDefinition，其实现了BeanDefinitionRegistry接口</span>  <span class="hljs-comment">// 封装了与BeanDefinition处理相关的方法。</span>  <span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 返回资源加载器以用于资源位置</span>  <span class="hljs-comment">// 可以检查ResourcePatternResolver接口并进行相应的转换，以针对给定的资源模式加载多个资源。</span>  <span class="hljs-comment">// 返回值为null表示此BeanDefinitionReader无法使用绝对资源加载</span>  <span class="hljs-function">ResourceLoader <span class="hljs-title">getResourceLoader</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回用于加载Bean的类加载器</span>  <span class="hljs-comment">// null建议不要急于加载Bean类，而只是用类名注册Bean定义，并在以后（或永不解析）相应的类。</span>  <span class="hljs-function">ClassLoader <span class="hljs-title">getBeanClassLoader</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回BeanNameGenerator用于匿名Bean名称（未指定显式Bean名称）。</span>  <span class="hljs-function">BeanNameGenerator <span class="hljs-title">getBeanNameGenerator</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 使用指定的Resource加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 使用指定的Resource数组加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 使用指定的location加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 使用指定的location数组加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;&#125;</code></pre><p>BeanDefinitionReader重载了不同参数的<code>loadBeanDefinitions</code>方法用于加载BeanDefinition。</p><h3 id="AbstractBeanDefinitionReader"><a href="#AbstractBeanDefinitionReader" class="headerlink" title="AbstractBeanDefinitionReader"></a><code>AbstractBeanDefinitionReader</code></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>AbstractBeanDefinitionReader是实现了BeanDefinitionReader接口抽象基类。提供常见的属性，例如要处理的BeanFactory以及用于加载bean类的类加载器。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBeanDefinitionReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionReader</span>, <span class="hljs-title">EnvironmentCapable</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinitionRegistry registry;  <span class="hljs-comment">// BeanDefinition注册器</span>  <span class="hljs-keyword">private</span> ResourceLoader resourceLoader; <span class="hljs-comment">// 资源加载器</span>  <span class="hljs-keyword">private</span> ClassLoader beanClassLoader;<span class="hljs-comment">// 类加载器</span>  <span class="hljs-keyword">private</span> Environment environment;<span class="hljs-comment">// 环境变量</span>  <span class="hljs-keyword">private</span> BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;  <span class="hljs-comment">// Bean名称生成器</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;    Assert.notNull(registry, <span class="hljs-string">"BeanDefinitionRegistry must not be null"</span>);    <span class="hljs-keyword">this</span>.registry = registry;    <span class="hljs-comment">// 如果实现了资源加载器接口</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registry <span class="hljs-keyword">instanceof</span> ResourceLoader) &#123;      <span class="hljs-keyword">this</span>.resourceLoader = (ResourceLoader) <span class="hljs-keyword">this</span>.registry;    &#125;<span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 创建默认资源加载器</span>      <span class="hljs-keyword">this</span>.resourceLoader = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();    &#125;    <span class="hljs-comment">// 判断拥有环境变量信息</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registry <span class="hljs-keyword">instanceof</span> EnvironmentCapable) &#123;      <span class="hljs-keyword">this</span>.environment = ((EnvironmentCapable) <span class="hljs-keyword">this</span>.registry).getEnvironment();    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 创建一个标准的环境变量对象</span>      <span class="hljs-keyword">this</span>.environment = <span class="hljs-keyword">new</span> StandardEnvironment();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;    Assert.notNull(resources, <span class="hljs-string">"Resource array must not be null"</span>);    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (Resource resource : resources) &#123;      <span class="hljs-comment">// 最终会调用子类实现的loadBeanDefinitions方法</span>      count += loadBeanDefinitions(resource);    &#125;    <span class="hljs-keyword">return</span> count;  &#125;&#125;</code></pre><p><code>AbstractBeanDefinitionReader</code>对<code>BeanDefinitionReader</code>进行了简单的实现，声明<code>registry</code>，<code>resourceLoader</code>，<code>beanClassLoader</code>，<code>environment</code>，<code>beanNameGenerator</code>等属性。</p><h3 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a><code>XmlBeanDefinitionReader</code></h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>XmlBeanDefinitionReader用于读取XML，将实际的XML文档读取委托给<code>BeanDefinitionDocumentReader</code>接口的实现。</p><p>此类加载DOM Document 并将BeanDefinitionDocumentReader应用于该Document。</p><h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlBeanDefinitionReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanDefinitionReader</span> </span>&#123;    <span class="hljs-comment">// BeanDefinitionDocumentReader读取解析Document并转换成BeanDefinition</span>    <span class="hljs-keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass =      DefaultBeanDefinitionDocumentReader<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    <span class="hljs-comment">// 命名空间解析器</span>    <span class="hljs-keyword">private</span> NamespaceHandlerResolver namespaceHandlerResolver;    <span class="hljs-comment">// 将XML文件加载成Document对象</span>    <span class="hljs-keyword">private</span> DocumentLoader documentLoader = <span class="hljs-keyword">new</span> DefaultDocumentLoader();    <span class="hljs-comment">// 用于解析XML中的DTD文件</span>    <span class="hljs-keyword">private</span> EntityResolver entityResolver;    <span class="hljs-comment">// 绑定当前线程正在处理的XML文件集合 </span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded =      <span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">"XML bean definition resources currently being loaded"</span>);    <span class="hljs-comment">// 构造器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XmlBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;      <span class="hljs-keyword">super</span>(registry);    &#125;    <span class="hljs-comment">// 实现BeanDefinitionReader定义的接口</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;      <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> EncodedResource(resource));    &#125;    <span class="hljs-comment">// 重载的loadBeanDefinitions方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;      <span class="hljs-comment">// 获取当前线程正在处理的XML集合</span>      Set&lt;EncodedResource&gt; currentResources = <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.get();      <span class="hljs-keyword">if</span> (currentResources == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 为空则初始化</span>        currentResources = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 默认大小为4</span>        <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);      &#125;      <span class="hljs-keyword">if</span> (!currentResources.add(encodedResource)) &#123;   <span class="hljs-comment">// 将当前正在处理的encodedResource添加到Set集合中</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-comment">// 添加失败报错</span>          <span class="hljs-string">"Detected cyclic loading of "</span> + encodedResource + <span class="hljs-string">" - check your import definitions!"</span>);      &#125;      <span class="hljs-comment">// 获取到XMl文件的输入流</span>      InputStream inputStream = encodedResource.getResource().getInputStream();      <span class="hljs-comment">// 一个InputSource代表一个XML实体</span>      InputSource inputSource = <span class="hljs-keyword">new</span> InputSource(inputStream);      <span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 为InputSource设置编码</span>        inputSource.setEncoding(encodedResource.getEncoding());      &#125;      <span class="hljs-comment">// 调用doLoadBeanDefinitions方法(真正的执行操作)</span>      <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());    &#125;    <span class="hljs-comment">// 忽略部分代码</span>  &#125;  <span class="hljs-comment">// 根据指定的XML文件加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 使用documentLoader将XML转换成Document</span>      Document doc = doLoadDocument(inputSource, resource);      <span class="hljs-comment">// 注册BeanDefinition</span>      <span class="hljs-keyword">int</span> count = registerBeanDefinitions(doc, resource);      <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (SAXParseException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (SAXException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (ParserConfigurationException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (IOException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;&#125;  &#125;  <span class="hljs-comment">// 将XML转换成Docment</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> Document <span class="hljs-title">doLoadDocument</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="hljs-keyword">this</span>.errorHandler,                                            getValidationModeForResource(resource), isNamespaceAware());  &#125;  <span class="hljs-comment">// 注册BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;    <span class="hljs-comment">// 创建BeanDefinition文档读取器，</span>    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();    <span class="hljs-keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;  &#125;  <span class="hljs-comment">// 创建BeanDefinitionDocumentReader对象，用于将Document解析成BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> BeanDefinitionDocumentReader <span class="hljs-title">createBeanDefinitionDocumentReader</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(<span class="hljs-keyword">this</span>.documentReaderClass);  &#125;  <span class="hljs-comment">// XmlReaderContext是ReaderContext的扩展，提供对XmlBeanDefinitionReader中配置的NamespaceHandlerResolver的访问。</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> XmlReaderContext <span class="hljs-title">createReaderContext</span><span class="hljs-params">(Resource resource)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XmlReaderContext(resource, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.eventListener,                                <span class="hljs-keyword">this</span>.sourceExtractor, <span class="hljs-keyword">this</span>, getNamespaceHandlerResolver());  &#125;  <span class="hljs-comment">// 命名空间解析器</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> NamespaceHandlerResolver <span class="hljs-title">getNamespaceHandlerResolver</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.namespaceHandlerResolver == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">this</span>.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.namespaceHandlerResolver;  &#125;&#125;</code></pre><p><code>XMLBeanDefinitionReader</code>实际上只做了<code>Document</code>文档的解析操作，真正的解析BeanDefinition操作交给了<code>BeanDefinitionDocumentReader</code>（接口）实例（默认为<code>DefaultBeanDefinitionDocumentReader</code>）来解析。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>Xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"iocBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"io.better.spring.ioc.IocBean"</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">"init"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"destroy"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"test-xml"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testXmlBeanDefinitionReader</span><span class="hljs-params">()</span> </span>&#123;    AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();    BeanDefinitionReader definitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(applicationContext);    definitionReader.loadBeanDefinitions(<span class="hljs-string">"Ioc.xml"</span>);    applicationContext.refresh();    IocBean iocBean = (IocBean) applicationContext.getBean(<span class="hljs-string">"iocBean"</span>);    System.out.println(iocBean);&#125;</code></pre><pre><code class="hljs txt">IocBean ConstructorIocBean custom initIocBean&#123;name&#x3D;&#39;test-xml&#39;&#125;</code></pre><h4 id="BeanDefinitionDocumentReader"><a href="#BeanDefinitionDocumentReader" class="headerlink" title="BeanDefinitionDocumentReader"></a>BeanDefinitionDocumentReader</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>SPI，<code>BeanDefinitionDocumentReader</code>用于解析带有BeanDefinition的Xml Document。</p><h5 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionDocumentReader</span> </span>&#123;  <span class="hljs-comment">//注册BeanDefinition，doc：当前Xml对应的Document对象，readerContext：当前BeanDefinitionReader的长下文</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;&#125;</code></pre><h4 id="DefaultBeanDefinitionDocumentReader"><a href="#DefaultBeanDefinitionDocumentReader" class="headerlink" title="DefaultBeanDefinitionDocumentReader"></a>DefaultBeanDefinitionDocumentReader</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>BeanDefinitionDocumentReader的唯一实现类，封装了解析并组装BeanDefinition的具体操作。</p><h5 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultBeanDefinitionDocumentReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionDocumentReader</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT;<span class="hljs-comment">// 常量，标识一些标签</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NESTED_BEANS_ELEMENT = <span class="hljs-string">"beans"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ALIAS_ELEMENT = <span class="hljs-string">"alias"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME_ATTRIBUTE = <span class="hljs-string">"name"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ALIAS_ATTRIBUTE = <span class="hljs-string">"alias"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String IMPORT_ELEMENT = <span class="hljs-string">"import"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESOURCE_ATTRIBUTE = <span class="hljs-string">"resource"</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PROFILE_ATTRIBUTE = <span class="hljs-string">"profile"</span>;  <span class="hljs-comment">// 当前BeanDefinitionReader的上下文</span>  <span class="hljs-keyword">private</span> XmlReaderContext readerContext;<span class="hljs-comment">// 解析Document中的值并赋值给BeanDefinition</span>  <span class="hljs-keyword">private</span> BeanDefinitionParserDelegate delegate;  <span class="hljs-comment">// 核心入口</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;    <span class="hljs-keyword">this</span>.readerContext = readerContext;    doRegisterBeanDefinitions(doc.getDocumentElement());  &#125;  <span class="hljs-comment">// 核心方法</span>  <span class="hljs-comment">// </span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> </span>&#123;    BeanDefinitionParserDelegate parent = <span class="hljs-keyword">this</span>.delegate;    <span class="hljs-keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<span class="hljs-comment">// 处理Xml前置操作</span>    preProcessXml(root);    <span class="hljs-comment">// 解析BeanDefinition</span>    parseBeanDefinitions(root, <span class="hljs-keyword">this</span>.delegate);    <span class="hljs-comment">// 处理Xml后置操作</span>    postProcessXml(root);    <span class="hljs-keyword">this</span>.delegate = parent;  &#125;  <span class="hljs-comment">// 解析BeanDefinition核心方法</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;      NodeList nl = root.getChildNodes();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;        Node node = nl.item(i);        <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123; <span class="hljs-comment">// 是否是元素标签</span>          Element ele = (Element) node;          <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;            <span class="hljs-comment">// 处理默认元素</span>            parseDefaultElement(ele, delegate);          &#125;          <span class="hljs-keyword">else</span> &#123;            delegate.parseCustomElement(ele);          &#125;        &#125;      &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;      delegate.parseCustomElement(root);    &#125;  &#125;  <span class="hljs-comment">// 解析默认元素</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;    <span class="hljs-comment">// import标签</span>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;      importBeanDefinitionResource(ele);    &#125;    <span class="hljs-comment">// alias标签</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;      processAliasRegistration(ele);    &#125;    <span class="hljs-comment">// beans标签</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;      processBeanDefinition(ele, delegate);    &#125;    <span class="hljs-comment">// 内嵌bean标签</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;      <span class="hljs-comment">// recurse</span>      doRegisterBeanDefinitions(ele);    &#125;  &#125;  <span class="hljs-comment">// 解析beans标签，并调用registry进行注册</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;    <span class="hljs-comment">// BeanDefinitionHolder内部包装了一个BeanDefinition</span>    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);      <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 注册BeanDefinition</span>        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());      &#125;      <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;&#125;      <span class="hljs-comment">// 发布注册完成事件</span>      getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));    &#125;  &#125;&#125;</code></pre><p>在<code>DefaultBeanDefinitionDocumentReader</code>中处理<code>Bean标签</code>的逻辑交给了<code>BeanDefinitionParserDelegate</code>对象来进行操作，并通过<code>XmlReaderContext</code>获取到<code>Registry</code>，最后将解析好的BeanDefinition注册进容器。</p><p>伴随着Xml方法的繁琐，笨重，Spring在4.2版本后提供了注解配置的方式来替换Xml配置的方法，那么注解是怎样读取 BeanDefinition的呢？</p><h3 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a><code>AnnotatedBeanDefinitionReader</code></h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>AnnotatedBeanDefinitionReader是个方便的适配器，用于以编程方式注册Bean类。这是<code>ClassPathBeanDefinitionScanner</code>的替代方法，它应用注解的相同解析，但仅适用于显式注册的类。</p><p><strong>该类不仅仅读取BeanDefinition，同时会注册BeanDefinition。</strong></p><h4 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotatedBeanDefinitionReader</span> </span>&#123;<span class="hljs-comment">// BeanDefinition注册器</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinitionRegistry registry;<span class="hljs-comment">// Bean名称生成器</span>  <span class="hljs-keyword">private</span> BeanNameGenerator beanNameGenerator = AnnotationBeanNameGenerator.INSTANCE;  <span class="hljs-keyword">private</span> ScopeMetadataResolver scopeMetadataResolver = <span class="hljs-keyword">new</span> AnnotationScopeMetadataResolver();  <span class="hljs-comment">// </span>  <span class="hljs-keyword">private</span> ConditionEvaluator conditionEvaluator;  <span class="hljs-comment">// 构造函数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;    <span class="hljs-keyword">this</span>(registry, getOrCreateEnvironment(registry));  &#125;  <span class="hljs-comment">// 使用指定的Class数组注册Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;    <span class="hljs-keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;      registerBean(componentClass);    &#125;  &#125;<span class="hljs-comment">// 使用执行的Class注册Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;    doRegisterBean(beanClass, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);  &#125; <span class="hljs-comment">// 使用指定的Class和名称注册Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, @Nullable String name)</span> </span>&#123;    doRegisterBean(beanClass, name, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);  &#125;  <span class="hljs-comment">// 使用指定的Class和Annotation Class数组注册Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>&#123;    doRegisterBean(beanClass, <span class="hljs-keyword">null</span>, qualifiers, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);  &#125;    <span class="hljs-comment">// 忽略部分重载的registerBean方法</span>  <span class="hljs-comment">// 真正执行注册BeanDefinition的地方</span>  <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String name,</span></span><span class="hljs-function"><span class="hljs-params">                                  Class&lt;? extends Annotation&gt;[] qualifiers, Supplier&lt;T&gt; supplier,</span></span><span class="hljs-function"><span class="hljs-params">                                  BeanDefinitionCustomizer[] customizers)</span> </span>&#123;<span class="hljs-comment">// 创建BeanDefinition</span>    AnnotatedGenericBeanDefinition abd = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;      <span class="hljs-keyword">return</span>;    &#125;    abd.setInstanceSupplier(supplier);    <span class="hljs-comment">// 解析BeanDefinition的作用域</span>    ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);    abd.setScope(scopeMetadata.getScopeName());    <span class="hljs-comment">// 生成Bean名称</span>    String beanName = (name != <span class="hljs-keyword">null</span> ? name : <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="hljs-keyword">this</span>.registry));    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);    <span class="hljs-comment">// 处理Bean上声明的注解信息</span>    <span class="hljs-keyword">if</span> (qualifiers != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;        <span class="hljs-keyword">if</span> (Primary<span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== qualifier) &#123;          abd.setPrimary(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 唯一</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Lazy<span class="hljs-class">.<span class="hljs-keyword">class</span> </span>== qualifier) &#123;          abd.setLazyInit(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 懒加载</span>        &#125;        <span class="hljs-keyword">else</span> &#123;          abd.addQualifier(<span class="hljs-keyword">new</span> AutowireCandidateQualifier(qualifier));        &#125;      &#125;    &#125;    <span class="hljs-comment">// 定制BeanDefinition，与BeanDefinitionBuilder.applyCustomizers 用法一致</span>    <span class="hljs-keyword">if</span> (customizers != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;        customizer.customize(abd);      &#125;    &#125;<span class="hljs-comment">// 生成BeanDefinitionHolder</span>    BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(abd, beanName);    <span class="hljs-comment">// 创建作用域代理</span>    definitionHolder =       AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);    <span class="hljs-comment">// 向容器中注册Bean</span>    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);  &#125;&#125;</code></pre><p>可以看出AnnotatedBeanDefinitionReader注册Bean的方法明显比XmlBeanDefinitionReader的处理方式简单了很多，</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAnnotatedBeanDefinitionReader</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 创建ApplicationContext</span>  AnnotationConfigApplicationContext applicationContext =     <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">// 获取Bean</span>  IocBean iocBean = applicationContext.getBean(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  System.out.println(iocBean);&#125;</code></pre><p><code>AnnotationConfigApplicationContext</code>类中声明了<code>AnnotatedBeanDefinitionReader</code>，<code>ClassPathBeanDefinitionScanner</code>对象，并在构造函数中做了初始化。</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180020.png" srcset="/img/loading.gif" alt="image-20200517154640954" style="zoom:50%;" /><p><code>ClassPathBeanDefinitionScanner</code>用于扫描<code>ClassPath</code>下带<code>@Component，@Repository，@Service，@Controller</code>注解的类。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此BeanDefinitionReader的分析完成，我们一共分析了两个BeanDefinitionReader规范实现，分别对应<code>Xml读取（XmlBeanDefinitionReader）</code>和<code>注解读取（AnnotatedBeanDefinitionReader）</code>。</p><p><code>XmlBeanDefinitionReader</code>：内部将BeanDefinition的读取交给了BeanDefinitionDocumentReader来进行操作。</p><p><code>AnnotatedBeanDefinitionReader</code>：不仅能读取BeanDefinition，并且还能注册BeanDefinition。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-Bean定义</title>
    <link href="/2020/10/09/spring-bean-definition/index/"/>
    <url>/2020/10/09/spring-bean-definition/index/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-BeanDefinition"><a href="#Ioc-BeanDefinition" class="headerlink" title="Ioc-BeanDefinition"></a>Ioc-BeanDefinition</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><p>本文主要讲述BeanDefinition的作用，以及BeanDefinition子接口或实现类的使用和介绍。</p><p>不会涉及BeanDefinitionReader（读取生成BeanDefinition）和BeanDefinitionRegistry（注册BeanDefinition）相关的东西，只关注BeanDefinition本身的东西。</p></blockquote><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>BeanDefinition描述了一个bean实例，该实例具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p><p>BeanDefinition主要是用来描述Bean，里面存放Bean元数据：比如<code>Bean类名、scope、属性、构造函数参数列表、依赖的Bean、是否是单例类、是否是懒加载</code>等一些列信息。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180454.png" srcset="/img/loading.gif" alt="image-20200513192525817" style="zoom:50%;" /><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeAccessor</span>, <span class="hljs-title">BeanMetadataElement</span> </span>&#123;<span class="hljs-comment">// 设置Bean实例在Ioc中的名称</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBeanClassName</span><span class="hljs-params">(@Nullable String beanClassName)</span></span>;  <span class="hljs-function">String <span class="hljs-title">getBeanClassName</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置是否单例</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setScope</span><span class="hljs-params">(@Nullable String scope)</span></span>;  <span class="hljs-function">String <span class="hljs-title">getScope</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置是否懒加载</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLazyInit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> lazyInit)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isLazyInit</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置当前Bean依赖的Bean</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDependsOn</span><span class="hljs-params">(@Nullable String... dependsOn)</span></span>;  String[] getDependsOn();  <span class="hljs-comment">// 当前Bean是否是唯一</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPrimary</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> primary)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimary</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回此bean的构造函数参数值。</span>  <span class="hljs-comment">// ConstructorArgumentValues包装了当前Bean的构造函数参数值</span>  <span class="hljs-function">ConstructorArgumentValues <span class="hljs-title">getConstructorArgumentValues</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回要应用到Bean的新实例的属性值。</span>  <span class="hljs-comment">// MutablePropertyValues包装了当前Bean的属性值</span>  <span class="hljs-function">MutablePropertyValues <span class="hljs-title">getPropertyValues</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置自定义初始化方法</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInitMethodName</span><span class="hljs-params">(@Nullable String initMethodName)</span></span>;  <span class="hljs-function">String <span class="hljs-title">getInitMethodName</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置自定义销毁方法</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDestroyMethodName</span><span class="hljs-params">(@Nullable String destroyMethodName)</span></span>;  <span class="hljs-function">String <span class="hljs-title">getDestroyMethodName</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 是否单例</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 是否多例</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 是否抽象</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAbstract</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回原始的BeanDefinition；如果没有，则返回null。 允许获取修饰的bean定义（如果有）。</span>  <span class="hljs-comment">// 请注意，此方法返回直接发起者。 遍历发起者链以找到用户定义的原始BeanDefinition。</span>  <span class="hljs-function">BeanDefinition <span class="hljs-title">getOriginatingBeanDefinition</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>代码中BeanDefinition继承了<code>AttributeAccessor</code>, <code>BeanMetadataElement</code>两接口，让我们来看一下这两个接口。</p><h3 id="BeanMetadataElement"><a href="#BeanMetadataElement" class="headerlink" title="BeanMetadataElement"></a><code>BeanMetadataElement</code></h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanMetadataElement</span> </span>&#123;  <span class="hljs-comment">// 返回此元数据元素的配置源Object（可以为null）。</span>  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">getSource</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;&#125;</code></pre><h3 id="AttributeAccessor"><a href="#AttributeAccessor" class="headerlink" title="AttributeAccessor"></a><code>AttributeAccessor</code></h3><pre><code class="hljs java"><span class="hljs-comment">// 定义用于将元数据附加到任意对象或从任意对象访问元数据的通用协定的接口。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeAccessor</span> </span>&#123;  <span class="hljs-comment">// 将名称定义的属性设置为提供的值。 如果value为null，则删除该属性。</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, @Nullable Object value)</span></span>;<span class="hljs-comment">// 获取由名称标识的属性的值。 如果属性不存在，则返回null。</span>  <span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(String name)</span></span>;  <span class="hljs-comment">// 删除由名称标识的属性的值。 如果属性不存在，则返回null。</span>  <span class="hljs-function">Object <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String name)</span></span>;  <span class="hljs-comment">// 存在由名称标识的属性的值返回true，否则返回false</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttribute</span><span class="hljs-params">(String name)</span></span>;<span class="hljs-comment">// 返回所有属性的名称。</span>  String[] attributeNames();&#125;</code></pre><h3 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a><code>AbstractBeanDefinition</code></h3><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>AbstractBeanDefinition是BeanDefinition最完整的实现，内部提供了大量的的属性字段来封装Bean的元数据信息。</p><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanMetadataAttributeAccessor</span></span><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinition</span>, <span class="hljs-title">Cloneable</span> </span>&#123;<span class="hljs-comment">// 忽略部分常量</span><span class="hljs-comment">// 属性字段</span>  <span class="hljs-comment">// BeanDefinition对应的Class</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Object beanClass;  <span class="hljs-keyword">private</span> String scope = SCOPE_DEFAULT;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> abstractFlag = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">private</span> Boolean lazyInit; <span class="hljs-comment">// 是否懒加载</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> autowireMode = AUTOWIRE_NO;   <span class="hljs-comment">// 自动注入模式</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> dependencyCheck = DEPENDENCY_CHECK_NONE;  <span class="hljs-comment">// 依赖检查</span>  <span class="hljs-keyword">private</span> String[] dependsOn;<span class="hljs-comment">// 依赖</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> autowireCandidate = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> primary = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();  <span class="hljs-keyword">private</span> Supplier&lt;?&gt; instanceSupplier;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> nonPublicAccessAllowed = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> lenientConstructorResolution = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> String factoryBeanName;  <span class="hljs-keyword">private</span> String factoryMethodName;  <span class="hljs-keyword">private</span> ConstructorArgumentValues constructorArgumentValues;  <span class="hljs-comment">// 构造函数参数</span>  <span class="hljs-keyword">private</span> MutablePropertyValues propertyValues;<span class="hljs-comment">// 属性参数</span>  <span class="hljs-keyword">private</span> MethodOverrides methodOverrides = <span class="hljs-keyword">new</span> MethodOverrides();  <span class="hljs-keyword">private</span> String initMethodName;  <span class="hljs-keyword">private</span> String destroyMethodName;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enforceInitMethod = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enforceDestroyMethod = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> synthetic = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> role = BeanDefinition.ROLE_APPLICATION;  <span class="hljs-keyword">private</span> String description;  <span class="hljs-keyword">private</span> Resource resource;    <span class="hljs-comment">// 忽略属性get/set方法</span>    <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> cloneBeanDefinition();&#125;<span class="hljs-comment">// 克隆BeanDefinition</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractBeanDefinition <span class="hljs-title">cloneBeanDefinition</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h4 id="GenericBeanDefinition"><a href="#GenericBeanDefinition" class="headerlink" title="GenericBeanDefinition"></a><code>GenericBeanDefinition</code></h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>GenericBeanDefinition是一站式的用于标准bean定义。 像任何bean定义一样，它允许指定一个类以及可选的构造函数参数值和属性值。通过其<code>parentName</code>属性灵活的指定父BeanDefinition。</p><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanDefinition</span> </span>&#123;  <span class="hljs-meta">@Nullable</span>  <span class="hljs-keyword">private</span> String parentName;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericBeanDefinition</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericBeanDefinition</span><span class="hljs-params">(BeanDefinition original)</span> </span>&#123;    <span class="hljs-keyword">super</span>(original);  &#125;  <span class="hljs-comment">// 实现克隆BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">cloneBeanDefinition</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GenericBeanDefinition(<span class="hljs-keyword">this</span>);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(@Nullable Object other)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == other) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span> (!(other <span class="hljs-keyword">instanceof</span> GenericBeanDefinition)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    GenericBeanDefinition that = (GenericBeanDefinition) other;    <span class="hljs-keyword">return</span> (ObjectUtils.nullSafeEquals(<span class="hljs-keyword">this</span>.parentName, that.parentName) &amp;&amp; <span class="hljs-keyword">super</span>.equals(other));  &#125;&#125;</code></pre><p>可以看出GenericBeanDefinition继承了AbstractBeanDefinition类，新增了一个<code>parentName</code>属性。GenericBeanDefinition因为这个属性可以动态定义父依赖项，而不是将角色“硬编码”为根bean定义。</p><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGenericBeanDefinition</span><span class="hljs-params">()</span> </span>&#123;  AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();  GenericBeanDefinition parentBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();  parentBeanDefinition.setBeanClass(IocParentBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  parentBeanDefinition.setBeanClassName(IocParentBean<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;  parentBeanDefinition.setInitMethodName(<span class="hljs-string">"init"</span>);  applicationContext.registerBeanDefinition(<span class="hljs-string">"iocParentBean"</span>, parentBeanDefinition);  GenericBeanDefinition childBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();  childBeanDefinition.setBeanClass(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  childBeanDefinition.setParentName(parentBeanDefinition.getBeanClassName());  applicationContext.registerBeanDefinition(<span class="hljs-string">"iocBean"</span>, childBeanDefinition);  System.out.println(applicationContext.getBeanDefinition(<span class="hljs-string">"iocParentBean"</span>));  System.out.println(applicationContext.getBeanDefinition(<span class="hljs-string">"iocBean"</span>));&#125;</code></pre><h5 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h5><pre><code class="hljs txt">Generic bean: class [io.better.spring.ioc.IocParentBean]; scope&#x3D;; abstract&#x3D;false; lazyInit&#x3D;null; autowireMode&#x3D;0; dependencyCheck&#x3D;0; autowireCandidate&#x3D;true; primary&#x3D;false; factoryBeanName&#x3D;null; factoryMethodName&#x3D;null; initMethodName&#x3D;init; destroyMethodName&#x3D;null Generic bean with parent &#39;io.better.spring.ioc.IocParentBean&#39;: class [io.better.spring.ioc.IocBean]; scope&#x3D;; abstract&#x3D;false; lazyInit&#x3D;null; autowireMode&#x3D;0; dependencyCheck&#x3D;0; autowireCandidate&#x3D;true; primary&#x3D;false; factoryBeanName&#x3D;null; factoryMethodName&#x3D;null; initMethodName&#x3D;null; destroyMethodName&#x3D;null</code></pre><h4 id="RootBeanDefinition"><a href="#RootBeanDefinition" class="headerlink" title="RootBeanDefinition"></a><code>RootBeanDefinition</code></h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>一个RooBeanDefinition表示合并的BeanDefinition，该定义在运行时支持Spring BeanFactory中的特定bean。它可能是由多个相互继承的原始bean定义创建的，通常定义为GenericBeanDefinitions。<code>RootBeanDefinition</code>本质上是运行时的 “统一” BeanDefinition 视图。</p><p>但是，从Spring 2.5开始，以编程方式注册bean定义的首选方法是GenericBeanDefinition类。</p><h5 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanDefinition</span> </span>&#123;<span class="hljs-comment">// BeanDefinitionHolder存储有Bean的名称、别名、BeanDefinition</span>  <span class="hljs-keyword">private</span> BeanDefinitionHolder decoratedDefinition;  <span class="hljs-comment">// AnnotatedElement表示此VM中当前正在运行的程序的带注释元素。方便使用反射读取注释信息</span>  <span class="hljs-keyword">private</span> AnnotatedElement qualifiedElement;  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stale; <span class="hljs-comment">// 确定是否需要重新合并定义</span>  <span class="hljs-keyword">boolean</span> allowCaching = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">boolean</span> isFactoryMethodUnique = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">volatile</span> ResolvableType targetType;  <span class="hljs-keyword">volatile</span> Class&lt;?&gt; resolvedTargetType; <span class="hljs-comment">// 缓存给定BeanDefinition的对应的Class。</span>  <span class="hljs-keyword">volatile</span> Boolean isFactoryBean; <span class="hljs-comment">// 如果该bean是工厂bean，则进行缓存。</span>  <span class="hljs-keyword">volatile</span> ResolvableType factoryMethodReturnType;<span class="hljs-comment">// 缓存通用类型的工厂方法的返回类型。</span>  <span class="hljs-keyword">volatile</span> Method factoryMethodToIntrospect;  <span class="hljs-comment">// 缓存用于自省的唯一工厂方法候选。</span>    <span class="hljs-keyword">final</span> Object constructorArgumentLock = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">// 以下四个构造函数字段的通用锁。</span>  Executable resolvedConstructorOrFactoryMethod; <span class="hljs-comment">// 缓存已解析的构造函数或工厂方法</span>  <span class="hljs-keyword">boolean</span> constructorArgumentsResolved = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 将构造函数参数标记为已解析。</span>  Object[] resolvedConstructorArguments; <span class="hljs-comment">// 构造函数解析的参数数组</span>  Object[] preparedConstructorArguments;  <span class="hljs-comment">// 缓存部分准备好的构造函数参数。</span>  <span class="hljs-keyword">final</span> Object postProcessingLock = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">// 以下两个后处理字段的通用锁</span>  <span class="hljs-keyword">boolean</span> postProcessed = <span class="hljs-keyword">false</span>;  <span class="hljs-comment">// 指示是否应用MergedBeanDefinitionPostProcessor</span>  <span class="hljs-keyword">volatile</span> Boolean beforeInstantiationResolved;  <span class="hljs-comment">// 表示实例化之前的后处理器已启动</span>  <span class="hljs-keyword">private</span> Set&lt;Member&gt; externallyManagedConfigMembers;  <span class="hljs-keyword">private</span> Set&lt;String&gt; externallyManagedInitMethods;  <span class="hljs-keyword">private</span> Set&lt;String&gt; externallyManagedDestroyMethods;&#125;</code></pre><p>RootBeanDefiniiton保存了以下信息：</p><ol><li>持有的BeanDefinitionHolder定义了id、别名与Bean的对应关系。</li><li>AnnotatedElement获取Bean的注解信息。</li><li>具体的工厂方法（Class类型），包括工厂方法的返回类型，工厂方法的Method对象</li><li>缓存了构造函数、构造函数参数。</li></ol><h4 id="ChildBeanDefinition"><a href="#ChildBeanDefinition" class="headerlink" title="ChildBeanDefinition"></a><code>ChildBeanDefinition</code></h4><p>从其父级继承设置的Bean的BeanDefinition。ChildBeanDefinition对父beanDefinition有固定的依赖性。ChildBeanDefinition将从父对象继承构造函数参数值，属性值和方法替代，并可以选择添加新值。如果指定了init方法，destroy方法和/或静态工厂方法，则它们将覆盖相应的父设置。其余设置将始终从子定义中获取：取决于，自动装配模式，依赖项检查，单例，懒加载。</p><p>从Spring 2.5开始，以编程方式注册Bean定义的首选方法是GenericBeanDefinition类。</p><hr><h3 id="AnnotatedBeanDefinition"><a href="#AnnotatedBeanDefinition" class="headerlink" title="AnnotatedBeanDefinition"></a><code>AnnotatedBeanDefinition</code></h3><p>AnnotatedBeanDefinition扩展了BeanDefinition，可向外暴露Bean的<code>AnnotationMetadata</code>信息，无需加载Bean。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnnotatedBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanDefinition</span> </span>&#123;<span class="hljs-comment">// 返回Bean的注解元数据信息</span>  <span class="hljs-function">AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 获取此bean定义的factory方法的元数据（如果有）</span>  <span class="hljs-function">MethodMetadata <span class="hljs-title">getFactoryMethodMetadata</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h4 id="ScannedGenericBeanDefinition"><a href="#ScannedGenericBeanDefinition" class="headerlink" title="ScannedGenericBeanDefinition"></a><code>ScannedGenericBeanDefinition</code></h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>基于ASM ClassReader的GenericBeanDefinition类的扩展，支持通过AnnotatedBeanDefinition接口公开的注解元数据。此类不会尽早加载Bean类。而是从ASM ClassReader解析的“ .class”文件本身中检索所有相关的元数据。</p><p>它在功能上等效于AnnotatedGenericBeanDefinition.AnnotatedGenericBeanDefinition（AnnotationMetadata），但按类型区分已扫描的bean和已通过其他方式注册或检测的bean。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScannedGenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotatedBeanDefinition</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata metadata;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScannedGenericBeanDefinition</span><span class="hljs-params">(MetadataReader metadataReader)</span> </span>&#123;    Assert.notNull(metadataReader, <span class="hljs-string">"MetadataReader must not be null"</span>);    <span class="hljs-comment">// 获取到注解元数据信息</span>    <span class="hljs-keyword">this</span>.metadata = metadataReader.getAnnotationMetadata();    setBeanClassName(<span class="hljs-keyword">this</span>.metadata.getClassName());  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.metadata;  &#125;&#125;</code></pre><p><code>MetadataReader</code>：用于访问类元数据的简单入口，由<code>ASM org.springframework.asm.ClassReader</code>读取。</p><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><pre><code class="hljs java"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"iocBean1"</span>)<span class="hljs-meta">@Order</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBean</span> </span>&#123;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testScannedGenericBeanDefinition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  SimpleMetadataReaderFactory simpleMetadataReaderFactory = <span class="hljs-keyword">new</span> SimpleMetadataReaderFactory();  MetadataReader metadataReader =     simpleMetadataReaderFactory.getMetadataReader(<span class="hljs-string">"io.better.spring.ioc.IocBean"</span>);  ScannedGenericBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);  AnnotationMetadata metadata = beanDefinition.getMetadata();  Set&lt;String&gt; annotationTypes = metadata.getAnnotationTypes();  System.out.println(annotationTypes);&#125;</code></pre><h5 id="示例结果-1"><a href="#示例结果-1" class="headerlink" title="示例结果"></a>示例结果</h5><pre><code class="hljs txt">[org.springframework.stereotype.Component, org.springframework.core.annotation.Order]</code></pre><h4 id="AnnotatedGenericBeanDefinition"><a href="#AnnotatedGenericBeanDefinition" class="headerlink" title="AnnotatedGenericBeanDefinition"></a>AnnotatedGenericBeanDefinition</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>AnnotatedGenericBeanDefinition</p><p>这个GenericBeanDefinition变体主要用于测试希望在AnnotatedBeanDefinition上运行的代码，例如Spring组件扫描支持中的策略实现（默认定义类是org.springframework.context.annotation.ScannedGenericBeanDefinition，它也实现了AnnotatedBeanDefinition接口） 。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotatedGenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotatedBeanDefinition</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata metadata;  <span class="hljs-keyword">private</span> MethodMetadata factoryMethodMetadata;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotatedGenericBeanDefinition</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;    setBeanClass(beanClass);    <span class="hljs-keyword">this</span>.metadata = AnnotationMetadata.introspect(beanClass);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.metadata;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-meta">@Nullable</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> MethodMetadata <span class="hljs-title">getFactoryMethodMetadata</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.factoryMethodMetadata;  &#125;&#125;</code></pre><h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAnnotatedGenericBeanDefinition</span><span class="hljs-params">()</span> </span>&#123;  AnnotatedGenericBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(beanDefinition.getMetadata().getAnnotationTypes());&#125;</code></pre><h5 id="示例结果-2"><a href="#示例结果-2" class="headerlink" title="示例结果"></a>示例结果</h5><pre><code class="hljs txt">[org.springframework.stereotype.Component]</code></pre><h4 id="ConfigurationClassBeanDefinition"><a href="#ConfigurationClassBeanDefinition" class="headerlink" title="ConfigurationClassBeanDefinition"></a><code>ConfigurationClassBeanDefinition</code></h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><p>该类是<code>ConfigurationClassBeanDefinitionReader</code>中的私有静态内部类。</p><p>而<code>ConfigurationClassBeanDefinitionReader</code>作用是将<code>@Configuration</code>注解标识的类生成<code>ConfigurationClass</code>实例，在通过<code>ConfigurationClassBeanDefinition</code>将其转换成BeanDefinition并注册到<code>BeanDefinitionRegistry</code>中。</p><p>而<code>ConfigurationClassBeanDefinition</code>的作用就是将<code>@Configuration</code>标识的类生成BeanDefinition（XML等其他配置源无效）。</p><h5 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h5><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigurationClassBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RootBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotatedBeanDefinition</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata annotationMetadata;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodMetadata factoryMethodMetadata;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConfigurationClassBeanDefinition</span><span class="hljs-params">(ConfigurationClass configClass, MethodMetadata beanMethodMetadata)</span> </span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">this</span>.annotationMetadata = configClass.getMetadata();    <span class="hljs-keyword">this</span>.factoryMethodMetadata = beanMethodMetadata;    setLenientConstructorResolution(<span class="hljs-keyword">false</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.annotationMetadata;  &#125;&#125;</code></pre><p>在ConfigurationClassBeanDefinition构造函数中我们看到ConfigurationClass类，一个ConfigurationClass代表着一个用户定义的@Configuration类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>AbstractBeanDefinition</strong>：<ul><li>AbstractBeanDefinition是完善且具体的BeanDefinition类的基类，其中排除了GenericBeanDefinition，RootBeanDefinition和ChildBeanDefinition的常用属性。自动装配常数与AutowireCapableBeanFactory接口中定义的常数匹配。</li></ul></li><li><strong>GenericBeanDefinition</strong>：<ul><li>GenericBeanDefinition是一站式的用于标准bean定义。 像任何bean定义一样，它允许指定一个类以及可选的构造函数参数值和属性值。</li></ul></li><li><strong>AnnotatedBeanDefinition</strong>：<ul><li>表示注解类型的BeanDefinition，有两个重要的属性，AnnotationMetadata，MethodMetadata分别表示BeanDefinition的注解元信息和方法元信息。</li></ul></li><li><strong>RootBeanDefinition</strong>：<ul><li>代表一个<code>Xml，Java Config</code>来的BeanDefinition</li></ul></li><li><strong>ChildBeanDefinition</strong>:<ul><li>可以让子Bean定义拥有从父Bean定义哪里继承配置的能力</li></ul></li><li><strong>AnnotatedGenericBeanDefinition</strong>：<ul><li>表示<code>@Configuration</code>注解注释的Bean</li></ul></li><li><strong>ScannedGenericBeanDefinition</strong>：<ul><li>表示<code>@Component、@Service、@Controller、@Repository</code>等注解注释的Bean</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-核心接口</title>
    <link href="/2020/10/09/spring-core-interface/index/"/>
    <url>/2020/10/09/spring-core-interface/index/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-Spring核心接口"><a href="#Ioc-Spring核心接口" class="headerlink" title="Ioc-Spring核心接口"></a>Ioc-Spring核心接口</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><ol><li>本章主要讲述Spring Ioc中几个比较重要的接口<ol><li>BeanFactory的含义及其使用</li><li>BeanFactoryPostProcessor的作用以及使用</li><li>BeanPostProcessor的作用以及使用</li><li>BeanDefinitionReader的作用以及使用</li><li>FactoryBean的作用以及使用</li></ol></li></ol></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们一般配置Bean的方式有两种：1、使用Xml进行Bean的配置，2、使用@Component，@Bean等注解进行Bean的配置。</p><p>当然Spring为了处理这些不同的配置定义了一个接口（<code>BeanDefinitionReader</code>）来统一将这些配置加载并生成BeanDefinition。</p><p>当BeanDefinition被加载后，我们出于某些因素需要修改BeanDefinition，Spring向我们提供了<code>BeanFactoryPostProcessor</code>回调接口来修改BeanDefinition（在BeanDefinition被加载进BeanFactory时进行回调）。</p><p>接着实例化具体的Bean并放入到BeanFactory中，实例化后我们可能需要对实例进行一些包装，比如 AOP。Spring向我们提供了BeanPostProcessor回调接口来对Bean实例进行包装（在Bean实例被创建后进行回调）。</p><p>此时Ioc容器已经加载完毕了，但是上面的步骤都是在Bean实例化这个步骤前后进行操作，那我们怎么在操作实例化这个步骤呢？</p><p>Spring为提供了FactoryBean这个接口，让开发人员自己实现创建Bean实例的步骤。</p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>Gradle 坐标</p><pre><code class="hljs groovy">testCompile <span class="hljs-string">'junit:junit:4.13'</span>compile <span class="hljs-string">'org.aspectj:aspectjweaver:1.9.5'</span>compile <span class="hljs-string">'org.springframework:spring-beans:5.2.2.RELEASE'</span>compile <span class="hljs-string">'org.springframework:spring-aop:5.2.2.RELEASE'</span>compile <span class="hljs-string">'org.springframework:spring-context:5.2.2.RELEASE'</span></code></pre><p>Maven坐标</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><p>Spring 框架中</p><p><code>BeanDefinitionReader</code>：读取XML或注解配置的Bean并生成BeanDefinition</p><p><code>BeanFactoryPostProcesser</code>：BeanFactory加载BeanDefinition后增强的扩展接口，可以<code>新增/修改BeanDefinition</code>。</p><p><code>BeanPostProcesser</code>：BeanFactory实例化Bean后增强的扩展接口，可以包装Bean，例如AOP。</p><p><code>BeanFactory</code>：Spring Ioc的顶级接口，主要负责创建，实例化，管理Bean实例。</p><p><code>FactoryBean</code>：Spring提供给开发人员自定义实例化Bean的接口。</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>BeanFactory是访问Spring Bean容器的根接口。该接口由包含多个Bean定义的对象实现，每个定义均由String名称唯一标识。</p><p>它负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;  <span class="hljs-comment">// 用于区分FactoryBean实例，下面讲解FactoryBean接口时会讲到</span>  String FACTORY_BEAN_PREFIX = <span class="hljs-string">"&amp;"</span>;  <span class="hljs-comment">// 根据Bean名称查找并获取Bean</span>  <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 根据Bean名称和指定类型查找并获取Bean</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 返回名称查找并返回实例</span><span class="hljs-comment">// 允许在bean定义指定明确的构造器参数/工厂方法的参数，重写指定的默认参数（如果有的话）</span>  <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 根据类型返回指定实例</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 同上</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 返回一个提供者指定的Bean，允许懒按需检索的实例，包括可用性和唯一选择。</span>  &lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></span>;  <span class="hljs-comment">// 同上</span>  &lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span></span>;  <span class="hljs-comment">// 是否存在Bean</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;  <span class="hljs-comment">// 是否单例Bean</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>; <span class="hljs-comment">// 是否多例Bean</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;  <span class="hljs-comment">// 检查具有给定名称的Bean是否与指定的类型匹配。</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<span class="hljs-comment">// 同上</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;  <span class="hljs-comment">// 确定与给定名称的bean的类型。 更具体地讲，确定对象的该类型getBean将返回给定名称</span>  Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<span class="hljs-comment">// 同上</span>  Class&lt;?&gt; getType(String name, <span class="hljs-keyword">boolean</span> allowFactoryBeanInit) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;   <span class="hljs-comment">// 返回指定bean名字实例的所有别名，如果有的话.</span>  String[] getAliases(String name);&#125;</code></pre><p>我们常用的方法就是重载的<code>getBean()</code>。</p><h4 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h4><h5 id="初始生命周期"><a href="#初始生命周期" class="headerlink" title="初始生命周期"></a>初始生命周期</h5><ol><li><p><strong>BeanNameAware</strong>：将Bean在容器中的名称</p></li><li><p><strong>BeanClassLoaderAware</strong>：将加载Bean的类加载器提供给Bean的回调接口</p></li><li><p><strong>BeanFactoryAware</strong>：将管理当前Bean的BeanFactory返回给Bean的回调接口</p></li><li><p><strong>EnvironmentAware</strong>：返回当前Spring的环境变量的回调接口</p></li><li><p><strong>EmbeddedValueResolverAware</strong>：</p></li><li><p><strong>ResourceLoaderAware</strong>： 资源加载器的回调接口</p></li><li><p><strong>ApplicationEventPublisherAware</strong>：应用事件发送器获取的回调接口</p></li><li><p><strong>MessageSourceAware</strong>：MessageSource获取的回调接口</p></li><li><p><strong>ApplicationContextAware</strong>：Application Context获取的回调接口</p></li><li><p><strong>ServletContextAware</strong>：Servlet Context获取的</p></li><li><p><strong>BeanPostProcessor.postProcessBeforeInitialization</strong> ：在Bean初始化前执行</p></li><li><p><strong>InitializingBean</strong>：由BeanFactory设置完所有属性后执行</p></li><li><p><strong>自定义的初始化方法定义</strong>：<code>@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</code></p></li><li><p><strong>BeanPostProcessor.postProcessAfterInitialization</strong>：在Bean初始化后执行</p></li></ol><h5 id="销毁生命周期"><a href="#销毁生命周期" class="headerlink" title="销毁生命周期"></a>销毁生命周期</h5><ol><li><strong>DestructionAwareBeanPostProcessor.postProcessBeforeDestruction</strong></li><li><strong>DisposableBean.destroy</strong></li><li><strong>自定义的销毁方法</strong>：<code>@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</code></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>初始化流程：</p><ul><li>调用目标对象构造器创建对象</li><li>通过一系列Aware接口注入一些常用的属性</li><li>执行BeanPostProcessor.postProcessBeforeInitialization方法</li><li>执行InitializingBean.afterPropertiesSet方法</li><li>执行Bean自定义的初始化方法</li><li>执行BeanPostProcessor.postProcessAfterInitialization方法</li></ul><p>销毁流程：</p><ul><li>执行DestructionAwareBeanPostProcessors.postProcessBeforeDestruction方法</li><li>执行DisposableBean.destroy方法</li><li>执行Bean自定义的销毁方法</li></ul><h3 id="BeanFactoryPostBeanPostProcessor"><a href="#BeanFactoryPostBeanPostProcessor" class="headerlink" title="BeanFactoryPostBeanPostProcessor"></a>BeanFactoryPostBeanPostProcessor</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><code>BeanFactoryPostBeanPostProcessor</code>是一个回调接口，可以在BeanDefinition被加载到BeanFactory后如果想再次对BeanDefinition进行修改就可以实现此接口。Spring会在加载完BeanDefinition后回调此接口。</p><p>注意：再此接口实现中不能与Bean实例进行交互。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">  * 在标准初始化后修改ApplicationContext内的BeanFactory，所有的BeanDefinition都被加载，但没有被创建。</span><span class="hljs-comment">  * 可以覆盖或添加属性，甚至可以用于初始化bean</span><span class="hljs-comment">  */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException</span>;&#125;</code></pre><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>BeanFactoryPostProcessor主要用于当BeanDefinition被加载到BeanFactory中后，对BeanDefinition进行修改。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"io.better.spring.ioc"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocConfiguration</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IocBean <span class="hljs-title">iocBean</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IocBean();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBean</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IocBean</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"IocBean init"</span>);  &#125;<span class="hljs-comment">// 忽略get/set方法</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"IocBean custom init"</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"IocBean custom destroy"</span>);  &#125;&#125;</code></pre><p>在IocConfiguration配置中我们并没有指定IocBean的初始化和销毁方法，以及懒加载</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBeanFactoryProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        System.out.println(<span class="hljs-string">"BeanFactoryPostProcessor ....."</span>);        BeanDefinition iocBeanDefinition = beanFactory.getBeanDefinition(<span class="hljs-string">"iocBean"</span>);        iocBeanDefinition.setInitMethodName(<span class="hljs-string">"init"</span>);        iocBeanDefinition.setDestroyMethodName(<span class="hljs-string">"destroy"</span>);        iocBeanDefinition.setLazyInit(<span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre><p>在BeanFactoryPostProcessor实现中我们为IocBean指定了初始化和销毁的方法，以及懒加载。</p><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIocBeanFactoryPostProcessor</span><span class="hljs-params">()</span> </span>&#123;    AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    IocBean bean = (IocBean) applicationContext.getBean(<span class="hljs-string">"iocBean"</span>);    System.out.println(bean);    applicationContext.close();&#125;</code></pre><h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><pre><code class="hljs txt">BeanFactoryPostProcessor .....IocBean ConstructorIocBean custom initio.better.spring.ioc.IocBean@9225652IocBean custom destroy</code></pre><p>从测试结果可以看出，我们在BeanFactoryPostProcessor中成功的操作了已经被BeanFactory加载的BeanDefinition并对其进行了修改。</p><p><strong>到这里你可能会想既然能修改BeanDefinition，那能不能注册一个BeanDefinition呢？</strong></p><p>要想往BeanFactory中注册一个BeanDefinition需要实现接口<code>BeanDefinitionRegistryPostProcessor</code>。</p><p>该接口是BeanFactoryPostProcessor的子接口。</p><h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a><code>BeanDefinitionRegistryPostProcessor</code></h4><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;  <span class="hljs-comment">// </span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException</span>;&#125;</code></pre><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    System.out.println(<span class="hljs-string">"BeanDefinitionRegistryPostProcessor"</span>);        <span class="hljs-comment">// 创建IocRegistryTestBean的BeanDefinition</span>    BeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(IocRegistryTestBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>      .addPropertyValue("name", "registry post processor inject")      .getBeanDefinition();<span class="hljs-comment">// 注册进BeanFactory</span>    registry.registerBeanDefinition(<span class="hljs-string">"iocRegistryTestBean"</span>, beanDefinition);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    BeanDefinition iocRegistryTestBean = beanFactory.getBeanDefinition(<span class="hljs-string">"iocRegistryTestBean"</span>);    iocRegistryTestBean.setInitMethodName(<span class="hljs-string">"init"</span>);    iocRegistryTestBean.setDestroyMethodName(<span class="hljs-string">"destroy"</span>);    iocRegistryTestBean.setLazyInit(<span class="hljs-keyword">true</span>);  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"io.better.spring.ioc"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocConfiguration</span> </span>&#123;&#125;</code></pre><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIocBeanFactoryPostProcessor</span><span class="hljs-params">()</span> </span>&#123;  AnnotationConfigApplicationContext applicationContext =     <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  IocRegistryTestBean iocRegistryTestBean =     (IocRegistryTestBean) applicationContext.getBean(<span class="hljs-string">"iocRegistryTestBean"</span>);  System.out.println(iocRegistryTestBean);  applicationContext.close();&#125;</code></pre><h5 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h5><pre><code class="hljs txt">BeanDefinitionRegistryPostProcessorBeanFactoryPostProcessor .....IocRegistryTestBean custom initIocRegistryTestBean&#123;name&#x3D;&#39;registry post processor inject&#39;&#125;IocRegistryTestBean custom destroy</code></pre><p>从执行结果看出在<code>BeanDefinitionRegistryPostProcessor</code>想BeanFactory中注册了一个IocRegistryTestBean实例，并指定了其初始化和销毁的方法以及懒加载。</p><p><code>BeanDefinitionRegistryPostProcessor</code>比<code>BeanFactoryPostProcessor</code>先执行。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>ConfigurationClassPostProcessor作用</p><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>BeanDefinitionReader是一个接口，主要是读取XML或注解标识的类并将其转成BeanDefinition，提供了使用<code>Resource</code>和<code>String location</code>参数指定加载方法。</p><p>此接口是个规范接口，具体的BeanDefinitionReader无需实现此接口。BeanDefinition读取的简单接口。</p><h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">    * 返回通过BeanDefinitionRegistry接口暴露的BeanFactory去注册BeanDefinition</span><span class="hljs-comment">    */</span>  <span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;  <span class="hljs-meta">@Nullable</span>  <span class="hljs-function">ResourceLoader <span class="hljs-title">getResourceLoader</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回用于Bean类的类加载器。</span>  <span class="hljs-comment">// null建议不要急于加载Bean类，而只是用类名注册Bean定义，并在以后解析（或永不解析）相应的类。</span>  <span class="hljs-meta">@Nullable</span>  <span class="hljs-function">ClassLoader <span class="hljs-title">getBeanClassLoader</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回BeanNameGenerator用于匿名Bean（未指定显式Bean名称）</span>  <span class="hljs-function">BeanNameGenerator <span class="hljs-title">getBeanNameGenerator</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 从指定的Resource中加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 从指定的Resource数组中加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 同上</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 同上</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;&#125;</code></pre><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><p>我们以<code>XmlBeanDefinitionReader</code>为例</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"iocBean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"io.better.spring.ioc.IocBean"</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">"init"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"destroy"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"test-xml"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericXmlApplicationContext</span><span class="hljs-params">(String... resourceLocations)</span> </span>&#123;   load(resourceLocations);   refresh();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load</span><span class="hljs-params">(String... resourceLocations)</span> </span>&#123;   <span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(resourceLocations);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> XmlBeanDefinitionReader reader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(<span class="hljs-keyword">this</span>);</code></pre><p>可以看出<code>GenericXmlApplicationContext</code>中持有了<code>XmlBeanDefinitionReader</code>的引用，并在初始化时调用了XmlBeanDefinitionReader的loadBeanDefinitions方法加载了BeanDefinition。</p><h4 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIocBeanDefinitionReader</span><span class="hljs-params">()</span> </span>&#123;    GenericXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> GenericXmlApplicationContext(<span class="hljs-string">"Ioc.xml"</span>);    System.out.println(applicationContext.getBean(<span class="hljs-string">"iocBean"</span>));&#125;</code></pre><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>BeanPostProcessor为一个接口，用于在BeanFactory实例化Bean后对Bean进行扩展需要实现的接口，Spring会在初始化每个Bean后会回调这个接口。</p><p>如果有多个<code>BeanPostProcessor</code>实例，我们可以通过设置<code>order</code>属性或实现<code>Ordered</code>接口来控制执行顺序。</p><p>BeanPostProcessor接口由两个回调方法组成，即<code>postprocessbeforeinitialize()</code>和<code>postprocessafterinitialize()</code>。</p><p>我们可以对实例化的Bean进行包装或修改，例如<code>Aop</code>（使用的是<code>AbstractAdvisingBeanPostProcessor</code>类）就是一个很好的例子。</p><h4 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;  <span class="hljs-comment">// 在InitializingBean.afterPropertiesSet或自定义初始化方法之前应用这个BeanPostProcessor</span>  <span class="hljs-comment">// 此时该Bean已经填充了属性值。</span>  <span class="hljs-comment">// 这个方法可以对原始实例进行包装，默认实现按原样返回给定的bean。</span>  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">return</span> bean;  &#125;  <span class="hljs-comment">// 在InitializingBean.afterPropertiesSet或自定义初始化方法之后应用这个BeanPostProcessor</span>  <span class="hljs-comment">// 此时该Bean已经填充了属性值。</span>  <span class="hljs-comment">// 对于FactoryBean，将为FactoryBean实例和由FactoryBean创建的对象（从Spring 2.0开始）调用此回调。 </span>  <span class="hljs-comment">// post-processor可以通过FactoryBean检查的相应bean实例来决定是应用到FactoryBean还是创建的对象，还是两者都应用。</span>  <span class="hljs-comment">// 与所有其他BeanPostProcessor回调相反，此回调还将在</span>  <span class="hljs-comment">// InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation方法触发短路后被调用。</span>  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">return</span> bean;  &#125;&#125;</code></pre><p>我们利用BeanPostProcessor来实现一个简单的Aop代理功能，示例代码如下：</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> IocBean) &#123;      IocBean iocBean = (IocBean) bean;      <span class="hljs-comment">// 设置Name属性</span>      iocBean.setName(<span class="hljs-string">"test-BeanPostProcessor"</span>);      System.out.println(<span class="hljs-string">"IocBeanPostProcessor Before "</span> + beanName);    &#125;    <span class="hljs-keyword">return</span> bean;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> IocBean) &#123;      System.out.println(<span class="hljs-string">"IocBeanPostProcessor After "</span> + beanName);            <span class="hljs-comment">// 为IocBean创建代理对象</span>      IocBean iocBean = (IocBean) bean;      Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();      enhancer.setSuperclass(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      enhancer.setCallback(<span class="hljs-keyword">new</span> CglibProxy(iocBean));      <span class="hljs-keyword">return</span> enhancer.create();    &#125;    <span class="hljs-keyword">return</span> bean;  &#125;&#125;<span class="hljs-comment">// Cglib执行程序</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;  <span class="hljs-keyword">private</span> Object proxyTarget;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CglibProxy</span><span class="hljs-params">(Object proxyTarget)</span> </span>&#123;    <span class="hljs-keyword">this</span>.proxyTarget = proxyTarget;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    System.out.println(<span class="hljs-string">"BeanPostProcessor Cglib 代理执行前"</span>);    Object invoke = method.invoke(proxyTarget, objects);    System.out.println(<span class="hljs-string">"BeanPostProcessor Cglib 代理执行后"</span>);    <span class="hljs-keyword">return</span> invoke;  &#125;&#125;</code></pre><p>代码中在Before中为IocBean的Name属性进行了赋值，在After中为IocBean创建了代理对象。</p><h4 id="测试代码-3"><a href="#测试代码-3" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIocBeanPostProcessor</span><span class="hljs-params">()</span> </span>&#123;    AnnotationConfigApplicationContext applicationContext =       <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    IocBean bean = applicationContext.getBean(IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    bean.say();&#125;</code></pre><p>当我们从Application Context获取的Bean实例是在BeanPostProcessor中创建的代理对象。</p><h4 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h4><pre><code class="hljs txt">IocBean Constructor   &#x2F;&#x2F; 初始化beanIocBeanPostProcessor Before iocBean  &#x2F;&#x2F; 设置name属性IocBeanPostProcessor After iocBean &#x2F;&#x2F; 创建Cglib代理IocBean Constructor &#x2F;&#x2F; cglib代理类调用&#x2F;&#x2F; 执行Say方法BeanPostProcessor Cglib 代理执行前IocBean  Say :test-BeanPostProcessorBeanPostProcessor Cglib 代理执行后</code></pre><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>FactoryBean是一个接口，如果Bean实现此接口，则它将用作对象公开的工厂，而不是直接用作将自身公开的bean实例。</p><p>FactoryBeans可以支持单例和原型，并且可以按需延迟创建对象，也可以在启动时急于创建对象。 </p><p>注意：实现此接口的Bean不能用作普通Bean。 FactoryBean以Bean样式定义（名称，别名和普通Bean一致），但是为Bean引用公开的对象始终是由<code>Factory.getObject()</code>方法创建的对象。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>在Spring中我们注册实例化Bean的方式一般都是使用<code>@Component，@Bean</code>等注解将Bean注册到容器中，整个过程对于开发人员来说是不可见的（除非阅读源码）。Spring为了更好的扩展提供了<code>FactoryBean</code>这个接口让开发人员可以自定义Bean的实例化和注册过程。</p><p>实现了<code>FactoryBean&lt;T&gt;</code>接口的Bean，Spring会向容器中注册两个Bean，一个是FactoryBean实例本身，一个是<code>FactoryBean.getObject()</code>方法返回值所代表的Bean。</p><p>根据该Bean的ID从BeanFactory中获取的实际上是<code>FactoryBean.getObject()</code>返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个<code>&amp;</code>符号来获取（和BeanFactory中的静态变量<code>FACTORY_BEAN_PREFIX</code>对应）。</p><h4 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  String OBJECT_TYPE_ATTRIBUTE = <span class="hljs-string">"factoryBeanObjectType"</span>;  <span class="hljs-comment">// 调用获取对象，可以是任意类型的对象</span>  <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;  <span class="hljs-comment">// 获取对象类型</span>  Class&lt;?&gt; getObjectType();  <span class="hljs-comment">// 是否是单例</span>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;&#125;</code></pre><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IocBean</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"IocBean init"</span>);    System.out.println(<span class="hljs-keyword">this</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"IocBean custom init"</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"IocBean custom destroy"</span>);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    System.out.println(<span class="hljs-string">"FactoryBean Create IocBean Instance"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IocBean();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;    <span class="hljs-keyword">return</span> IocBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;  &#125;&#125;</code></pre><h5 id="测试代码-4"><a href="#测试代码-4" class="headerlink" title="测试代码"></a>测试代码</h5><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIoc</span><span class="hljs-params">()</span> </span>&#123;  AnnotationConfigApplicationContext applicationContext =     <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  IocBean bean = (IocBean) applicationContext.getBean(<span class="hljs-string">"iocBean"</span>);  IocBean factoryBean = (IocBean) applicationContext.getBean(<span class="hljs-string">"&amp;iocBean"</span>);  System.out.println(bean);  System.out.println(factoryBean);  applicationContext.close();&#125;</code></pre><h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><pre><code class="hljs txt">&#x2F;&#x2F; 第一次初始化IocBean initio.better.spring.ioc.IocBean@159f197&#x2F;&#x2F; BeanFactory.getObject()执行FactoryBean Create IocBean Instance&#x2F;&#x2F; 第二次初始化IocBean initio.better.spring.ioc.IocBean@6fe7aac8&#x2F;&#x2F; sout输出内容io.better.spring.ioc.IocBean@6fe7aac8io.better.spring.ioc.IocBean@159f197</code></pre><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>从执行结果可以看出IocBean的实例对象是由<code>FactoryBean.getObject()</code>方法创建的。</p><p>通过打印从<code>容器获取FactoryBean实例</code>和<code>构造器中打印语句</code>得出：IocBean类被实例化了两次</p><ul><li>第一次实例化的是FactoryBean实例</li><li>第二次实例化的是IocBean实例（是通过FactoryBean.getObject方法创建的）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-简介</title>
    <link href="/2020/10/09/spring-introduction/index/"/>
    <url>/2020/10/09/spring-introduction/index/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc容器"><a href="#Ioc容器" class="headerlink" title="Ioc容器"></a>Ioc容器</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><p>本文主要讲述Ioc容器和DI相关的概念以及区别</p><p>Ioc是什么?</p><p>DI是什么？</p><p>Ioc为什么叫控制反转？控制了什么？反转了什么？</p><p>Di为什么叫依赖注入？依赖了什么？注入了什么？</p></blockquote><h2 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IoC</strong>），是<a href="https://zh.wikipedia.org/wiki/面向对象编程" target="_blank" rel="noopener">面向对象编程</a>中的一种<strong>设计原则</strong>，可以用来减低计算机代码之间的<a href="https://zh.wikipedia.org/wiki/耦合度_(計算機科學)" target="_blank" rel="noopener">耦合度</a>。其中最常见的方式叫做<strong>依赖注入</strong>（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。</p><p><strong>IOC不是什么技术，而是一种设计思想</strong>。</p><p>既然IOC是控制反转，那<strong>控制了什么</strong>？<strong>反转了什么</strong>？ </p><p><strong>控制</strong>：传统Java开发中，我们都是主动在类中创建依赖的对象，是程序主动去创建依赖对象；而在IoC中有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建。<strong>即创建和查找依赖对象的控制权交给了IoC容器</strong>。</p><p><strong>反转</strong>：类获取依赖对象的方式不在是主动<code>new</code>，而是想IoC容器获取，即<strong>获得依赖对象的过程被反转</strong>。</p><p>实现方法</p><p>实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><code>DI—Dependency Injection</code>，即<strong>依赖注入</strong>：<strong>组件之间依赖关系</strong>由容器在运行期决定，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>参考 <a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Martin Fowler文章</a></p><p>理解DI的关键是：<strong>谁依赖谁，为什么需要依赖，谁注入谁，注入了什么</strong>。</p><ul><li><p>谁依赖谁：当然是<strong>应用程序依赖于IoC容器</strong>；</p></li><li><p>为什么需要依赖：<strong>应用程序需要IoC容器来提供对象需要的外部资源</strong>；</p></li><li><p>谁注入谁：很明显是<strong>IoC容器注入应用程序某个对象</strong>，应用程序依赖的对象；</p></li><li><p>注入了什么：就是注入<strong>某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>；</p></li></ul><p>IoC和DI之间有什么关系呢？Ioc着重强调的是对象创建和获取的控制，而DI着重强调的是</p><p>依赖注入实现方式：</p><ul><li>基于接口。实现特定接口以供外部容器注入所依赖类型的对象。</li><li>基于<code>set</code>方法。实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。</li><li>基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。</li><li>基于注解。基于<a href="https://zh.wikipedia.org/wiki/Java注解" target="_blank" rel="noopener">Java的注解功能</a>，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而并不希望其他依赖此类的对象访问）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins Pipeline</title>
    <link href="/2020/10/09/jenkins/index/"/>
    <url>/2020/10/09/jenkins/index/</url>
    
    <content type="html"><![CDATA[<p>该文章主要Jenkins Pipeline的使用</p><a id="more"></a><h2 id="Jenkins-Pipeline"><a href="#Jenkins-Pipeline" class="headerlink" title="Jenkins-Pipeline"></a>Jenkins-Pipeline</h2><h3 id="Pipeline-Block"><a href="#Pipeline-Block" class="headerlink" title="Pipeline Block"></a>Pipeline Block</h3><blockquote><p>所有有效的声明式流水线必须包含在一个 <code>pipeline</code>块中</p><pre><code class="hljs groovy">pipeline &#123;  &#125;</code></pre><p>遵循Groovy语法。</p><p>特点：</p><ol><li>流水线顶层必须是一个 <code>pipeline{}</code>。</li><li>没有分号作为语句分隔符，每条语句都必须在自己的行上。</li><li>块只能由<code>节段，指令，步骤或赋值语句</code>组成。 *属性引用语句被视为无参方法调用。例如：input被视为input()。</li></ol></blockquote><h3 id="Agent-Block"><a href="#Agent-Block" class="headerlink" title="Agent Block"></a>Agent Block</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p><code>agent</code> 部分指定了整个流水线或特定的部分, 将会在Jenkins环境中执行的位置，这取决于 <code>agent</code> 区域的位置。</p><p>该部分必须在 <code>pipeline</code> 块的顶层被定义, 但是 stage 级别的使用是可选的。</p></blockquote><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><blockquote><p><code>any</code>：在任何可用的代理上执行流水线或阶段。例如: <code>agent any</code></p><p><code>label</code>：在提供了标签的 Jenkins 环境中可用的代理上执行流水线或阶段。 例如: <code>agent { label &#39;node-1&#39; }</code></p><p><code>node</code>： <code>agent { node { label &#39;labelName&#39; } }</code> 和 <code>agent { label &#39;labelName&#39; }</code> 一样, 但是 <code>node</code> 允许额外的选项 (比如 <code>customWorkspace</code> )。</p></blockquote><h3 id="Post-Block"><a href="#Post-Block" class="headerlink" title="Post Block"></a>Post Block</h3><blockquote><p><code>post</code> 部分定义一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">steps</a> ，这些阶段根据流水线或阶段的完成情况而运行(取决于流水线中 <code>post</code> 部分的位置)。</p><p><code>post</code>支持<code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code>, <code>unstable</code>, 和 <code>aborted</code>块中任意一个。</p><p>这些条件块允许在 <code>post</code> 部分的步骤的执行取决于流水线或阶段的完成状态。</p></blockquote><h4 id="块对应的条件"><a href="#块对应的条件" class="headerlink" title="块对应的条件"></a>块对应的条件</h4><blockquote><p><code>always</code>:无论流水线或阶段的完成状态如何，都允许在 <code>post</code> 部分运行该步骤。</p><p><code>changed</code>:当前流水线或阶段的完成状态与它之前的运行不同时，才能执行。</p><p><code>failure</code>:当前流水线或阶段的完成状态为”failure”，才能执行,。</p><p><code>success</code>:当前流水线或阶段的完成状态为”success”，才能执行。</p><p><code>unstable</code>:当前流水线或阶段的完成状态为”unstable”，才能执行, 通常由于测试失败,代码违规等造成。通常web UI是黄色。</p><p><code>aborted</code>:当前流水线或阶段的完成状态为”aborted”，才能执行, 通常由于流水线被手动的aborted。通常web UI是灰色。</p></blockquote><h3 id="Stages-块"><a href="#Stages-块" class="headerlink" title="Stages 块"></a>Stages 块</h3><blockquote><p>包含一系列一个或多个 <a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#stage" target="_blank" rel="noopener">stage</a> 指令, <code>stages</code> 部分是流水线描述的大部分”工作” 的位置。</p></blockquote><pre><code class="hljs groovy">pipeline &#123;    agent any    stages &#123;         stage(<span class="hljs-string">'Example'</span>) &#123;            steps &#123;                echo <span class="hljs-string">'Hello World'</span>            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="Steps块"><a href="#Steps块" class="headerlink" title="Steps块"></a>Steps块</h3><blockquote><p><code>steps</code> 部分在给定的 <code>stage</code> 指令中执行的定义了一系列的一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">steps</a></p></blockquote><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><blockquote><p><code>environment</code> 指令制定一个 键-值对序列，该序列将被定义为所有步骤的环境变量，或者是特定于阶段的步骤， 这取决于 <code>environment</code> 指令在流水线内的位置。</p><p>该指令支持一个特殊的助手方法 <code>credentials()</code> ，该方法可用于在Jenkins环境中通过标识符访问预定义的凭证。</p></blockquote><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><blockquote><p><code>options</code> 指令允许从流水线内部配置特定于流水线的选项。</p></blockquote><h5 id="可用选项"><a href="#可用选项" class="headerlink" title="可用选项"></a>可用选项</h5><ul><li><p>buildDiscarder</p><p>为最近的流水线运行的特定数量保存组件和控制台输出。例如: <code>options { buildDiscarder(logRotator(numToKeepStr: &#39;1&#39;)) }</code></p></li><li><p>disableConcurrentBuilds</p><p>不允许同时执行流水线。 可被用来防止同时访问共享资源等。 例如: <code>options { disableConcurrentBuilds() }</code></p></li><li><p>overrideIndexTriggers</p><p>允许覆盖分支索引触发器的默认处理。 如果分支索引触发器在多分支或组织标签中禁用, <code>options { overrideIndexTriggers(true) }</code> 将只允许它们用于促工作。否则, <code>options { overrideIndexTriggers(false) }</code> 只会禁用改作业的分支索引触发器。</p></li><li><p>skipDefaultCheckout</p><p>在<code>agent</code> 指令中，跳过从源代码控制中检出代码的默认情况。例如: <code>options { skipDefaultCheckout() }</code></p></li><li><p>skipStagesAfterUnstable</p><p>一旦构建状态变得UNSTABLE，跳过该阶段。例如: <code>options { skipStagesAfterUnstable() }</code></p></li><li><p>checkoutToSubdirectory</p><p>在工作空间的子目录中自动地执行源代码控制检出。例如: <code>options { checkoutToSubdirectory(&#39;foo&#39;) }</code></p></li><li><p>timeout</p><p>设置流水线运行的超时时间, 在此之后，Jenkins将中止流水线。例如: <code>options { timeout(time: 1, unit: &#39;HOURS&#39;) }</code></p></li><li><p>retry</p><p>在失败时, 重新尝试整个流水线的指定次数。 For example: <code>options { retry(3) }</code></p></li><li><p>timestamps</p><p>预谋所有由流水线生成的控制台输出，与该流水线发出的时间一致。 例如: <code>options { timestamps() }</code></p></li></ul><h5 id="可选的阶段选项"><a href="#可选的阶段选项" class="headerlink" title="可选的阶段选项"></a>可选的阶段选项</h5><ul><li><p>skipDefaultCheckout</p><p>在 <code>agent</code> 指令中跳过默认的从源代码控制中检出代码。例如: <code>options { skipDefaultCheckout() }</code></p></li><li><p>timeout</p><p>设置此阶段的超时时间, 在此之后， Jenkins 会终止该阶段。 例如: <code>options { timeout(time: 1, unit: &#39;HOURS&#39;) }</code></p></li><li><p>retry</p><p>在失败时, 重试此阶段指定次数。 例如: <code>options { retry(3) }</code></p></li><li><p>timestamps</p><p>预谋此阶段生成的所有控制台输出以及该行发出的时间一致。例如: <code>options { timestamps() }</code></p></li></ul><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><blockquote><p>定义自动安装和放置 <code>PATH</code> 的工具的一部分。</p></blockquote><pre><code class="hljs groovy">pipeline &#123;    agent any    tools &#123;        maven <span class="hljs-string">'apache-maven-3.0.1'</span>     &#125;    stages &#123;        stage(<span class="hljs-string">'Example'</span>) &#123;            steps &#123;                sh <span class="hljs-string">'mvn --version'</span>            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="hljs groovy">when &#123;branch <span class="hljs-string">'development'</span>&#125;</code></pre><p>when 用于判断</p><pre><code class="hljs groovy">pipeline &#123;  agent any  stages &#123;    stage(<span class="hljs-string">'Test'</span>) &#123;      steps &#123;        <span class="hljs-comment">/* `make check` 在测试失败后返回非零的退出码；</span><span class="hljs-comment">         * 使用 `true` 允许流水线继续进行</span><span class="hljs-comment">         */</span>        sh <span class="hljs-string">'make check || true'</span>         junit <span class="hljs-string">'**/target/*.xml'</span>       &#125;    &#125;  &#125;&#125;</code></pre><pre><code class="hljs groovy">choice(<span class="hljs-symbol">  description:</span> <span class="hljs-string">'Run flyway database migration using latest master branch from prices in what environment?'</span>,<span class="hljs-symbol">  name:</span> <span class="hljs-string">'environment'</span>,<span class="hljs-symbol">  choices:</span> [<span class="hljs-string">'PRE'</span>, <span class="hljs-string">'PRO'</span>])</code></pre><p>input</p><pre><code class="hljs groovy">input &#123;  message <span class="hljs-string">"是否继续?"</span>  ok <span class="hljs-string">"发布 "</span>  submitter <span class="hljs-string">"alice,bob"</span>  parameters &#123;    string(<span class="hljs-string">name:</span> <span class="hljs-string">'IP'</span>, <span class="hljs-string">defaultValue:</span> <span class="hljs-string">'0.0.0.0'</span>, <span class="hljs-string">description:</span> <span class="hljs-string">'线上节点 1'</span>)  &#125;&#125;</code></pre><pre><code class="hljs sh">nohup java -jar -Dspring.profiles.active=prod /data/jars/admin-io-better-cn-api/master/admin-io-better-cn-api-master.jar &gt;/data/nohup.out 2&gt;&amp;1 &amp;</code></pre><pre><code class="hljs sh">ps -ef |grep java|grep admin-io-better-cn-api-master.jar|grep prod|grep -v grep|awk <span class="hljs-string">'&#123;print $2&#125;'</span></code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote><p>BUILD_ID</p><p>当前构建的 ID，与 Jenkins 版本 1.597+ 中创建的构建号 BUILD_NUMBER 是完全相同的。</p><p>BUILD_NUMBER</p><p>当前构建号，比如 “153”。</p><p>BUILD_TAG</p><p>字符串 <code>jenkins-${JOB_NAME}-${BUILD_NUMBER}</code>。可以放到源代码、jar 等文件中便于识别。</p><p>BUILD_URL</p><p>可以定位此次构建结果的 URL（比如 <a href="http://buildserver/jenkins/job/MyJobName/17/" target="_blank" rel="noopener">http://buildserver/jenkins/job/MyJobName/17/</a> ）</p><p>EXECUTOR_NUMBER</p><p>用于识别执行当前构建的执行者的唯一编号（在同一台机器的所有执行者中）。这个就是你在“构建执行状态”中看到的编号，只不过编号从 0 开始，而不是 1。</p><p>JAVA_HOME</p><p>如果你的任务配置了使用特定的一个 JDK，那么这个变量就被设置为此 JDK 的 JAVA_HOME。当设置了此变量时，PATH 也将包括 JAVA_HOME 的 bin 子目录。</p><p>JENKINS_URL</p><p>Jenkins 服务器的完整 URL，比如 <a href="https://example.com:port/jenkins/">https://example.com:port/jenkins/</a> （注意：只有在“系统设置”中设置了 Jenkins URL 才可用）。</p><p>JOB_NAME</p><p>本次构建的项目名称，如 “foo” 或 “foo/bar”。</p><p>NODE_NAME</p><p>运行本次构建的节点名称。对于 master 节点则为 “master”。</p><p>WORKSPACE</p><p>workspace 的绝对路径。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI</tag>
      
      <tag>Jenkins</tag>
      
      <tag>Pipeline</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-执行</title>
    <link href="/2020/10/09/mybatis-execute/index/"/>
    <url>/2020/10/09/mybatis-execute/index/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-语句执行"><a href="#Mybatis-语句执行" class="headerlink" title="Mybatis-语句执行"></a>Mybatis-语句执行</h1><h2 id="本章讲述的内容"><a href="#本章讲述的内容" class="headerlink" title="本章讲述的内容"></a>本章讲述的内容</h2><p>本章主要讲解Mybatis在启动后是如何执行Mapper文件中对应SQL语句的。带着下面几个问题我们正式进入Mybatis语句执行分析。</p><blockquote><p>1、Mybatis是如何实现一级缓存的？</p><p>2、Mybatis是如何执行SQL的？有几种执行器？</p><p>3、Mybatis是如何处理查询结果的？</p></blockquote><p>想知道如何使用Mybatis请参考<a href="https://mybatis.org/mybatis-3/zh/" target="_blank" rel="noopener">Mybatis官方文档</a>。</p><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="配置XML"><a href="#配置XML" class="headerlink" title="配置XML"></a>配置XML</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"io.better.mybatis.mapper.UserMapper"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"io.better.mybatis.model.User"</span>&gt;</span>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span>        <span class="hljs-comment">&lt;!--@Table tbl_user--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"username"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"phone"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"phone"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"address"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Name_Column"</span>&gt;</span>            username    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Base_Column_List"</span>&gt;</span>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span>        id,        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Name_Column"</span>/&gt;</span>,        phone,        address    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByPrimaryKey"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Long"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span>&gt;</span>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span>        select        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span>/&gt;</span>        from tbl_user        where id = #&#123;id,jdbcType=BIGINT&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><h3 id="全局配置XML"><a href="#全局配置XML" class="headerlink" title="全局配置XML"></a>全局配置XML</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"jdbc.properties"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SLF4J"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"useGeneratedKeys"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultExecutorType"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"BATCH"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"io.better.mybatis.model"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/source-code-analysis"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123456"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-comment">&lt;!--&lt;package name="io.better.mybatis.mapper"/&gt;--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"mybatis/mappers/UserMapper.xml"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> better create in 2020/4/19 10:30 上午</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisTest</span> </span>&#123;    SqlSessionFactory sqlSessionFactory;    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        String resource = <span class="hljs-string">"mybatis/mybatis-config.xml"</span>;        InputStream inputStream = Resources.getResourceAsStream(resource);        sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testList</span><span class="hljs-params">()</span> </span>&#123;        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        User user = mapper.selectByPrimaryKey(<span class="hljs-number">1L</span>);        System.out.println(user);    &#125;&#125;</code></pre><p>从代码可以看出一共执行了三个操作：</p><p>1、调用<code>SqlSessionFactory</code>创建<code>SqlSession</code>对象。</p><p>2、调用SqlSession获取Mapper代理对象。</p><p>3、调用Mapper代理对象执行目标方法获取结果。</p><h2 id="获取SqlSession"><a href="#获取SqlSession" class="headerlink" title="获取SqlSession"></a>获取SqlSession</h2><h3 id="调用openSession-创建SqlSession"><a href="#调用openSession-创建SqlSession" class="headerlink" title="调用openSession()创建SqlSession"></a>调用<code>openSession()</code>创建SqlSession</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSession <span class="hljs-title">openSession</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> SqlSession <span class="hljs-title">openSessionFromDataSource</span><span class="hljs-params">(ExecutorType execType, TransactionIsolationLevel level, <span class="hljs-keyword">boolean</span> autoCommit)</span> </span>&#123;  Transaction tx = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 获取环境配置</span>    <span class="hljs-keyword">final</span> Environment environment = configuration.getEnvironment();    <span class="hljs-comment">// 步骤①</span>    <span class="hljs-keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);    <span class="hljs-comment">// 步骤②</span>    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);    <span class="hljs-comment">// 步骤③</span>    <span class="hljs-keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);    <span class="hljs-comment">// 步骤④</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-comment">// 忽略部分代码</span>  &#125;&#125;</code></pre><p>上诉代码中我们需要重点关注一个点：1、<code>configuration.getDefaultExecutorType()：</code>它用于指定Executor的类型，默认即<code>ExecutorType.SIMPLE</code>。</p><p>在<code>openSessionFromDataSource</code>方法中，Mybatis做了下面几个操作：</p><ul><li>步骤①：创建TransactionFactory，类型为：<code>JdbcTransactionFactory</code>。<ul><li>对应Mybatis配置中 <transactionManager type="JDBC"/>标签。</li></ul></li><li>步骤②：创建Transaction事务对象，并对<code>autoCommit，IsolationLevel</code> 属性赋值。</li><li>步骤③：根据<code>execType</code>创建执行类型的<code>Executor</code>执行器。</li><li>步骤④：创建<code>DefaultSqlSession</code>对象。</li></ul><h4 id="创建Transaction"><a href="#创建Transaction" class="headerlink" title="创建Transaction"></a>创建<code>Transaction</code></h4><p>源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Transaction <span class="hljs-title">newTransaction</span><span class="hljs-params">(DataSource ds, TransactionIsolationLevel level, <span class="hljs-keyword">boolean</span> autoCommit)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTransaction(ds, level, autoCommit);&#125;</code></pre><p>代码中直接调用<code>JdbcTransaction</code>构造器进行Transaction创建。那么JdbcTransaction将就能干什么事情呢？让我们来看看JdbcTransaction的类结构图。</p><p><img src="https://raw.githubusercontent.com/io-better-chen/better.io.images/master/images/image-20200428162608413.png" srcset="/img/loading.gif" alt="image-20200428162608413"></p><p>从类图可以看出JdbcTransaction主要是负责<code>提交、回滚、关闭Transaction</code>，<code>打开、获取Connection</code>等操作。</p><h4 id="创建Executor"><a href="#创建Executor" class="headerlink" title="创建Executor"></a>创建<code>Executor</code></h4><p><code>Configuration#newExecutor(Transaction, ExecutorType)</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">newExecutor</span><span class="hljs-params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;  <span class="hljs-comment">// 判断 executorType </span>  executorType = executorType == <span class="hljs-keyword">null</span> ? defaultExecutorType : executorType;  executorType = executorType == <span class="hljs-keyword">null</span> ? ExecutorType.SIMPLE : executorType;  Executor executor;  <span class="hljs-keyword">if</span> (ExecutorType.BATCH == executorType) &#123;    <span class="hljs-comment">// 批量执行器</span>    executor = <span class="hljs-keyword">new</span> BatchExecutor(<span class="hljs-keyword">this</span>, transaction);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ExecutorType.REUSE == executorType) &#123;    <span class="hljs-comment">// 可重用执行器</span>    executor = <span class="hljs-keyword">new</span> ReuseExecutor(<span class="hljs-keyword">this</span>, transaction);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 默认执行器</span>    executor = <span class="hljs-keyword">new</span> SimpleExecutor(<span class="hljs-keyword">this</span>, transaction);  &#125;  <span class="hljs-keyword">if</span> (cacheEnabled) &#123;    <span class="hljs-comment">// 缓存执行器，类似于一个装饰器</span>    executor = <span class="hljs-keyword">new</span> CachingExecutor(executor);  &#125;  <span class="hljs-comment">// 将执行器传递给每个插件拦截器</span>  executor = (Executor) interceptorChain.pluginAll(executor);  <span class="hljs-keyword">return</span> executor;&#125;</code></pre><p>代码中可以看出，执行器的类型一共有三种：<code>批量-&gt;BatchExecutor，可重用-&gt;ReuseExecutor，简单-&gt;SimpleExecutor</code>。</p><p>而<code>CachingExecutor</code>是一个装饰类，包装了具体的Executor，主要用于做一些缓存操作。</p><p>默认为<code>SimpleExecutor</code>执行器，我们这里使用是<code>BatchExecutor</code>执行器。可以通过下面的配置修改：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultExecutorType"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"BATCH"</span>/&gt;</span></code></pre><p>最后将创建好的执行器交给<code>interceptorChain</code>，此处代码是为了扩展。</p><p>因为代码最终会走向<code>Plugin.wrap</code>方法中，并为其创建 <code>Plugin</code>这个代理对象（<code>如果有拦截器处理则创建，没有则无</code>）。</p><p><img src="https://raw.githubusercontent.com/io-better-chen/better.io.images/master/images/20200429161400.png" srcset="/img/loading.gif" alt="image-20200429161316723"></p><h4 id="创建DefaultSqlSession"><a href="#创建DefaultSqlSession" class="headerlink" title="创建DefaultSqlSession"></a>创建<code>DefaultSqlSession</code></h4><p>源代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSqlSession</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SqlSession</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration configuration;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor executor;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> autoCommit;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> dirty;  <span class="hljs-keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultSqlSession</span><span class="hljs-params">(Configuration configuration, Executor executor, <span class="hljs-keyword">boolean</span> autoCommit)</span> </span>&#123;    <span class="hljs-keyword">this</span>.configuration = configuration;    <span class="hljs-keyword">this</span>.executor = executor;    <span class="hljs-keyword">this</span>.dirty = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">this</span>.autoCommit = autoCommit;  &#125;&#125;</code></pre><p>DefaultSqlSession的构造比较简单，仅仅是对类中部分属性进行赋值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在获取SqlSession阶段主要是初始化了<code>Transaction，Executor，SqlSession</code>三个对象。</p><h2 id="获取指定Mapper"><a href="#获取指定Mapper" class="headerlink" title="获取指定Mapper"></a>获取指定Mapper</h2><h3 id="调用getMapper-获取Mapper"><a href="#调用getMapper-获取Mapper" class="headerlink" title="调用getMapper()获取Mapper"></a>调用<code>getMapper()</code>获取Mapper</h3><pre><code class="hljs java"><span class="hljs-comment">// DefaultSqlSession.getMapper</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;  <span class="hljs-keyword">return</span> configuration.getMapper(type, <span class="hljs-keyword">this</span>);&#125;<span class="hljs-comment">// Configuration.getMapper</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;  <span class="hljs-keyword">return</span> mapperRegistry.getMapper(type, sqlSession);&#125;</code></pre><p>代码最终调用到了Configuration对象中。</p><p>因为Mybatis在启动加载阶段将所有的Mapper接口都注册到了<code>Configuration.mapperRegistry</code>对象中。</p><h3 id="创建MapperProxy"><a href="#创建MapperProxy" class="headerlink" title="创建MapperProxy"></a>创建MapperProxy</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;  <span class="hljs-comment">// 获取到MapperProxy工厂</span>  <span class="hljs-keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 创建MapperProxy对象</span>    <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  &#125;&#125;<span class="hljs-comment">// MapperProxyFactory</span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> </span>&#123;  <span class="hljs-comment">// 创建MapperProxy对象</span>  <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);  <span class="hljs-comment">// 调用JDK的Proxy.newProxyInstance() 创建实例</span>  <span class="hljs-keyword">return</span> newInstance(mapperProxy);&#125;</code></pre><p>从代码可以看出Mybatis在获取每一个Mapper接口时都为其创建了一个MapperProxy代理对象。最终调用JDK创建代理。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong><code>在获取Mapper接口阶段主要是操作是：为指定Mapper接口创建代理对象MapperProxy</code></strong>。</p><h2 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h2><h3 id="调用MapperProxy-invoke"><a href="#调用MapperProxy-invoke" class="headerlink" title="调用MapperProxy.invoke"></a>调用<code>MapperProxy.invoke</code></h3><p>当调用SqlSession返回Mapper接口中的方法时，会调用到MapperProxy对象的<code>invoke</code>方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  <span class="hljs-keyword">if</span> (Object<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">equals</span>(<span class="hljs-title">method</span>.<span class="hljs-title">getDeclaringClass</span>())) </span>&#123;    <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// cachedInvoker会生成MapperMethodInvoker对象，并将其缓存</span>    <span class="hljs-comment">// 调用invoke执行方法</span>    <span class="hljs-keyword">return</span> cachedInvoker(method).invoke(proxy, method, args, sqlSession);  &#125;&#125;<span class="hljs-comment">// cachedInvoker方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> MapperMethodInvoker <span class="hljs-title">cachedInvoker</span><span class="hljs-params">(Method method)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  <span class="hljs-comment">// 被调用过的方法会被缓存起来，避免重复创建</span>  <span class="hljs-keyword">return</span> methodCache.computeIfAbsent(method, m -&gt; &#123;    <span class="hljs-keyword">if</span> (m.isDefault()) &#123;      <span class="hljs-keyword">if</span> (privateLookupInMethod == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultMethodInvoker(getMethodHandleJava8(method));      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultMethodInvoker(getMethodHandleJava9(method));      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 默认第一次都会创建PlainMethodInvoker。</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PlainMethodInvoker(<span class="hljs-keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));    &#125;  &#125;);&#125;</code></pre><p>Mybatis会先调用<code>cachedInvoker</code>方法，判断当前执行的方法是否已经创建过<code>MethodInvoker</code>：</p><p>1、如果没有则创建<code>MapperMethod</code>封装当前执行的方法：</p><p>​    1、如果执行的方法不是Default方法，则创建<code>PlainMethodInvoker</code> 并赋值。</p><p>​    2、如果执行的是Default方法，则创建<code>DefaultMethodInvoker</code>并赋值。</p><p>2、如果已经创建，则直接从<code>methodCache</code>中获取。</p><h3 id="调用MapperMethodInvoker-invoke"><a href="#调用MapperMethodInvoker-invoke" class="headerlink" title="调用MapperMethodInvoker.invoke"></a>调用<code>MapperMethodInvoker.invoke</code></h3><p>源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  <span class="hljs-comment">// 调用上面cachedInvoker方法创建的MapperMethod对象，执行SQL</span>  <span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);&#125;</code></pre><p>调用上一步创建的<code>MapperMethod</code>对象执行目标Mapper方法。</p><h3 id="调用MapperMethod-execute"><a href="#调用MapperMethod-execute" class="headerlink" title="调用MapperMethod.execute"></a>调用<code>MapperMethod.execute</code></h3><p>源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;  Object result;  <span class="hljs-comment">// 判断sql指令类型：insert，select，update，delete</span>  <span class="hljs-keyword">switch</span> (command.getType()) &#123;    Object param = method.convertArgsToSqlCommandParam(args);    <span class="hljs-comment">// 插入指令</span>    <span class="hljs-keyword">case</span> INSERT: &#123;      result = rowCountResult(sqlSession.insert(command.getName(), param));      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">// 更新指令</span>    <span class="hljs-keyword">case</span> UPDATE: &#123;      result = rowCountResult(sqlSession.update(command.getName(), param));      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">// 删除指令</span>    <span class="hljs-keyword">case</span> DELETE: &#123;      result = rowCountResult(sqlSession.delete(command.getName(), param));      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">// 查询指令</span>    <span class="hljs-keyword">case</span> SELECT:      <span class="hljs-comment">// </span>      <span class="hljs-keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;        executeWithResultHandler(sqlSession, args);        result = <span class="hljs-keyword">null</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMany()) &#123;<span class="hljs-comment">// List结果集</span>        result = executeForMany(sqlSession, args);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMap()) &#123;        <span class="hljs-comment">// Map结果集</span>        result = executeForMap(sqlSession, args);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsCursor()) &#123;        <span class="hljs-comment">// Cursor结果集</span>        result = executeForCursor(sqlSession, args);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 单个结果集</span>        result = sqlSession.selectOne(command.getName(), param);<span class="hljs-comment">// 忽略部分代码</span>      &#125;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> FLUSH:      result = sqlSession.flushStatements();      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"Unknown execution method for: "</span> + command.getName());  &#125;<span class="hljs-comment">// 忽略部分代码</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>我们可以看出<code>MapperMethod</code>类是执行Mapper方法的核心类。</p><p>在这个方法中我们分别看到了Mybatis对新增，更新，删除，查询所执行的操作。</p><p>通过判断<code>command</code>指令类型来断定SQL语句的类型。改对象(<code>command</code>)是在MapperMethod构造器中被初始化。</p><p><code>新增，更新，删除，查询</code>四个操作最终都调用了<code>sqlSession</code>中对应的方法。</p><p>而<code>executeForMany，executeForMap，executeForCursor</code>三个方法最终分别调用了<code>SqlSession</code>的<code>selectList，selectMap，selectCursor</code>方法。</p><p><strong><code>可以看出Mybatis的SQL执行最终是在SqlSession中完成的</code></strong>。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><h4 id="获取单个结果-selectList"><a href="#获取单个结果-selectList" class="headerlink" title="获取单个结果-selectList"></a>获取单个结果-<code>selectList</code></h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">selectOne</span><span class="hljs-params">(String statement, Object parameter)</span> </span>&#123;<span class="hljs-comment">// 调用同类的selectList方法</span>  List&lt;T&gt; list = <span class="hljs-keyword">this</span>.selectList(statement, parameter);  <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 返回第一个</span>    <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 抛出异常</span>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TooManyResultsException();  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;&#125;<span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    MappedStatement ms = configuration.getMappedStatement(statement);    <span class="hljs-comment">// 调用执行器执行查询</span>    <span class="hljs-keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);  &#125; <span class="hljs-keyword">finally</span> &#123;  &#125;&#125;</code></pre><p>在<code>selectOne</code>方法中调用了<code>selectList</code>方法。并对结果集进行了判断，超过一个抛出异常。</p><p>在<code>selectList</code>方法中<code>Mybatis</code>获取到了解析<code>Mapper</code>文件时生成的<code>MappedStatement</code>对象。并将其传递给了<code>Executor</code>。</p><p><strong>而上面的<code>executeForMany，executeForMap，executeForCursor</code>三个方法查询时最终都调用的是<code>selectList</code>方法</strong>。</p><h4 id="执行查询-Executor"><a href="#执行查询-Executor" class="headerlink" title="执行查询-Executor"></a>执行查询-<code>Executor</code></h4><p><code>CachingExecutor.query</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  BoundSql boundSql = ms.getBoundSql(parameterObject);  <span class="hljs-comment">// 调用包装的执行器创建缓存Key</span>  CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);  <span class="hljs-comment">// 继续调用同类Query方法</span>  <span class="hljs-keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&#125;</code></pre><p><code>CachingExecutor.query</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><span class="hljs-function">  <span class="hljs-keyword">throws</span> SQLException </span>&#123;  <span class="hljs-comment">// 获取缓存</span>  Cache cache = ms.getCache();  <span class="hljs-comment">// 默认第一次为空</span>  <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;    flushCacheIfRequired(ms);    <span class="hljs-keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="hljs-keyword">null</span>) &#123;      ensureNoOutParams(ms, boundSql);<span class="hljs-comment">// private final TransactionalCacheManager tcm = new TransactionalCacheManager();</span>      <span class="hljs-comment">// 从事务缓存管理器中获取，并判断是否已经存在执行过</span>      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);      <span class="hljs-comment">// 如果为空，说明没执行过</span>      <span class="hljs-keyword">if</span> (list == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 调用包装执行器执行</span>        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);        <span class="hljs-comment">// 将执行的结果放入缓存中</span>        tcm.putObject(cache, key, list); <span class="hljs-comment">// issue #578 and #116</span>      &#125;      <span class="hljs-keyword">return</span> list;    &#125;  &#125;  <span class="hljs-comment">// 调用包装执行器执行query</span>  <span class="hljs-keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&#125;</code></pre><p><code>BaseExecutor.query</code></p><pre><code class="hljs java"><span class="hljs-comment">// 父类BaseExecutor.query</span><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  List&lt;E&gt; list;  <span class="hljs-keyword">try</span> &#123;    queryStack++;    list = resultHandler == <span class="hljs-keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// </span>      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 执行查询,最终执行的结果会放入localCache对象中。</span>      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);    &#125;  &#125; <span class="hljs-keyword">finally</span> &#123;    queryStack--;  &#125;  <span class="hljs-keyword">return</span> list;&#125;</code></pre><p>可以看出三个方法中都是做了很多缓存操作，提高效率，</p><h4 id="核心查询-doQuery"><a href="#核心查询-doQuery" class="headerlink" title="核心查询-doQuery"></a>核心查询-<code>doQuery</code></h4><h5 id="BatchExecutor-doQuery-Core"><a href="#BatchExecutor-doQuery-Core" class="headerlink" title="BatchExecutor.doQuery (Core)"></a><code>BatchExecutor.doQuery (Core)</code></h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  Statement stmt = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">try</span> &#123;    flushStatements();    Configuration configuration = ms.getConfiguration();    <span class="hljs-comment">// 创建StatementHandler</span>    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, rowBounds, resultHandler, boundSql);    <span class="hljs-comment">// 获取Connection，如果没有则使用DataSource进行创建</span>    Connection connection = getConnection(ms.getStatementLog());    <span class="hljs-comment">// 创建Statement对象，并设置timeOut和fetchSize属性</span>    stmt = handler.prepare(connection, transaction.getTimeout());    <span class="hljs-comment">// 进行参数替换</span>    handler.parameterize(stmt);    <span class="hljs-comment">// 执行SQL查询，获取到结果集，调用ResultSetHandler.handleResultSets进行结果集处理。</span>    <span class="hljs-keyword">return</span> handler.query(stmt, resultHandler);  &#125; <span class="hljs-keyword">finally</span> &#123;    closeStatement(stmt);  &#125;&#125;</code></pre><p>该方法主要的作用是操作<code>Statement</code>对象。<code>1、创建StatementHandler处理对象。2、获取Connection连接。3、初始化Statement对象。4、进行参数替换。5、执行SQL完成查询</code>。</p><h4 id="处理查询结果"><a href="#处理查询结果" class="headerlink" title="处理查询结果"></a>处理查询结果</h4><h5 id="ResultSetHandler-handleResultSets"><a href="#ResultSetHandler-handleResultSets" class="headerlink" title="ResultSetHandler.handleResultSets"></a><code>ResultSetHandler.handleResultSets</code></h5><p>源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">handleResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  <span class="hljs-keyword">final</span> List&lt;Object&gt; multipleResults = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-keyword">int</span> resultSetCount = <span class="hljs-number">0</span>;  ResultSetWrapper rsw = getFirstResultSet(stmt);<span class="hljs-comment">// 获取当前Mapper的ResultMap</span>  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();  <span class="hljs-keyword">int</span> resultMapCount = resultMaps.size();<span class="hljs-comment">// 遍历resultMaps</span>  <span class="hljs-keyword">while</span> (rsw != <span class="hljs-keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;    <span class="hljs-comment">// 获取resultMap</span>    ResultMap resultMap = resultMaps.get(resultSetCount);    <span class="hljs-comment">// 处理ResultSet</span>    handleResultSet(rsw, resultMap, multipleResults, <span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 获取下一个ResultSet</span>    rsw = getNextResultSet(stmt);    cleanUpAfterHandlingResultSet();    resultSetCount++;  &#125;<span class="hljs-comment">// 处理ResultSet</span>  String[] resultSets = mappedStatement.getResultSets();  <span class="hljs-keyword">if</span> (resultSets != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">while</span> (rsw != <span class="hljs-keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;      <span class="hljs-comment">// 获取ResultMapping</span>      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);      <span class="hljs-keyword">if</span> (parentMapping != <span class="hljs-keyword">null</span>) &#123;        String nestedResultMapId = parentMapping.getNestedResultMapId();        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);        handleResultSet(rsw, resultMap, <span class="hljs-keyword">null</span>, parentMapping);      &#125;      rsw = getNextResultSet(stmt);      cleanUpAfterHandlingResultSet();      resultSetCount++;    &#125;  &#125;  <span class="hljs-keyword">return</span> collapseSingleResultList(multipleResults);&#125;</code></pre><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Orm</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybaits-启动加载</title>
    <link href="/2020/10/09/mybatis-init-load/index/"/>
    <url>/2020/10/09/mybatis-init-load/index/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-启动加载"><a href="#Mybatis-启动加载" class="headerlink" title="Mybatis-启动加载"></a>Mybatis-启动加载</h1><h2 id="本章节讲述的内容"><a href="#本章节讲述的内容" class="headerlink" title="本章节讲述的内容"></a>本章节讲述的内容</h2><blockquote><p>本章节主要分析Mybatis在启动时做了那些操作。带着以下疑问去阅读本章内容。本章内容涉及了大量的mybatis源码。</p><p>1、Mybaits是如何解析配置文件（mybatis-config.xml）？</p><p>2、Mybaits是如何解析Mapper文件（mapper.xml）？</p><p>3、Mybatis是如何设计</p></blockquote><p>想知道如何使用Mybatis请参考<a href="https://mybatis.org/mybatis-3/zh/" target="_blank" rel="noopener">Mybatis官方文档</a>。</p><h2 id="相关配置依赖"><a href="#相关配置依赖" class="headerlink" title="相关配置依赖"></a>相关配置依赖</h2><p>本文使用的Mybatis版本：<code>3.5.4</code>，不依赖任何Spring的环境。</p><h3 id="坐标依赖"><a href="#坐标依赖" class="headerlink" title="坐标依赖"></a>坐标依赖</h3><p>Maven坐标：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>Gradle坐标：</p><pre><code class="hljs groovy">compile <span class="hljs-string">'org.mybatis:mybatis:3.5.4'</span></code></pre><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SLF4J"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"useGeneratedKeys"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logPrefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"source-code-analysis"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"io.better.mybatis.model"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/source-code-analysis"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123456"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"mybatis/mappers/UserMapper.xml"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><p><strong>Mybatis的启动时主要分为两个阶段：<code>配置文件加载解析阶段，Mapper文件加载解析阶段</code>。</strong></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisTest</span> </span>&#123;    SqlSessionFactory sqlSessionFactory;    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        String resource = <span class="hljs-string">"mybatis/mybatis-config.xml"</span>;        InputStream inputStream = Resources.getResourceAsStream(resource);        sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSqlSessionFactoryInit</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(sqlSessionFactory);    &#125;&#125;</code></pre><h2 id="配置文件加载解析阶段"><a href="#配置文件加载解析阶段" class="headerlink" title="配置文件加载解析阶段"></a>配置文件加载解析阶段</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在这个阶段我们会去了解Mybatis是如何解析配置文件的？</p><h3 id="构建开始"><a href="#构建开始" class="headerlink" title="构建开始"></a>构建开始</h3><p>从官网文档我们知道使用Mybatis第一步就是使用<code>SqlSessionFactoryBuilder</code>来构建<code>SqlSessionFactory</code>。</p><p>而<code>SqlSessionFactoryBuilder</code>类提供了多个重载的<code>build</code>方法：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164710.png" srcset="/img/loading.gif" alt="image-20200430102857721" style="zoom:50%;" /><p>这里我们使用的是<code>build(InputStream)</code>方法。进入该方法的源代码：</p><h3 id="执行-SqlSessionFactoryBuilder-build"><a href="#执行-SqlSessionFactoryBuilder-build" class="headerlink" title="执行-SqlSessionFactoryBuilder.build()"></a>执行-<code>SqlSessionFactoryBuilder.build()</code></h3><p>源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 创建XMLConfigBuilder，该对象用于解析Mybatis配置文件</span>    XMLConfigBuilder parser = <span class="hljs-keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);    <span class="hljs-comment">// build会用解析配置文件的结果来创建SqlSessionFactory</span>    <span class="hljs-keyword">return</span> build(parser.parse());  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  &#125; <span class="hljs-keyword">finally</span> &#123;&#125;&#125;</code></pre><p>其中 <code>build</code>方法比较简单，就是使用<code>XMLConfigBuilder.parse</code>生成的<code>Configuration</code>对象创建<code>SqlSessionFactory</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(Configuration config)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSessionFactory(config);&#125;</code></pre><p>而<code>XMLConfigBuilder.parse</code>方法主要描述了Mybatis解析配置文件并生成Configuration对象的过程。</p><p>成员变量：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164704.png" srcset="/img/loading.gif" alt="image-20200430103839043"></p><ul><li><code>parsed：</code>标识了配置是否已经解析。</li><li><code>parser：</code>用于解析XML配置文件</li><li><code>environment：</code>Mybatis的环境配置</li><li><code>localReflectorFactory：</code>反射工厂</li></ul><p>构造器：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164659.png" srcset="/img/loading.gif" alt="image-20200430104004899"></p><p><code>org.apache.ibatis.builder.xml.XMLConfigBuilder#parse</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (parsed) &#123;<span class="hljs-comment">// 已经解析过直接抛出异常</span>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Each XMLConfigBuilder can only be used once."</span>);  &#125;  parsed = <span class="hljs-keyword">true</span>;<span class="hljs-comment">// 将parsed置为true，避免重复解析。</span><span class="hljs-comment">// 调用parser获取配置文件中的configuration节点</span>  <span class="hljs-comment">// 调用parseConfiguration方法继续解析</span>  parseConfiguration(parser.evalNode(<span class="hljs-string">"/configuration"</span>));  <span class="hljs-keyword">return</span> configuration;&#125;</code></pre><h3 id="执行-XMLConfigBuilder-parseConfiguration"><a href="#执行-XMLConfigBuilder-parseConfiguration" class="headerlink" title="执行-XMLConfigBuilder.parseConfiguration()"></a>执行-<code>XMLConfigBuilder.parseConfiguration()</code></h3><p>源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 解析properties标签配置</span>    propertiesElement(root.evalNode(<span class="hljs-string">"properties"</span>));    <span class="hljs-comment">// 解析settings标签配置</span>    Properties settings = settingsAsProperties(root.evalNode(<span class="hljs-string">"settings"</span>));<span class="hljs-comment">// 使用setting配置日志实现类</span>    loadCustomLogImpl(settings);    <span class="hljs-comment">// 解析typeAliases标签配置</span>    typeAliasesElement(root.evalNode(<span class="hljs-string">"typeAliases"</span>));    <span class="hljs-comment">// 解析plugins标签配置</span>    pluginElement(root.evalNode(<span class="hljs-string">"plugins"</span>));    <span class="hljs-comment">// 使用settings配置对configuration对象中的属性进行赋值</span>    settingsElement(settings);    <span class="hljs-comment">// 解析environments标签配置</span>    environmentsElement(root.evalNode(<span class="hljs-string">"environments"</span>));    <span class="hljs-comment">// 解析mappers标签配置, 开启Mapper文件解析阶段</span>    mapperElement(root.evalNode(<span class="hljs-string">"mappers"</span>));  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);  &#125;&#125;</code></pre><p>在<code>parseConfiguration</code>方法中，Mybatis对配置中的不同标签分别进行了处理，这里只列举常用的标签配置，例如：<code>properties，settings，typeAliases，plugins，environments，mappers</code>等标签进行了处理。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 解析properties标签配置</span>    propertiesElement(root.evalNode(<span class="hljs-string">"properties"</span>));    <span class="hljs-comment">// 解析settings标签配置</span>    Properties settings = settingsAsProperties(root.evalNode(<span class="hljs-string">"settings"</span>));<span class="hljs-comment">// 使用setting配置日志实现类</span>    loadCustomLogImpl(settings);    <span class="hljs-comment">// 解析typeAliases标签配置</span>    typeAliasesElement(root.evalNode(<span class="hljs-string">"typeAliases"</span>));    <span class="hljs-comment">// 解析plugins标签配置</span>    pluginElement(root.evalNode(<span class="hljs-string">"plugins"</span>));    <span class="hljs-comment">// 使用settings配置对configuration对象中的属性进行赋值</span>    settingsElement(settings);    <span class="hljs-comment">// 解析environments标签配置</span>    environmentsElement(root.evalNode(<span class="hljs-string">"environments"</span>));    <span class="hljs-comment">// 解析mappers标签配置, 开启Mapper文件解析阶段</span>    mapperElement(root.evalNode(<span class="hljs-string">"mappers"</span>));  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);  &#125;&#125;</code></pre><h4 id="解析Properties标签"><a href="#解析Properties标签" class="headerlink" title="解析Properties标签"></a>解析<code>Properties</code>标签</h4><p>从上面代码可以看出<code>propertiesElement</code>方法是解析Properties标签的核心方法，源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">propertiesElement</span><span class="hljs-params">(XNode context)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 获取properties标签中resource和url配置</span>    String resource = context.getStringAttribute(<span class="hljs-string">"resource"</span>);    String url = context.getStringAttribute(<span class="hljs-string">"url"</span>);    <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 使用resource路径加载properties</span>      defaults.putAll(Resources.getResourceAsProperties(resource));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 使用url加载properties</span>      defaults.putAll(Resources.getUrlAsProperties(url));    &#125;    <span class="hljs-comment">// 获取到configuration中已有的属性</span>    Properties vars = configuration.getVariables();    <span class="hljs-keyword">if</span> (vars != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 合并</span>      defaults.putAll(vars);    &#125;     parser.setVariables(defaults);    <span class="hljs-comment">// 重新赋值</span>    configuration.setVariables(defaults);  &#125;&#125;</code></pre><p>可以看出解析出来的<code>Properties</code>属性，最终被赋值到了<code>Configuration</code>中的<code>variables</code>对象中。</p><pre><code class="hljs java"><span class="hljs-comment">// Configuration的成员变量</span><span class="hljs-keyword">protected</span> Properties variables = <span class="hljs-keyword">new</span> Properties();</code></pre><h4 id="解析Settings标签"><a href="#解析Settings标签" class="headerlink" title="解析Settings标签"></a>解析<code>Settings</code>标签</h4><p>使用类似的方式查看<code>settingsAsProperties</code>方法中处理<code>Setting</code>标签的逻辑。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Properties <span class="hljs-title">settingsAsProperties</span><span class="hljs-params">(XNode context)</span> </span>&#123;  <span class="hljs-keyword">if</span> (context == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Properties();  &#125;  <span class="hljs-comment">// 获取所有setting子节点，并将其转成properties</span>  Properties props = context.getChildrenAsProperties();<span class="hljs-comment">// 通过反射获取Configuration类的元数据信息</span>  MetaClass metaConfig = MetaClass.forClass(Configuration<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">localReflectorFactory</span>)</span>;  <span class="hljs-comment">// 判断配置的属性在Configuration是否存在</span>  <span class="hljs-keyword">for</span> (Object key : props.keySet()) &#123;    <span class="hljs-comment">// 判断Configuration对象是否存在此配置的Setter方法。</span>    <span class="hljs-keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"此配置无效："</span> + key);    &#125;  &#125;  <span class="hljs-keyword">return</span> props;&#125;</code></pre><p><code>MetaClass.forClass</code>方法作用是使用<code>localReflectorFactory</code>创建一个<code>Reflector</code>实例，该实例中包含了Configuration类所有的<code>构造器，方法，属性</code>等。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164650.png" srcset="/img/loading.gif" alt=""></p><h4 id="使用Settings标签"><a href="#使用Settings标签" class="headerlink" title="使用Settings标签"></a>使用<code>Settings</code>标签</h4><p>上面我们知道了<code>Settings</code>配置时如何解析的，但却没有使用到<code>Settings</code>配置。</p><p><code>loadCustomVfs(settings)：</code>忽略</p><p> <code>loadCustomLogImpl(settings)：</code>设置Mybatis的日志实现。</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164645.png" srcset="/img/loading.gif" alt="image-20200430111703591"  /><p><code>settingsElement(settings)：</code>设置Mybatis所有全局配置，Settings没有则使用默认配置。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164633.png" srcset="/img/loading.gif" alt="image-20200430111538374"></p><h4 id="解析typeAliasesElement标签"><a href="#解析typeAliasesElement标签" class="headerlink" title="解析typeAliasesElement标签"></a>解析<code>typeAliasesElement</code>标签</h4><p>源代码如下:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">typeAliasesElement</span><span class="hljs-params">(XNode parent)</span> </span>&#123;  <span class="hljs-comment">// 获取到typeAliases标签下所有的子标签</span>  <span class="hljs-keyword">for</span> (XNode child : parent.getChildren()) &#123;    <span class="hljs-comment">// 如果标签以package开头，说明配置的是整个包的别名</span>    <span class="hljs-keyword">if</span> (<span class="hljs-string">"package"</span>.equals(child.getName())) &#123;      String typeAliasPackage = child.getStringAttribute(<span class="hljs-string">"name"</span>);      <span class="hljs-comment">// registerAliases方法会扫描整个包下的类，并生成其对应的Class对象</span>      <span class="hljs-comment">// 最后添加到configuration.typeAliasRegistry属性对象中</span>      configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);    &#125;     <span class="hljs-comment">// 否则就是以typeAlias开头的标签，配置的是单个别名</span>    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 获取到别名</span>      String alias = child.getStringAttribute(<span class="hljs-string">"alias"</span>);      <span class="hljs-comment">// 获取别名对应的class</span>      String type = child.getStringAttribute(<span class="hljs-string">"type"</span>);      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 根据type解析出其真实的class对象</span>        Class&lt;?&gt; clazz = Resources.classForName(type);        <span class="hljs-keyword">if</span> (alias == <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">// 别名为空，默认使用类名做为别名</span>          typeAliasRegistry.registerAlias(clazz);        &#125; <span class="hljs-keyword">else</span> &#123;          typeAliasRegistry.registerAlias(alias, clazz);        &#125;      &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;      &#125;    &#125;  &#125;&#125;</code></pre><p>从代码可以看出配置<code>typeAliases</code>有两种方式：</p><p>1、使用package标签配置整个包下的别名。</p><p>2、使用typeAlias标签配置单个别名。</p><p>获取到<code>别名对应的Class对象</code>后，最终调用了<code>typeAliasRegistry.registerAlias</code>方法注册了别名。而<code>typeAliasRegistry</code>对象引用之Configuration对象。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164624.png" srcset="/img/loading.gif" alt="image-20200430112247768"></p><p>让我们进入<code>typeAliasRegistry.registerAlias</code>方法查看具体注册逻辑</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String alias, Class&lt;?&gt; value)</span> </span>&#123;  <span class="hljs-keyword">if</span> (alias == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeException(<span class="hljs-string">"The parameter alias cannot be null"</span>);  &#125;  <span class="hljs-comment">// issue #748</span>  String key = alias.toLowerCase(Locale.ENGLISH);  <span class="hljs-comment">// 判断alias是否已经存在，且对应的class不一致，抛出异常。</span>  <span class="hljs-keyword">if</span> (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != <span class="hljs-keyword">null</span> &amp;&amp; !typeAliases.get(key).equals(value)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeException(<span class="hljs-string">""</span>);  &#125;  <span class="hljs-comment">// 放入typeAliases中</span>  typeAliases.put(key, value);&#125;</code></pre><p>让我们看一下该类的结构图：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164616.png" srcset="/img/loading.gif" alt="image-20200430112955479"></p><p>从类结构图能看出<code>TypeAliasRegistry</code>类中重载了很多<code>registerAliases</code>方法，同时<code>typeAliases</code>保存了所有注册的别名信息。并且在初始化时默认添加了很多基础类型对应的别名。</p><p>结论：Mybatis将解析的别名配置，最终放入了<code>Configuration</code>中的<code>TypeAliasRegistry</code>对象中。</p><h4 id="解析plugins标签"><a href="#解析plugins标签" class="headerlink" title="解析plugins标签"></a>解析<code>plugins</code>标签</h4><p>源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pluginElement</span><span class="hljs-params">(XNode parent)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">for</span> (XNode child : parent.getChildren()) &#123;      <span class="hljs-comment">// 获取配置的interceptor对应的class信息</span>      String interceptor = child.getStringAttribute(<span class="hljs-string">"interceptor"</span>);      <span class="hljs-comment">// 获取plugin标签下的属性</span>      Properties properties = child.getChildrenAsProperties();      <span class="hljs-comment">// resolveClass方法解析具体interceptor的class</span>      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();      <span class="hljs-comment">// 将属性赋值给Interceptor</span>      interceptorInstance.setProperties(properties);      <span class="hljs-comment">// 添加到Configuration中</span>      configuration.addInterceptor(interceptorInstance);    &#125;  &#125;&#125;</code></pre><p>可以看出解析Interceptor最终通过反射初始化被添加到了Configuration中 。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164611.png" srcset="/img/loading.gif" alt="image-20200430141031684"></p><h4 id="解析environmentsElement标签"><a href="#解析environmentsElement标签" class="headerlink" title="解析environmentsElement标签"></a>解析<code>environmentsElement</code>标签</h4><p>参考Xml：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/source-code-analysis"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123456"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></code></pre><p>源代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">environmentsElement</span><span class="hljs-params">(XNode context)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span> (environment == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 获取默认的environment，即上面的development</span>      environment = context.getStringAttribute(<span class="hljs-string">"default"</span>);    &#125;    <span class="hljs-comment">// 获取到所有的environment子标签</span>    <span class="hljs-keyword">for</span> (XNode child : context.getChildren()) &#123;      String id = child.getStringAttribute(<span class="hljs-string">"id"</span>);      <span class="hljs-comment">// environment是否和默认配置的一致</span>      <span class="hljs-keyword">if</span> (isSpecifiedEnvironment(id)) &#123;        <span class="hljs-comment">// 创建事务管理器，即上面的JDBC事务管理器</span>        TransactionFactory txFactory = transactionManagerElement(child.evalNode(<span class="hljs-string">"transactionManager"</span>));        <span class="hljs-comment">// 创建数据源工厂</span>        DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class="hljs-string">"dataSource"</span>));        <span class="hljs-comment">// 并获取到数据源</span>        DataSource dataSource = dsFactory.getDataSource();        <span class="hljs-comment">// 构建Environment</span>        Environment.Builder environmentBuilder = <span class="hljs-keyword">new</span> Environment.Builder(id)          .transactionFactory(txFactory)          .dataSource(dataSource);        <span class="hljs-comment">// 赋值给configuration对象</span>        configuration.setEnvironment(environmentBuilder.build());      &#125;    &#125;  &#125;&#125;</code></pre><p>从代码可以看出，Mybatis获取环境变量后创建了两个核心对象：1、TransactionFactory。2、DataSource，其对应的方法是</p><p><code>transactionManagerElement()</code>， <code>dataSourceElement()</code>两个方法。底层实现都是通过反射进行实例化。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164602.png" srcset="/img/loading.gif" alt="image-20200430142709538"></p><p>我们以<code>PooledDataSourceFactory</code>子类为例。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164552.png" srcset="/img/loading.gif" alt="image-20200430142750298"></p><p>至此Mybatis的第一阶段配置文件的解析到此结束，这里还有Mapper文件的解析（下面讲解）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>解析出来的<code>Properties</code>配置，最终被赋值到了<code>Configuration</code>中的<code>variables</code>对象中。</li><li>解析出来的<code>typeAliases</code>配置，最终放入了<code>Configuration</code>中的<code>typeAliasRegistry</code>对象中。</li><li>解析出来的<code>Plugins</code>配置，最终放入了Configuration中的<code>interceptorChain</code>对象中。</li><li>解析出来的<code>environments</code>配置，用于<code>创建了数据源和事务工厂</code>。最终构建<code>Environment</code>对象赋值给Configuration中。</li></ul><p>从上面处理流程可以看出Configuration非常的重要，几乎所有的配置最终都会汇聚到Configuration对象中。</p><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><pre><code class="hljs txt">&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream) -&gt; Mybatis构建入口   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration -&gt; 解析configuration标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#propertiesElement -&gt; 解析properties标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#settingsAsProperties -&gt; 解析settings标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#typeAliasesElement -&gt; 解析typeAliases标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#pluginElement -&gt; 解析plugins标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#environmentsElement -&gt; 解析environments标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement -&gt; 解析mappers标签配置</code></pre><h2 id="Mapper文件加载解析阶段"><a href="#Mapper文件加载解析阶段" class="headerlink" title="Mapper文件加载解析阶段"></a>Mapper文件加载解析阶段</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在这个阶段我们将深入了解Mybatis是如何解析Mapper文件。如何绑定Mapper接口和文件的关系。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>在进入分析之前我们先思考几个问题：</p><p>1、Mybatis是如何<code>Select，Insert，Delete，Update</code>标签的？</p><p>2、Mybatis是如何处理<code>Include</code>标签的？</p><p>3、Mybatis是如何处理动态SQL标签（<code>set，foreach，if</code>）？</p><p>4、Mybatis是如何处理<code>resultMap</code>标签的？</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>在上个阶段的最后一行方法：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164546.png" srcset="/img/loading.gif" alt="image-20200430144550431"></p><p>红圈内的方法就是解析Mapper文件流程的入口方法。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164537.png" srcset="/img/loading.gif" alt="image-20200430151542891"></p><p>从图中可以看出解析Mapper文件有两种方式：</p><ol><li><p>使用Package标签扫描整个包下的Mapper接完成注册。</p></li><li><p>使用Mapper标签配置单个Mapper。</p><ol><li>Mapper标签支持三种方式 ：<code>resource（路径），url（网络），class（class类）</code>来加载Mapper。</li></ol></li></ol><h3 id="使用Package解析"><a href="#使用Package解析" class="headerlink" title="使用Package解析"></a>使用<code>Package</code>解析</h3><p>进入 <code>configuration.addMappers(mapperPackage)</code>方法，源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addMappers</span><span class="hljs-params">(String packageName)</span> </span>&#123;  mapperRegistry.addMappers(packageName);&#125;</code></pre><p>从<code>mapperRegistry</code>对象的命名可以看出，该对象主要是负责注册Mapper的。</p><p>进入<code>addMappers</code>方法：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164530.png" srcset="/img/loading.gif" alt="image-20200430163542757"  /><p>代码会获取到包下所有Mapper对应的Class信息，并进行遍历调用 <code>addMapper</code>方法。</p><p>我们可以看出Mapper解析是在MapperRegistry类中完成的，那么MapperRegistry是如何存储注册的Mapper的，来看看其类结构图：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164524.png" srcset="/img/loading.gif" alt="image-20200430163959992"></p><p><code>knownMappers</code>充当了一个重要的角色，它存储了注册过的Mapper。而<code>MapperProxyFactory</code>对象则用于创建MapperProxy对象，此对象会对Mapper进行代理。</p><p>接着进入<code>addMapper</code>方法查看添加细节。</p><h4 id="执行MapperRegistry-addMapper添加Mapper"><a href="#执行MapperRegistry-addMapper添加Mapper" class="headerlink" title="执行MapperRegistry.addMapper添加Mapper"></a>执行<code>MapperRegistry.addMapper</code>添加<code>Mapper</code></h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;  <span class="hljs-keyword">if</span> (type.isInterface()) &#123;<span class="hljs-comment">// 接口才处理</span>    <span class="hljs-keyword">if</span> (hasMapper(type)) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"此Mapper已经存在"</span>);    &#125;    <span class="hljs-keyword">boolean</span> loadCompleted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">try</span> &#123;      knownMappers.put(type, <span class="hljs-keyword">new</span> MapperProxyFactory&lt;&gt;(type));      <span class="hljs-comment">// 创建MapperAnnotationBuilder构建起</span>      MapperAnnotationBuilder parser = <span class="hljs-keyword">new</span> MapperAnnotationBuilder(config, type);      <span class="hljs-comment">// 构建Mapper</span>      parser.parse();      loadCompleted = <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;&#125;  &#125;&#125;</code></pre><p>该方法主要做了以下几个操作：</p><ul><li>将Mapper对应的Class对象放入knownMappers对象中。</li><li>创建MapperAnnotationBuilder构建器构建Mapper。</li></ul><h4 id="执行MapperAnnotationBuilder-parse解析Mapper"><a href="#执行MapperAnnotationBuilder-parse解析Mapper" class="headerlink" title="执行MapperAnnotationBuilder.parse解析Mapper"></a>执行<code>MapperAnnotationBuilder.parse</code>解析<code>Mapper</code></h4><p>源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;  String resource = type.toString();  <span class="hljs-keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;<span class="hljs-comment">// 判断当前资源是否加载过</span>    <span class="hljs-comment">// 步骤①</span>    loadXmlResource();    configuration.addLoadedResource(resource);<span class="hljs-comment">// 添加到Configuration对象中，标识已经加载过</span>    assistant.setCurrentNamespace(type.getName());    parseCache();    parseCacheRef();    <span class="hljs-keyword">for</span> (Method method : type.getMethods()) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (!method.isBridge()) &#123;          <span class="hljs-comment">// 步骤②</span>          parseStatement(method);        &#125;      &#125; <span class="hljs-keyword">catch</span> (IncompleteElementException e) &#123;&#125;    &#125;  &#125;  parsePendingMethods();&#125;</code></pre><p>代码中我们看到了最为重要的两个方法：<code>loadXmlResource()：</code>用于加载Mapper对应的Xml文件，<code>parseStatement()</code>：解析Mapper方法中的注解信息。</p><p>解析过的<code>resource</code>最终会添加到Configuration中的<code>loadedResources</code>（Set类型）对象中。</p><h5 id="loadXmlResource"><a href="#loadXmlResource" class="headerlink" title="loadXmlResource"></a><code>loadXmlResource</code></h5><p>从上面可以得知该方法主要用于解析Mapper对应的xml文件。源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadXmlResource</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (!configuration.isResourceLoaded(<span class="hljs-string">"namespace:"</span> + type.getName())) &#123;    <span class="hljs-comment">// 将全类名中的.替换成/,以方便下面Resources获取输入流</span>    <span class="hljs-comment">// io.better.mybatis.mapper.UserMapper -&gt; io/better/mybatis/mapper/UserMapper.xml</span>    String xmlResource = type.getName().replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>) + <span class="hljs-string">".xml"</span>;    <span class="hljs-comment">// 获取到Mapper对应的Xml文件输入流</span>    InputStream inputStream = type.getResourceAsStream(<span class="hljs-string">"/"</span> + xmlResource);    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-keyword">null</span>) &#123;        inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);    &#125;    <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 步骤①</span>      XMLMapperBuilder xmlParser = <span class="hljs-keyword">new</span> XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());      <span class="hljs-comment">// 步骤②</span>      xmlParser.parse();    &#125;  &#125;&#125;</code></pre><p>从代码中可以看出，Mybatis通过替换<code>Mapper全路径</code>获取到<code>xml对应resource中的目录层级</code>，并获取到InputStream流。</p><p>举例：<code>io.better.mybatis.mapper.UserMapper -&gt; resource/io/better/mybatis/mapper/UserMapper.xml</code>。</p><p><strong>所以使用原生Mybatis需要注意xml放置的位置</strong>。</p><p>紧接着Mybatis创建了<code>XMLMapperBuilder</code>对象，调用其parse方法进一步的解析xml文件。</p><p>关于上面步骤①和步骤②的流程下面<code>Resource解析方式</code>会复用到，如果需要了解请直接跳转至Resource解析方法。</p><h5 id="parseStatement"><a href="#parseStatement" class="headerlink" title="parseStatement"></a><code>parseStatement</code></h5><p>新版Mybatis支持注解执行SQL语句，通过<code>@SELECT，@INSERT，@UPDATE，@DELETE</code>注解来执行SQL语句。此方法就是解析这些注解并生成<code>MappedStatement</code>对象。</p><p>源代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parseStatement</span><span class="hljs-params">(Method method)</span> </span>&#123;  <span class="hljs-comment">// 获取参数来类型</span>  Class&lt;?&gt; parameterTypeClass = getParameterType(method);  LanguageDriver languageDriver = getLanguageDriver(method);  <span class="hljs-comment">// 获取到注解中编写的SQL语句</span>  SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);  <span class="hljs-keyword">if</span> (sqlSource != <span class="hljs-keyword">null</span>) &#123;    Options options = method.getAnnotation(Options<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">// 生成statementId</span>    <span class="hljs-keyword">final</span> String mappedStatementId = type.getName() + <span class="hljs-string">"."</span> + method.getName();    Integer fetchSize = <span class="hljs-keyword">null</span>;    Integer timeout = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 默认为PreparedStatement类型</span>    StatementType statementType = StatementType.PREPARED;    ResultSetType resultSetType = configuration.getDefaultResultSetType();    <span class="hljs-comment">//  获取到SQL指令类型，新增? 更新? 查询? 删除?</span>    SqlCommandType sqlCommandType = getSqlCommandType(method);    <span class="hljs-keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;    <span class="hljs-keyword">boolean</span> flushCache = !isSelect;    <span class="hljs-keyword">boolean</span> useCache = isSelect;<span class="hljs-comment">// 获取主键生成器</span>    KeyGenerator keyGenerator;    String keyProperty = <span class="hljs-keyword">null</span>;    String keyColumn = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">if</span> (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) &#123;      <span class="hljs-comment">// first check for SelectKey annotation - that overrides everything else</span>      SelectKey selectKey = method.getAnnotation(SelectKey<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-keyword">if</span> (selectKey != <span class="hljs-keyword">null</span>) &#123;        keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);        keyProperty = selectKey.keyProperty();      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options == <span class="hljs-keyword">null</span>) &#123;        keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;      &#125; <span class="hljs-keyword">else</span> &#123;        keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;        keyProperty = options.keyProperty();        keyColumn = options.keyColumn();      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      keyGenerator = NoKeyGenerator.INSTANCE;    &#125;    <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (FlushCachePolicy.TRUE.equals(options.flushCache())) &#123;        flushCache = <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (FlushCachePolicy.FALSE.equals(options.flushCache())) &#123;        flushCache = <span class="hljs-keyword">false</span>;      &#125;      useCache = options.useCache();      fetchSize = options.fetchSize() &gt; -<span class="hljs-number">1</span> || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : <span class="hljs-keyword">null</span>; <span class="hljs-comment">//issue #348</span>      timeout = options.timeout() &gt; -<span class="hljs-number">1</span> ? options.timeout() : <span class="hljs-keyword">null</span>;      statementType = options.statementType();      <span class="hljs-keyword">if</span> (options.resultSetType() != ResultSetType.DEFAULT) &#123;        resultSetType = options.resultSetType();      &#125;    &#125;    String resultMapId = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 获取ResultMap对象</span>    ResultMap resultMapAnnotation = method.getAnnotation(ResultMap<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">if</span> (resultMapAnnotation != <span class="hljs-keyword">null</span>) &#123;      resultMapId = String.join(<span class="hljs-string">","</span>, resultMapAnnotation.value());    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isSelect) &#123;      resultMapId = parseResultMap(method);    &#125;    <span class="hljs-comment">// 忽略参数</span>    <span class="hljs-comment">// 构建MappedStatement</span>    assistant.addMappedStatement();  &#125;&#125;</code></pre><p>方法内部创建的对象和Mapper标签几乎一致，并且这种方式代码阅读行较差，简单的SQL语句还行，但是复杂的不行。此处不做细致讲解。（后期可能补上）。</p><h3 id="使用Mapper标签解析"><a href="#使用Mapper标签解析" class="headerlink" title="使用Mapper标签解析"></a>使用<code>Mapper</code>标签解析</h3><p>入口：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164159.png" srcset="/img/loading.gif" alt="image-20200430183533866"></p><p>可以看出一共有三种方式，分别是<code>resource，url，class</code> 。前两种最终都创建了XMLMapperBuilder对象，而最后一种和Package解析方式类似。</p><p>我们重点关注<code>XMLMapperBuilder</code>这个对象。到这里与Package解析中的<code>loadXmlResource</code>方法处理一致。</p><h4 id="执行XMLMapperBuilder-parse"><a href="#执行XMLMapperBuilder-parse" class="headerlink" title="执行XMLMapperBuilder.parse"></a>执行<code>XMLMapperBuilder.parse</code></h4><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501112922.png" srcset="/img/loading.gif" alt="image-20200501112922353" style="zoom:50%;" /><p>重点关注两个方法，分别是：<code>configurationElement：</code>用于解析XML中各个标签，<code>bindMapperForNamespace：</code>将Mapper接口绑定到Configuration上。</p><h4 id="执行XMLMapperBuilder-configurationElement"><a href="#执行XMLMapperBuilder-configurationElement" class="headerlink" title="执行XMLMapperBuilder.configurationElement"></a>执行<code>XMLMapperBuilder.configurationElement</code></h4><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501113148.png" srcset="/img/loading.gif" alt="image-20200501113147828"></p><p>红圈中我们能够看到Mybatis对XML中的各个标签都进行了处理。</p><ul><li><pre><code>parameterMapElement -&gt; 处理parameterMap标签。<pre><code class="hljs diff"><span class="hljs-deletion">-</span></code></pre>resultMapElements -&gt; 处理resultMap标签<pre><code class="hljs diff"><span class="hljs-deletion">-</span></code></pre>sqlElement -&gt; 处理sql标签<pre><code class="hljs diff"><span class="hljs-deletion">-</span></code></pre>buildStatementFromContext -&gt; 处理Select，Insert，Delete，Update标签<pre><code class="hljs reasonml">接下来让我们逐个分析这些方法是如何处理标签的。#### 执行`bindMapperForNamespace`方法该方法主要作用是将解析后的XML和Mapper接口绑定到Configuration对象中。```java<span class="hljs-keyword">private</span> void bind<span class="hljs-constructor">MapperForNamespace()</span> &#123;  String namespace = builderAssistant.get<span class="hljs-constructor">CurrentNamespace()</span>;  <span class="hljs-keyword">if</span> (namespace != null) &#123;    Class&lt;?&gt; boundType = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Resources</span>.</span></span><span class="hljs-keyword">class</span><span class="hljs-constructor">ForName(<span class="hljs-params">namespace</span>)</span>;    <span class="hljs-keyword">if</span> (boundType != null) &#123;      <span class="hljs-keyword">if</span> (!configuration.has<span class="hljs-constructor">Mapper(<span class="hljs-params">boundType</span>)</span>) &#123;        <span class="hljs-comment">// 标识当前XML已经解析过</span>        configuration.add<span class="hljs-constructor">LoadedResource(<span class="hljs-string">"namespace:"</span> + <span class="hljs-params">namespace</span>)</span>;        <span class="hljs-comment">// 添加到Configuration中</span>        configuration.add<span class="hljs-constructor">Mapper(<span class="hljs-params">boundType</span>)</span>;      &#125;    &#125;  &#125;&#125;</code></pre></code></pre></li></ul><h4 id="解析ResultMap标签"><a href="#解析ResultMap标签" class="headerlink" title="解析ResultMap标签"></a>解析<code>ResultMap</code>标签</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ResultMap <span class="hljs-title">resultMapElement</span><span class="hljs-params">(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType)</span> </span>&#123;  String type = resultMapNode.getStringAttribute(<span class="hljs-string">"type"</span>); <span class="hljs-comment">// 这里删除了一些代码</span>  Class&lt;?&gt; typeClass = resolveClass(type);<span class="hljs-comment">// 解析type获取对应的Class对象</span>  <span class="hljs-keyword">if</span> (typeClass == <span class="hljs-keyword">null</span>) &#123;    typeClass = inheritEnclosingType(resultMapNode, enclosingType);  &#125;  Discriminator discriminator = <span class="hljs-keyword">null</span>;  List&lt;ResultMapping&gt; resultMappings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(additionalResultMappings);  List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();  <span class="hljs-keyword">for</span> (XNode resultChild : resultChildren) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-string">"constructor"</span>.equals(resultChild.getName())) &#123;      processConstructorElement(resultChild, typeClass, resultMappings);  <span class="hljs-comment">// 步骤④：处理constructor标签</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"discriminator"</span>.equals(resultChild.getName())) &#123;      <span class="hljs-comment">// 步骤③: 处理discriminator标签</span>      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 处理其他标签，例如：id，result标签</span>      List&lt;ResultFlag&gt; flags = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">if</span> (<span class="hljs-string">"id"</span>.equals(resultChild.getName())) &#123;        flags.add(ResultFlag.ID);      &#125;      <span class="hljs-comment">// 步骤①：调用buildResultMappingFromContext构建ResultMapping</span>      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));    &#125;  &#125;  <span class="hljs-comment">// 获取到标签中的id，extends，autoMapping属性</span>  String id = resultMapNode.getStringAttribute(<span class="hljs-string">"id"</span>,          resultMapNode.getValueBasedIdentifier());  String extend = resultMapNode.getStringAttribute(<span class="hljs-string">"extends"</span>);  Boolean autoMapping = resultMapNode.getBooleanAttribute(<span class="hljs-string">"autoMapping"</span>);  <span class="hljs-comment">// 初始化ResultMapResolver对象，用于解析生成ResultMap对象</span>  ResultMapResolver resultMapResolver = <span class="hljs-keyword">new</span> ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 步骤②： 执行解析</span>    <span class="hljs-keyword">return</span> resultMapResolver.resolve();  &#125; <span class="hljs-keyword">catch</span> (IncompleteElementException  e) &#123;  &#125;&#125;</code></pre><p>图中步骤③和步骤④最终都会 调用步骤①的方法，所以我们重点关注步骤①和步骤② 这两个方法。</p><h5 id="生成ResultMapping"><a href="#生成ResultMapping" class="headerlink" title="生成ResultMapping"></a>生成<code>ResultMapping</code></h5><p>进入<code>buildResultMappingFromContext</code>方法，源代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ResultMapping <span class="hljs-title">buildResultMappingFromContext</span><span class="hljs-params">(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags)</span> </span>&#123;  String property;  <span class="hljs-keyword">if</span> (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;    property = context.getStringAttribute(<span class="hljs-string">"name"</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    property = context.getStringAttribute(<span class="hljs-string">"property"</span>);  &#125;  String column = context.getStringAttribute(<span class="hljs-string">"column"</span>);  String javaType = context.getStringAttribute(<span class="hljs-string">"javaType"</span>);  String jdbcType = context.getStringAttribute(<span class="hljs-string">"jdbcType"</span>);  String nestedSelect = context.getStringAttribute(<span class="hljs-string">"select"</span>);  String nestedResultMap = context.getStringAttribute(<span class="hljs-string">"resultMap"</span>, () -&gt;    processNestedResultMappings(context, Collections.emptyList(), resultType));  String notNullColumn = context.getStringAttribute(<span class="hljs-string">"notNullColumn"</span>);  String columnPrefix = context.getStringAttribute(<span class="hljs-string">"columnPrefix"</span>);  String typeHandler = context.getStringAttribute(<span class="hljs-string">"typeHandler"</span>);  String resultSet = context.getStringAttribute(<span class="hljs-string">"resultSet"</span>);  String foreignColumn = context.getStringAttribute(<span class="hljs-string">"foreignColumn"</span>);  <span class="hljs-keyword">boolean</span> lazy = <span class="hljs-string">"lazy"</span>.equals(context.getStringAttribute(<span class="hljs-string">"fetchType"</span>, configuration.isLazyLoadingEnabled() ? <span class="hljs-string">"lazy"</span> : <span class="hljs-string">"eager"</span>));  Class&lt;?&gt; javaTypeClass = resolveClass(javaType);  Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler);  JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);  <span class="hljs-comment">// 最终调用buildResultMapping生成了ResultMapping对象</span>  <span class="hljs-keyword">return</span> builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);&#125;</code></pre><p>可以看出这个方法逻辑比较简单，将子节点中配置的属性获取出来，最终组装了ResultMapping对象。</p><h5 id="生成ResultMap"><a href="#生成ResultMap" class="headerlink" title="生成ResultMap"></a>生成<code>ResultMap</code></h5><p><code>org.apache.ibatis.builder.ResultMapResolver#resolve</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultMap <span class="hljs-title">resolve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 调用工具类的</span>  <span class="hljs-keyword">return</span> assistant.addResultMap(<span class="hljs-keyword">this</span>.id, <span class="hljs-keyword">this</span>.type, <span class="hljs-keyword">this</span>.extend, <span class="hljs-keyword">this</span>.discriminator, <span class="hljs-keyword">this</span>.resultMappings, <span class="hljs-keyword">this</span>.autoMapping);&#125;</code></pre><p><code>addResultMap</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultMap <span class="hljs-title">addResultMap</span><span class="hljs-params">(String id,Class&lt;?&gt; type,String extend,Discriminator discriminator,</span></span><span class="hljs-function"><span class="hljs-params">    List&lt;ResultMapping&gt; resultMappings,Boolean autoMapping)</span> </span>&#123;    id = applyCurrentNamespace(id, <span class="hljs-keyword">false</span>);  extend = applyCurrentNamespace(extend, <span class="hljs-keyword">true</span>);<span class="hljs-comment">// 如果当前resultMap存在父resultMap</span>  <span class="hljs-keyword">if</span> (extend != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// configuration是否已经加载过父resultMap</span>    <span class="hljs-keyword">if</span> (!configuration.hasResultMap(extend)) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncompleteElementException(<span class="hljs-string">"Could not find a parent resultmap with id '"</span> + extend + <span class="hljs-string">"'"</span>);    &#125;   <span class="hljs-comment">// 根据父resultMap的Id获取出父resultMap对象</span>    ResultMap resultMap = configuration.getResultMap(extend);    <span class="hljs-comment">// 去除父resultMap的resultMapping集合</span>    List&lt;ResultMapping&gt; extendedResultMappings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(resultMap.getResultMappings());    <span class="hljs-comment">// 去重</span>    extendedResultMappings.removeAll(resultMappings);    <span class="hljs-keyword">boolean</span> declaresConstructor = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 遍历当前resultMap的resultMapping，判断其是否包含Constructor</span>    <span class="hljs-keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;      <span class="hljs-keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;        declaresConstructor = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    <span class="hljs-comment">// 如果当前resultMap声明了Constructor标签，则删除父resultMap中声明的Constructor标签</span>    <span class="hljs-keyword">if</span> (declaresConstructor) &#123;      extendedResultMappings.removeIf(        resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR));    &#125;    <span class="hljs-comment">// 将父resultMap的resultMapping添加到当前resultMap的resultMapping集合中</span>    resultMappings.addAll(extendedResultMappings);  &#125;  <span class="hljs-comment">// 构建ResultMap对象</span>  ResultMap resultMap = <span class="hljs-keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)      .discriminator(discriminator).build();  <span class="hljs-comment">// 将构建好的ResultMap对象添加到Configuration中</span>  configuration.addResultMap(resultMap);  <span class="hljs-keyword">return</span> resultMap;&#125;</code></pre><p>因为resultMap标签可以继承其他的resultMap标签，而这个方法主要就是为了处理resultMap继承的问题。可以得出结论：<strong>XML中的<code>resultMap标签</code>最终会被解析成<code>ResultMap对象</code>并复制给了Configuration</strong>。</p><h4 id="解析SQL标签"><a href="#解析SQL标签" class="headerlink" title="解析SQL标签"></a>解析<code>SQL</code>标签</h4><p>resultMap标签解析完，继续看<code>sql标签</code>的解析过程：</p><p>方法入口：</p><pre><code class="hljs java">sqlElement(context.evalNodes(<span class="hljs-string">"/mapper/sql"</span>));</code></pre><p>获取到XML中所有的sql标签节点对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sqlElement</span><span class="hljs-params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;  <span class="hljs-keyword">for</span> (XNode context : list) &#123;    String databaseId = context.getStringAttribute(<span class="hljs-string">"databaseId"</span>);    <span class="hljs-comment">// 获取到sql标签的ID</span>    String id = context.getStringAttribute(<span class="hljs-string">"id"</span>);    <span class="hljs-comment">// 和namespace进行拼接</span>    id = builderAssistant.applyCurrentNamespace(id, <span class="hljs-keyword">false</span>);    <span class="hljs-comment">// 判断是否已经存在次sql标签</span>    <span class="hljs-keyword">if</span> (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;      <span class="hljs-comment">// 不存在，添加到sqlFragments中</span>      <span class="hljs-comment">// sqlFragments存在于configuration中</span>      sqlFragments.put(id, context);    &#125;  &#125;&#125;</code></pre><p>该方法功能很简单，就是将<code>sql标签的id和对应的XNode节点对象</code>放入到<code>sqlFragments</code>中。</p><p><code>sqlFragments</code>对象在后面解析<code>select|insert|update|delete</code>标签中的include标签时会使用到。</p><h4 id="解析Crud标签"><a href="#解析Crud标签" class="headerlink" title="解析Crud标签"></a>解析<code>Crud</code>标签</h4><p>方法入口 ：</p><pre><code class="hljs java">buildStatementFromContext(context.evalNodes(<span class="hljs-string">"select|insert|update|delete"</span>));</code></pre><p>获取的所有的CRUD标签。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildStatementFromContext</span><span class="hljs-params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;  <span class="hljs-comment">// 获取到所有的select，insert，delete，update标签节点</span>  <span class="hljs-keyword">for</span> (XNode context : list) &#123;    <span class="hljs-comment">// 为每一个crud标签创建XMLStatementBuilder对象，用于构建每个标签所对应的MapperStatement对象</span>    <span class="hljs-keyword">final</span> XMLStatementBuilder statementParser = <span class="hljs-keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);    <span class="hljs-comment">// 解析并生成MapperStatement对象</span>    statementParser.parseStatementNode();  &#125; <span class="hljs-comment">// 忽略了异常处理</span>&#125;</code></pre><p>该方法对获取到的<code>insert，select，update，delete</code>节点进行了遍历，并实例化了<code>XMLStatementBuilder</code>构建器来构建<code>MapperdStatement</code>。</p><p><code>XMLStatementBuilder</code>会将每个<code>crud标签</code>构建成一个<code>MapperdStatement对象</code>。它两是一对一的关系，后面调用方法执行SQL时就会获取到方法对应的MapperdStatement对象。</p><p>进入<code>parseStatementNode</code>方法：</p><p>重点关注标记的步骤</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseStatementNode</span><span class="hljs-params">()</span> </span>&#123;  String id = context.getStringAttribute(<span class="hljs-string">"id"</span>);  String databaseId = context.getStringAttribute(<span class="hljs-string">"databaseId"</span>);  <span class="hljs-keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="hljs-keyword">this</span>.requiredDatabaseId)) &#123;    <span class="hljs-keyword">return</span>;  &#125;  String nodeName = context.getNode().getNodeName();  SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));  <span class="hljs-keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;  <span class="hljs-keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="hljs-string">"flushCache"</span>, !isSelect);  <span class="hljs-keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="hljs-string">"useCache"</span>, isSelect);  <span class="hljs-keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="hljs-string">"resultOrdered"</span>, <span class="hljs-keyword">false</span>);  <span class="hljs-comment">// 步骤①</span>  XMLIncludeTransformer includeParser = <span class="hljs-keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);  includeParser.applyIncludes(context.getNode());  String parameterType = context.getStringAttribute(<span class="hljs-string">"parameterType"</span>);  Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);  String lang = context.getStringAttribute(<span class="hljs-string">"lang"</span>);  LanguageDriver langDriver = getLanguageDriver(lang);  <span class="hljs-comment">// 步骤②</span>  processSelectKeyNodes(id, parameterTypeClass, langDriver);  <span class="hljs-comment">// </span>  KeyGenerator keyGenerator;  String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;  keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="hljs-keyword">true</span>);  <span class="hljs-keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;    keyGenerator = configuration.getKeyGenerator(keyStatementId);  &#125; <span class="hljs-keyword">else</span> &#123;    keyGenerator = context.getBooleanAttribute(<span class="hljs-string">"useGeneratedKeys"</span>,        configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))        ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;  &#125;<span class="hljs-comment">// 步骤③</span>  SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);  StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="hljs-string">"statementType"</span>, StatementType.PREPARED.toString()));  Integer fetchSize = context.getIntAttribute(<span class="hljs-string">"fetchSize"</span>);  Integer timeout = context.getIntAttribute(<span class="hljs-string">"timeout"</span>);  String parameterMap = context.getStringAttribute(<span class="hljs-string">"parameterMap"</span>);  String resultType = context.getStringAttribute(<span class="hljs-string">"resultType"</span>);  Class&lt;?&gt; resultTypeClass = resolveClass(resultType);  String resultMap = context.getStringAttribute(<span class="hljs-string">"resultMap"</span>);  String resultSetType = context.getStringAttribute(<span class="hljs-string">"resultSetType"</span>);  ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);  <span class="hljs-keyword">if</span> (resultSetTypeEnum == <span class="hljs-keyword">null</span>) &#123;    resultSetTypeEnum = configuration.getDefaultResultSetType();  &#125;  String keyProperty = context.getStringAttribute(<span class="hljs-string">"keyProperty"</span>);  String keyColumn = context.getStringAttribute(<span class="hljs-string">"keyColumn"</span>);  String resultSets = context.getStringAttribute(<span class="hljs-string">"resultSets"</span>);  <span class="hljs-comment">// 步骤④</span>  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,      resultSetTypeEnum, flushCache, useCache, resultOrdered,      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);&#125;</code></pre><p>这段代码很长，无需全部阅读，只需查看标记的核心步骤即可。</p><ul><li>步骤①：处理curd标签中的的Include标签。</li><li>步骤②：处理insert标签中的selectKey标签。</li><li>步骤③：处理curd标签中的动态标签 。</li><li>步骤④：将使用最终的crud标签生成MappedStatement对象。</li></ul><h5 id="处理Include标签"><a href="#处理Include标签" class="headerlink" title="处理Include标签"></a>处理<code>Include</code>标签</h5><p>在分析<code>XMLIncludeTransformer.applyIncludes</code>方法前，我们先来看几个问题，以便我们更好的理解Mybatis对 <code>&lt;include/&gt;</code>的处理逻辑：</p><ul><li>Mybatis是如何拆分含有<code>&lt;include/&gt;</code>标签的SQL？拆分各部分SQL关系如何维护？</li><li>Mybatis是如何处理嵌套<code>&lt;include/&gt;</code>标签？</li></ul><p>带着这两个问题，我们进入<code>applyIncludes</code>方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyIncludes</span><span class="hljs-params">(Node source, <span class="hljs-keyword">final</span> Properties variablesContext, <span class="hljs-keyword">boolean</span> included)</span> </span>&#123;<span class="hljs-comment">//  步骤②</span>  <span class="hljs-keyword">if</span> (source.getNodeName().equals(<span class="hljs-string">"include"</span>)) &#123;    <span class="hljs-comment">// 步骤⑤ 从sqlFragments中获取include所引用的id，即sql标签中编写的SQL语句。</span>    Node toInclude = findSqlFragment(getStringAttribute(source, <span class="hljs-string">"refid"</span>), variablesContext);    Properties toIncludeContext = getVariablesContext(source, variablesContext);    <span class="hljs-comment">// 步骤⑥ 递归，处理toInclude中嵌套的include标签</span>    applyIncludes(toInclude, toIncludeContext, <span class="hljs-keyword">true</span>);    <span class="hljs-comment">// 如果（toInclude节点）和 source（引入toInclude节点）不在同一个document下</span>    <span class="hljs-keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;      <span class="hljs-comment">// 将（toInclude节点）导入到 source 节点中去</span>      toInclude = source.getOwnerDocument().importNode(toInclude, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">// 步骤⑦ 将 source 节点替换成（toInclude节点）</span>    source.getParentNode().replaceChild(toInclude, source);    <span class="hljs-comment">// 为了方便阅读对源代码进行了修改</span>    Node toIncludeParentNode = toInclude.getParentNode()；    <span class="hljs-comment">// （toInclude节点）含有子节点，可能是嵌套的include标签</span>    <span class="hljs-keyword">while</span> (toInclude.hasChildNodes()) &#123;      <span class="hljs-comment">// 将（toInclude节点）下的子节点添加到父节点的集合中，并在（toInclude节点）前面</span>      toIncludeParentNode.insertBefore(toInclude.getFirstChild(), toInclude);    &#125;    <span class="hljs-comment">// 步骤⑧ 从父节点中删除（toInclude节点）</span>    toIncludeParentNode.removeChild(toInclude);  &#125;   <span class="hljs-comment">// 步骤①</span>  <span class="hljs-comment">// source对象为DeferredElementImpl类型，即include，select，insert，update，delete等标签</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) &#123;    <span class="hljs-comment">// 步骤③</span>    NodeList children = source.getChildNodes();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.getLength(); i++) &#123;      <span class="hljs-comment">// 步骤④</span>      applyIncludes(children.item(i), variablesContext, included);    &#125;  &#125;   <span class="hljs-comment">// source对象为DeferredTextImpl类型，</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (included &amp;&amp; (source.getNodeType() == Node.TEXT_NODE || source.getNodeType() == Node.CDATA_SECTION_NODE) &amp;&amp; !variablesContext.isEmpty()) &#123;    <span class="hljs-comment">// 步骤⑨ 最终替换对象里的data属性</span>    source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));  &#125;&#125;</code></pre><p>这段代码大量使用了递归调用，来处理嵌套标签。</p><p>执行流程：</p><ul><li>判断节点类型是否为元素节点<ul><li>是 <code>--&gt; 步骤①</code><ul><li>获取到子节点，根据<code>include</code>标签进行拆分。<code>--&gt; 步骤③</code></li><li>遍历子节点，递归处理子节点。 <code>--&gt; 步骤④</code></li></ul></li><li>否 <code>--&gt; 步骤②</code>  <ul><li>从<code>sqlFragments</code>中获取到引入SQL节点。 <code>--&gt;步骤⑤</code></li><li>递归处理引入的SQL节点，防止引入的SQL中存在嵌套的Include节点。 <code>--&gt; 步骤⑥</code></li><li>逐层将<code>include标签</code>替换成<code>include中实际的SQL</code>。 <code>--&gt;步骤⑦</code> </li><li>最终删除<code>include标签</code>。 <code>--&gt; 步骤⑧</code></li></ul></li></ul></li><li>直接设置节点值 <code>--&gt;步骤⑨</code></li></ul><p>讲述了大致流程，这里会有一个小疑问，Mybatis到底是如何获取子节点的？是如何拆分的？为了更好的理解这个问题， 引入一张<code>select标签</code>引入<code>&lt;include/&gt;</code>标签的XML解析Debug图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164132.png" srcset="/img/loading.gif" alt="include解析" style="zoom:50%;" /><p>从上图画红圈的地方可以，整个<code>select</code>语句被拆分成了三个部分，每个对象中都有：</p><ul><li><code>select</code> 一行产生了一个<code>DeferredTextImpl</code>类型的 对象，简称对象A。</li><li><code>include</code>一行产生了一个<code>DeferredElementImpl</code>类型的对象，简称对象B。</li><li><code>form</code> 和<code>where</code>两行产生了一个<code>DeferredTextImpl</code>类型的对象，简称对象C。</li></ul><p>每个对象中都含有以下三个属性：</p><ul><li><p><code>data</code>标识了当前对象所对应的<code>sql</code>语句内容。</p></li><li><p><code>previousSibling</code>标识了当前对象的前一个对象。</p></li><li><p><code>nextSibling</code>标识来当前对象的下一个对象 。</p></li></ul><p>三个对象前后之前的关系：</p><pre><code class="hljs tex">对象A.previousSibling -&gt; 对象C对象B.previousSibling -&gt; 对象A对象C.previousSibling -&gt; 对象B</code></pre><p><strong>这里我们可以看出Mybatis使用了类似  <code>双向链表</code> 的结构来管理标签被拆分后形成的对象。</strong></p><p><strong>这里有一个疑问，为什么<code>select</code>被拆分成了一行，而<code>from</code>和<code>where</code>为什么没被拆分成两行，而是拆分成了一行 ？</strong></p><p>为了验证这个问题，将<code>&lt;include/&gt;</code>替换掉，生成的对象属性如下图。未引入Include的XML解析Debug图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164004.png" srcset="/img/loading.gif" style="zoom:50%;" /><p><strong>这里可以得出的结论就是：Mybatis会以<code>&lt;include/&gt;</code>标签为分割线进行SQL语句的切分。</strong></p><p>步骤②处理SelectKey标签代码不做分析，感兴趣的可以自行查看源代码。</p><h5 id="处理dynamic标签"><a href="#处理dynamic标签" class="headerlink" title="处理dynamic标签"></a>处理<code>dynamic</code>标签</h5><p>在进入<code>langDriver.createSqlSource</code>方法前我们先来思考两个问题？</p><ul><li>Mybatis是如何区分动态SQL和静态SQL？</li><li>Mybatis是如何处理包含动态标签的SQL？</li></ul><p>带着这两个问题我们继续分析：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title">createSqlSource</span><span class="hljs-params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;  <span class="hljs-comment">// 创建XMLScriptBuilder构建起</span>  XMLScriptBuilder builder = <span class="hljs-keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);  <span class="hljs-comment">// 构建script节点</span>  <span class="hljs-keyword">return</span> builder.parseScriptNode();&#125;</code></pre><p>我们可以看出Mybatis创建了<code>XMLScriptBuilder</code>构建器来构建<code>动态标签</code>。我们先来看看XMLScriptBuilder类结构：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501154915.png" srcset="/img/loading.gif" alt="image-20200501154915783" style="zoom:50%;" /><p>从类结构图可以看出有8个处理动态标签的处理类，使用<code>isDynamic()</code>判断是否为动态标签 ，使用<code>nodeHandlerMap</code>来存储动态标签处理器。</p><p>让我进入<code>parseScriptNode</code>方法一探究竟：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title">parseScriptNode</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 解析动态标签</span>  MixedSqlNode rootSqlNode = parseDynamicTags(context);  SqlSource sqlSource;  <span class="hljs-keyword">if</span> (isDynamic) &#123;    <span class="hljs-comment">// 动态SQL源</span>    sqlSource = <span class="hljs-keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 静态SQL源</span>    sqlSource = <span class="hljs-keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);  &#125;  <span class="hljs-keyword">return</span> sqlSource;&#125;</code></pre><p>从代码中可以看出Mybatis为动态SQL创建了<code>DynamicSqlSource</code>子类，为静态SQL创建了<code>RawSqlSource</code>子类。到这里我们的第一个问题就比较清晰了，<strong>Mybatis使用了不同的SqlSource子类来区分动态SQL和静态SQL</strong>。</p><p>进入<code>parseDynamicTags</code>方法，查看解析动态标签的具体方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> MixedSqlNode <span class="hljs-title">parseDynamicTags</span><span class="hljs-params">(XNode node)</span> </span>&#123;  List&lt;SqlNode&gt; contents = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">// 步骤①</span>  NodeList children = node.getNode().getChildNodes();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.getLength(); i++) &#123;    XNode child = node.newXNode(children.item(i));    <span class="hljs-comment">// 步骤②</span>    <span class="hljs-keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;      <span class="hljs-comment">// 步骤③</span>      String data = child.getStringBody(<span class="hljs-string">""</span>);      TextSqlNode textSqlNode = <span class="hljs-keyword">new</span> TextSqlNode(data);      <span class="hljs-keyword">if</span> (textSqlNode.isDynamic()) &#123;        contents.add(textSqlNode);        isDynamic = <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 步骤③</span>        contents.add(<span class="hljs-keyword">new</span> StaticTextSqlNode(data));      &#125;    &#125;     <span class="hljs-comment">// 步骤④</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="hljs-number">8</span>      String nodeName = child.getNode().getNodeName();      <span class="hljs-comment">// 步骤⑤</span>      NodeHandler handler = nodeHandlerMap.get(nodeName);      <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Unknown element &lt;"</span> + nodeName + <span class="hljs-string">"&gt; in SQL statement."</span>);      &#125;      <span class="hljs-comment">// 步骤⑤</span>      handler.handleNode(child, contents);      isDynamic = <span class="hljs-keyword">true</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MixedSqlNode(contents);&#125;</code></pre><p>配合着源代码梳理一下执行流程，以便更好的理解Mybatis处理逻辑：</p><ul><li>获取到<code>crud标签</code>下所有的<code>子节点</code>，并进行遍历 –&gt; 步骤①</li><li>判断子节点的类型是否是元素节点（即动态标签节点）<ul><li>是 –&gt; <code>动态标签</code> <code>--&gt; 步骤④</code><ul><li>根据动态标签名称从nodeHandlerMap获取出对应的处理器  <code>--&gt; 步骤⑤</code></li><li>调用处理器的handleNode方法处理  <code>--&gt; 步骤⑤</code></li></ul></li><li>否 –&gt; <code>txt文本类型的普通SQL语句</code><ul><li>获取到节点中的<code>Body</code>即SQL语句，创建<code>StaticTextSqlNode</code>对象包装 <code>--&gt; 步骤③</code></li></ul></li></ul></li></ul><p>从上面的类图我们已经知道<code>各自动态标签都对应各自的Handle</code>，那Handle是如何添加到<code>nodeHandlerMap</code>中的呢？</p><p>答案就在<code>XMLScriptBuilder</code>的构造方法中 。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501161032.png" srcset="/img/loading.gif" alt="image-20200501161032311"></p><p>接着我们来看看各个Handle对各自标签的处理过程，我们以<code>TrimHandler</code>为准，进入<code>handleNode</code>方法一探究竟：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleNode</span><span class="hljs-params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;  <span class="hljs-comment">// 递归处理当前动态标签里包含的其他动态标签，即嵌套动态标签。</span>  MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);  String prefix = nodeToHandle.getStringAttribute(<span class="hljs-string">"prefix"</span>);  String prefixOverrides = nodeToHandle.getStringAttribute(<span class="hljs-string">"prefixOverrides"</span>);  String suffix = nodeToHandle.getStringAttribute(<span class="hljs-string">"suffix"</span>);  String suffixOverrides = nodeToHandle.getStringAttribute(<span class="hljs-string">"suffixOverrides"</span>);  <span class="hljs-comment">// 构建TrimSqlNode对象</span>  TrimSqlNode trim = <span class="hljs-keyword">new</span> TrimSqlNode(configuration, mixedSqlNode, prefix, prefixOverrides, suffix, suffixOverrides); <span class="hljs-comment">// 添加到集合中</span>  targetContents.add(trim);&#125;</code></pre><p>上诉代码将<code>&lt;trim/&gt;</code>签配置的属性都读取出来，并最终生成了一个<code>TrimSqlNode</code>对象。<strong>这里我们可以猜测：是不是每一个标签都会对应拥有一个<code>SqlNode</code>呢？</strong></p><p>是的你没猜错，Mybatis为每种动态标签都生成了对应的SqlNode。下面为SqlNode的继承图 ：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501163950.png" srcset="/img/loading.gif" alt="image-20200424174851998" style="zoom:50%;" /><p><strong>到这里，我们上述的第二个问题就非常清晰了：</strong></p><p><strong>Mybatis使用不同的<code>NodeHandler</code>来处理不同的动态标签，使用不同的<code>SqlNode</code>来接收不同动态标签的配置。</strong></p><p>到此SQL解析完成了吗？其实并没有，Mybatis对静态SQL做了进一步的操作，替换<code>#{}</code>为<code>?</code>。我们知道Mybatis会为静态SQL创建<code>RawSqlSource</code>对象。而这个替换操作就是在这里面发生的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RawSqlSource</span><span class="hljs-params">(Configuration configuration, String sql, Class&lt;?&gt; parameterType)</span> </span>&#123;  SqlSourceBuilder sqlSourceParser = <span class="hljs-keyword">new</span> SqlSourceBuilder(configuration);  Class&lt;?&gt; clazz = parameterType == null ? Object.class : parameterType;  <span class="hljs-comment">// 解析SqlSource</span>  sqlSource = sqlSourceParser.parse(sql, clazz, <span class="hljs-keyword">new</span> HashMap&lt;&gt;());&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title">parse</span><span class="hljs-params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;  ParameterMappingTokenHandler handler = <span class="hljs-keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);  <span class="hljs-comment">// 将 #&#123;&#125; 替换成 ?</span>  GenericTokenParser parser = <span class="hljs-keyword">new</span> GenericTokenParser(<span class="hljs-string">"#&#123;"</span>, <span class="hljs-string">"&#125;"</span>, handler);  String sql = parser.parse(originalSql);  <span class="hljs-comment">// 最后创建StaticSqlSource的sqlSource</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());&#125;</code></pre><p>至此步骤 ③执行完成，动态SQL和静态SQL解析完成。</p><h4 id="构建MappedStatement"><a href="#构建MappedStatement" class="headerlink" title="构建MappedStatement"></a>构建<code>MappedStatement</code></h4><p>一切准备工作都已完成，到了最后步骤④，在这个步骤中会将前面几个步骤产生的结果组装到一个叫MappedStatement对象中。</p><p>最终将这个对象添加到Configuration中，可自行查看。</p><pre><code class="hljs java">builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,    fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,    resultSetTypeEnum, flushCache, useCache, resultOrdered,    keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</code></pre><p>此致Mybatis整个启动加载的过程分析完毕。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在这个阶段我们清楚的认知了Mybatis对Mapper解析的过程，使用了<code>XMLStatementBuilder</code>来解析Mapper中的标签，<code>XMLScriptBuilder</code>来解析Mapper中的动态标签。</p><p>使用<code>ResultMapResolver</code>来解析<code>ResultMap</code>标签，并将其每一个子节点映射成了<code>ResultMapping</code>对象。</p><p>使用不同的<code>NodeHandler</code>来处理不同的动态标签，为不同动态标签创建不同的<code>SqlNode</code>对象。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Orm</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reflection-反射</title>
    <link href="/2020/05/06/java/Java-Reflection/"/>
    <url>/2020/05/06/java/Java-Reflection/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述Java中Reflection反射相关的API使用，以及一些常见问题。</p><a id="more"></a><h1 id="Jdk-Reflection"><a href="#Jdk-Reflection" class="headerlink" title="Jdk-Reflection"></a>Jdk-Reflection</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>Class的实例表示正在运行的Java应用程序的类和接口</code>。 枚举是一种类和注释是一种接口。</p><p>每个数组都属于一个被映射成Class对象的类，该对象由具有相同元素类型和大小的所有数组共享。 </p><p>原始类型<code>(boolean， byte， char， short， int， long， float，double)</code>，以及关键字<code>void</code>也表示为Class对象。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><strong>Class没有公共构造函数。 相反， Class对象由Java虚拟机的类加载并通过调用自动构造defineClass的类加载器方法</strong>。</p><h3 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h3><p>获取Class对象的方式一共有三种：通过<code>Class.forName(&quot;全路径包名&quot;)，类.class，类实例.getClass()</code>。</p><p>示例代码：</p><pre><code class="hljs java">Class&lt;?&gt; stringClass = Class.forName(<span class="hljs-string">"java.lang.String"</span>);Class&lt;?&gt; integerClass = String<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;Class&lt;?&gt; stringObjClass = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>).getClass();System.out.println(stringClass == integerClass);System.out.println(stringObjClass == integerClass);</code></pre><p>输出结果：</p><pre><code class="hljs txt">truetrue</code></pre><p>输出的结果证实了相同元素类型的Class实例是相同且共享的。</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>在这个阶段会讲述Class类中常用方法的使用</p><p><code>ReflectionBean</code>类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectionBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassBean</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> Integer age;  String phone;  <span class="hljs-keyword">protected</span> String address;  <span class="hljs-keyword">public</span> Boolean sex;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflection</span><span class="hljs-params">()</span> </span>&#123;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflection</span><span class="hljs-params">(String name)</span> </span>&#123;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validInfo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> name != <span class="hljs-keyword">null</span> &amp;&amp; name.length() &gt; <span class="hljs-number">0</span> &amp;&amp; Objects.nonNull(age);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">(@NotNull String name)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">()</span> </span>&#123;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReflectionBean <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReflectionBean();  &#125;&#125;</code></pre><p><code>ClassBean</code>类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassBean</span> </span>&#123;    <span class="hljs-keyword">private</span> String className;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validClassName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> className != <span class="hljs-keyword">null</span> &amp;&amp; className.length() &gt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassBean</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassBean</span><span class="hljs-params">(String className)</span> </span>&#123;        <span class="hljs-keyword">this</span>.className = className;    &#125;&#125;</code></pre><h4 id="Construtor"><a href="#Construtor" class="headerlink" title="Construtor"></a><code>Construtor</code></h4><p>一个<code>Constructor</code>对应着类中的一个构造函数，可以使用<code>Class.getConstructors()</code>获取指定类所有的构造函数(私有无法获取)。也可以使用<code>Class.getConstructor(Class&lt;?&gt; ... paramType)</code>获取指定参数的构造方法。</p><p>测试代码：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    Constructor&lt;ReflectionBean&gt; specificConstructor = reflectionBeanClass.getConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(specificConstructor.getName());    System.out.println(Arrays.toString(specificConstructor.getParameterAnnotations()));    System.out.println(specificConstructor.getParameterCount());    System.out.println(Arrays.toString(specificConstructor.getParameterTypes()));    Constructor&lt;?&gt;[] constructors = reflectionBeanClass.getConstructors();    System.out.println(Arrays.toString(constructors));&#125;</code></pre><p>输出结果：</p><pre><code class="hljs txt">io.better.jdk.reflection.ReflectionBean[[Ljava.lang.annotation.Annotation;@1b701da1]1[class java.lang.String][public io.better.jdk.reflection.ReflectionBean(java.lang.String), public io.better.jdk.reflection.ReflectionBean()]</code></pre><p>上面代码中演示了<code>Class.getConstructors</code>和<code>Class.getConstructor(Class&lt;?&gt; ..params)</code>获取构造方法。</p><p>通过Constructor对象我们可以获取到构造方法中的<code>注解，参数，参数类型，参数数量</code>等信息，但这两种方式都不能获取私有构造方法。那如何获取私有的构造器呢？</p><p>使用<code>getDeclaredConstructors()</code>和<code>getDeclaredConstructor(Class&lt;?&gt; ..params)</code>可以获取到类中所有的构造方法，包括私有的。</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredConstructors</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;  <span class="hljs-comment">// 获取所有构造方法，包括私有</span>  Constructor&lt;?&gt;[] declaredConstructors = reflectionBeanClass.getDeclaredConstructors();  <span class="hljs-comment">// 获取指定构造方法</span>  Constructor&lt;ReflectionBean&gt; specificDeclaredConstructor = reflectionBeanClass.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Integer</span>.<span class="hljs-title">class</span>)</span>;&#125;</code></pre><p>介绍完<code>Constructor</code>对象的获取方式后，接下来通过<code>Constructor</code>对象来实例化目标对象。</p><p>我们可以通过<code>Constructor.newInstance(Object ...params)</code>方法传入实际的参数来创建目标对象。</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConstructorInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;  <span class="hljs-comment">// 获取指定参数的公共构造方法</span>  Constructor&lt;ReflectionBean&gt; stringConstructor = reflectionBeanClass.getConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  <span class="hljs-comment">// 实例化</span>  ReflectionBean reflectionBean = stringConstructor.newInstance(<span class="hljs-string">"Constructor"</span>);    System.out.println(reflectionBean);  <span class="hljs-comment">// 获取指定参数的私有构造方法</span>  Constructor&lt;ReflectionBean&gt; declaredConstructor = reflectionBeanClass.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Integer</span>.<span class="hljs-title">class</span>)</span>;  <span class="hljs-comment">// 设置成可访问，不设置，会出现访问私有构造方法</span>  declaredConstructor.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// 实例化</span>  reflectionBean = declaredConstructor.newInstance(<span class="hljs-string">"DeclaredConstructor"</span>, <span class="hljs-number">1</span>);  System.out.println(reflectionBean);&#125;</code></pre><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><code>Method</code></h4><p>讲完<code>Constructor</code>的使用，已经能通过其创建对象了，那如何调用目标对象中的方法呢？</p><p>与Constructor类似，Class提供了<code>getMethods，getMethod(String methodName, Class&lt;?&gt; ...paramType)</code>方法分别获取执行类的<code>所有方法(包括静态方法，父类继承下来的方法)</code>和<code>指定方法</code>。</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    Method[] methods = reflectionBeanClass.getMethods();    Method method = reflectionBeanClass.getMethod(<span class="hljs-string">"reflection"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(<span class="hljs-string">"指定方法: "</span> + method.getName());    <span class="hljs-keyword">for</span> (Method item : methods) &#123;        System.out.println(item);    &#125;&#125;</code></pre><p>执行结果：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200506163345.png" srcset="/img/loading.gif" alt="image-20200506141809485"></p><p>从结果可以看出，私有方法未被获取到，和Constructor类似这两个方法不能获取私有方法，要想获取私有方法必须使用</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<span class="hljs-comment">// 获取所有方法，包括私有方法</span>    Method[] methods = reflectionBeanClass.getDeclaredMethods();<span class="hljs-comment">// 获取指定私有方法</span>    Method method = reflectionBeanClass.getDeclaredMethod(<span class="hljs-string">"validInfo"</span>);    System.out.println(method.getName());<span class="hljs-comment">// 获取到所有方法的方法名</span>    List&lt;String&gt; methodName = Stream.of(methods).map(Method::getName).collect(Collectors.toList());    System.out.println(methodName);&#125;</code></pre><p>执行结果：</p><pre><code class="hljs txt">validInfo[equals, toString, hashCode, getName, setName, instance, reflection, reflection, validInfo, canEqual, getAge, setAge]</code></pre><p>获取类中方法已经了解，接下一来尝试调用执行一下方法。</p><p>与Constructor不太一样，要想执行方法需要调用<code>invoke(Object obj, Object... args)</code>。该方法接受两个参数，第一个为目标对象(即拥有此方法的类对象)，第二为方法所需的参数。当调用私有方法时做法与Constructor一致。</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInvokedMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;  Constructor&lt;ReflectionBean&gt; constructor = reflectionBeanClass.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Integer</span>.<span class="hljs-title">class</span>)</span>;  constructor.setAccessible(<span class="hljs-keyword">true</span>);  ReflectionBean object = constructor.newInstance(<span class="hljs-string">"TEST"</span>, <span class="hljs-number">1</span>);  Method method = reflectionBeanClass.getDeclaredMethod(<span class="hljs-string">"validInfo"</span>);  method.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// 执行方法，获取结果</span>  Object methodResult = method.invoke(object);  System.out.println(methodResult);&#125;</code></pre><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a><code>Field</code></h4><p>与Method类似，我们可以使用<code>getFields，getField(String name)</code>两个方法来获取类中所有非私有的字段。</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    Field[] fields = reflectionBeanClass.getFields();    <span class="hljs-keyword">for</span> (Field field : fields) &#123;        System.out.println(field);    &#125;&#125;<span class="hljs-comment">// 结果：public java.lang.Boolean io.better.jdk.reflection.ReflectionBean.sex</span></code></pre><p>这两个方法只能获取<code>公共字段(public修饰)</code>，<code>private，default，protected</code>都获取不到。</p><p>我们可以使用<code>getDeclaredFields</code>，<code>getDeclaredField</code>两个方法来获取所有的字段和指定字段，</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    Field[] fields = reflectionBeanClass.getDeclaredFields();    <span class="hljs-keyword">for</span> (Field field : fields) &#123;        System.out.println(field);    &#125;    Field age = reflectionBeanClass.getDeclaredField(<span class="hljs-string">"age"</span>);    System.out.println(age);&#125;</code></pre><p>执行结果：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200506163353.png" srcset="/img/loading.gif" alt="image-20200506150309477" style="zoom:50%;" /><p>如果想要获取某个字段对应的值，则需要调用<code>get(Object obj)</code>方法，传入包含此字段的目标类对象，私有字段需要调用<code>setAccessible()</code>方法。</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFieldMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    Constructor&lt;ReflectionBean&gt; constructor = reflectionBeanClass.getDeclaredConstructor(String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Integer</span>.<span class="hljs-title">class</span>)</span>;    constructor.setAccessible(<span class="hljs-keyword">true</span>);    ReflectionBean object = constructor.newInstance(<span class="hljs-string">"TEST"</span>, <span class="hljs-number">1</span>);    Field age = reflectionBeanClass.getDeclaredField(<span class="hljs-string">"age"</span>);    age.setAccessible(<span class="hljs-keyword">true</span>);    System.out.println(age.getDeclaringClass());    System.out.println(age.get(object));&#125;<span class="hljs-comment">// 执行结果</span><span class="hljs-comment">// class io.better.jdk.reflection.ReflectionBean</span><span class="hljs-comment">// 1</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Constructor，Method，Field</code>三个类分别 对应类中 的<code>构造方法、方法、字段</code>，分别提供了<code>getDeclared</code>开头的方法来获取对应所有的信息。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance()"></a><code>newInstance()</code></h4><p>在获取到类的Class对象时，可以通过调用此方法来创建目标类对象，该方法会默认调用类的<code>无参构造方法</code>来创建对象。</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNewInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;  ReflectionBean reflectionBean = reflectionBeanClass.newInstance();  System.out.println(reflectionBean);&#125;</code></pre><h4 id="isInstance-Object-obj"><a href="#isInstance-Object-obj" class="headerlink" title="isInstance(Object obj)"></a><code>isInstance(Object obj)</code></h4><p>该方法用于断定指定Object是赋值兼容与此表示的对象Class ，等效<code>instanceof</code>运算符。</p><pre><code class="hljs java">Class&lt;String&gt; stringClass = String<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;stringClass.isInstance(<span class="hljs-string">"test"</span>); <span class="hljs-comment">// 结果=true，类型匹配</span>stringClass.isInstance(<span class="hljs-number">123456</span>); <span class="hljs-comment">// 结果=false，类型不匹配</span></code></pre><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="反射进行数组扩容"><a href="#反射进行数组扩容" class="headerlink" title="反射进行数组扩容"></a>反射进行数组扩容</h3><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testArrayExtension</span><span class="hljs-params">()</span> </span>&#123;  String[] stringArray = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>&#125;;  System.out.println(<span class="hljs-string">"原始数组长度: "</span> + stringArray.length);  Object newStringArray = ArrayExtension(stringArray, stringArray.length * <span class="hljs-number">2</span>);  System.out.println(<span class="hljs-string">"扩容后数组长度: "</span> + Array.getLength(newStringArray));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">ArrayExtension</span><span class="hljs-params">(Object sourceArray, <span class="hljs-keyword">int</span> extensionLength)</span> </span>&#123;  <span class="hljs-keyword">if</span> (extensionLength &lt; Array.getLength(sourceArray))    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"扩展长度不合法"</span>);  Class&lt;?&gt; componentType = sourceArray.getClass().getComponentType();  Object newStringArray = Array.newInstance(componentType, extensionLength);  System.arraycopy(sourceArray, <span class="hljs-number">0</span>, newStringArray, <span class="hljs-number">0</span>, Array.getLength(sourceArray));  <span class="hljs-keyword">return</span> newStringArray;&#125;</code></pre><h3 id="反射跳过泛型检查"><a href="#反射跳过泛型检查" class="headerlink" title="反射跳过泛型检查"></a>反射跳过泛型检查</h3><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJumpTypeCheck</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  stringList.add(<span class="hljs-string">"a"</span>);  stringList.add(<span class="hljs-string">"b"</span>);  stringList.add(<span class="hljs-string">"c"</span>);  Class&lt;? extends List&gt; listClass = stringList.getClass();  Method addMethod = listClass.getMethod(<span class="hljs-string">"add"</span>, Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  <span class="hljs-comment">// 向集合中添加了一个int类型的值</span>  addMethod.invoke(stringList, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 结果为4</span>  System.out.println(stringList.size());&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Reflection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Reflection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Proxy-代理</title>
    <link href="/2020/05/06/java/Java-Proxy/"/>
    <url>/2020/05/06/java/Java-Proxy/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述代模式以及其实现方式，主要是 <code>静态代理</code> , <code>动态代理</code>, <code>Cglib代理</code>.</p><a id="more"></a><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://zh.wikipedia.org/wiki/代理模式" target="_blank" rel="noopener">代理模式</a>是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><p>在<code>Java</code>中实现代理主要有三种方式：</p><ul><li>静态代码</li><li>动态代理</li><li>Cglib代理</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在静态代理中，需要为每一个被代理对象创建一个代理类，并实现同一个接口。</p><p>示例代码：</p><pre><code class="hljs java"><span class="hljs-comment">// 父接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IConsumer</span> </span>&#123;  <span class="hljs-comment">// 消费</span>  <span class="hljs-function">String <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 代理对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IConsumer</span> </span>&#123;  <span class="hljs-keyword">private</span> Consumer consumer;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsumerProxy</span><span class="hljs-params">(Consumer consumer)</span> </span>&#123;    <span class="hljs-keyword">this</span>.consumer = consumer;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"代理对象执行前的代码"</span>);    String consumer = <span class="hljs-keyword">this</span>.consumer.consumer();    System.out.println(<span class="hljs-string">"代理对象执行后的代码"</span>);    <span class="hljs-keyword">return</span> consumer;  &#125;&#125;<span class="hljs-comment">// 被代理对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IConsumer</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"消费方法被调用了"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"Success"</span>;  &#125;&#125;</code></pre><p>从代码中看出，<code>ConsumerProxy</code>代理对象持有了<code>Consumer</code>被代理对象的引用，并在<code>consumer方法</code>中调用了<code>被代理对象的consumer方法</code>。来看看实际测试代码：</p><p>测试代码：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStaticProxy</span><span class="hljs-params">()</span> </span>&#123;    Consumer consumer = <span class="hljs-keyword">new</span> Consumer();    IConsumer consumerProxy = <span class="hljs-keyword">new</span> ConsumerProxy(consumer);    System.out.println(consumerProxy.consumer());&#125;</code></pre><p>输出结果：</p><pre><code class="hljs txt">代理对象执行前的代码消费方法被调用了代理对象执行后的代码Success</code></pre><p><strong>优点：可以最大程度扩展被代理对象的功能。</strong></p><p><strong>缺点：被代理对象会随着代理对象的增加而增加，代码冗余。如果接口新增方法，代理对象和被代理对象都需要实现。</strong></p><p>基于静态代理的缺点，有没有一种代理能够动态的生成代理对象呢？</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>动态代理利用了<a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/" target="_blank" rel="noopener">JDK API</a>，动态的在内存中构建代理对象，从而实现对目标对象的代理功能。</p><p>动态代理又被称为JDK代理或接口代理。</p><p>相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。</p><p>先来看一个示例，了解一下动态代理的基本使用。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="hljs java"><span class="hljs-comment">// ①</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDynamic</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dynamicProxy</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// ②</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dynamic</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDynamic</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dynamicProxy</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"目标方法执行了"</span>);    &#125;&#125;<span class="hljs-comment">// ③</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxyInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Object proxyTarget;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DynamicProxyInvocation</span><span class="hljs-params">(Object proxyTarget)</span> </span>&#123;        <span class="hljs-keyword">this</span>.proxyTarget = proxyTarget;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">"代理执行前"</span>);        Object invokeResult = method.invoke(proxyTarget, args);        System.out.println(<span class="hljs-string">"代理执行后"</span>);        <span class="hljs-keyword">return</span> invokeResult;    &#125;&#125;</code></pre><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDynamicProxy</span><span class="hljs-params">()</span> </span>&#123;    Dynamic proxyTarget = <span class="hljs-keyword">new</span> Dynamic();    IDynamic dynamicProxy = (IDynamic) Proxy.newProxyInstance(proxyTarget.getClass().getClassLoader(),            proxyTarget.getClass().getInterfaces(), <span class="hljs-keyword">new</span> DynamicProxyInvocation(proxyTarget));    dynamicProxy.dynamicProxy();&#125;</code></pre><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><pre><code class="hljs txt">代理执行前目标方法执行了代理执行后</code></pre><p>在上面的代码中，看到了很多未知的接口和类，主要是<code>Proxy类</code>，<code>InvocationHandler接口</code>。</p><h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a><code>Proxy</code></h3><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p><code>Proxy.newProxyInstance()</code>方法返回的<code>代理类是如何生成</code>？为什么Jdk 的动态代理<code>被代理类必须实现接口</code>？</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Proxy提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的<code>超类</code>。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>从上面的示例代码可以看出代理类的实例是由<code>Proxy.newProxyInstance</code>返回的，那么我们重点关注<code>Proxy.newProxyInstance</code>这个方法。</p><h5 id="创建代理实例"><a href="#创建代理实例" class="headerlink" title="创建代理实例"></a>创建代理实例</h5><pre><code class="hljs java"><span class="hljs-keyword">protected</span> InvocationHandler h;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(InvocationHandler h)</span> </span>&#123;  Objects.requireNonNull(h);  <span class="hljs-keyword">this</span>.h = h;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> </span>&#123;  <span class="hljs-comment">// 忽略部分代码</span>    <span class="hljs-comment">// 步骤①</span>  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);  <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;    checkNewProxyPermission(Reflection.getCallerClass(), cl);  &#125;<span class="hljs-comment">// 步骤②</span>  <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);  <span class="hljs-keyword">final</span> InvocationHandler ih = h;  <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        cons.setAccessible(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> Object[]&#123;h&#125;);  <span class="hljs-comment">// 忽略部分代码</span>&#125;</code></pre><p>在<code>newProxyInstance</code>方法中有两个比较核心的步骤，分别如下：</p><p>步骤①：获取代理类的<code>Class</code>实例。</p><p>步骤②：获取代理类带有<code>InvocationHandler</code>参数的构造方法。</p><p>除了上面两个比较重要的步骤，还需要关注<code>InvocationHandler h</code>和<code>Proxy(InvocationHandler h)</code>，后面会进行讲解。</p><h5 id="获取代理类字节码"><a href="#获取代理类字节码" class="headerlink" title="获取代理类字节码"></a>获取代理类字节码</h5><p><code>getProxyClass0</code>最终会调用到<code>ProxyClassFactory.apply()</code>方法中，具体操作细节，可自行Debug查看调用链。</p><pre><code class="hljs java">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String proxyClassNamePrefix = <span class="hljs-string">"$Proxy"</span>;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;    <span class="hljs-comment">// 忽略部分代码</span>    <span class="hljs-keyword">long</span> num = nextUniqueNumber.getAndIncrement();    String proxyName = proxyPkg + proxyClassNamePrefix + num;<span class="hljs-comment">// 步骤①</span>    <span class="hljs-keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(      proxyName, interfaces, accessFlags);    <span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">// 步骤② 定义Class，native方法</span>      <span class="hljs-keyword">return</span> defineClass0(loader, proxyName,                          proxyClassFile, <span class="hljs-number">0</span>, proxyClassFile.length);    &#125; <span class="hljs-keyword">catch</span> (ClassFormatError e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(e.toString());    &#125;&#125;</code></pre><p>步骤①：调用<code>ProxyGenerator.generateProxyClass</code>生成代理类.class的字节数组。</p><p>步骤②：调用<code>defineClass0</code>生成.class文件，并加载到Jvm中。</p><h4 id="手动生成Class"><a href="#手动生成Class" class="headerlink" title="手动生成Class"></a>手动生成Class</h4><p>从上面我们得知了Proxy类在最后调用了<code>ProxyGenerator.generateProxyClass</code>方法生成了代理类的<code>.class</code>字节数组。那么生成的<code>.class</code>结构是怎样的呢？让我们来手动触发调用一下。</p><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyGeneratorTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">byte</span>[] dynamicObj = ProxyGenerator.generateProxyClass(      <span class="hljs-string">"ManualGeneratorDynamicClass"</span>, <span class="hljs-keyword">new</span> Class[]&#123;IDynamic<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;, 17)</span>;    FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"ManualGeneratorDynamicClass.class"</span>));    out.write(dynamicObj);    out.flush();    out.close();  &#125;&#125;</code></pre><h5 id="代理类-class文件"><a href="#代理类-class文件" class="headerlink" title="代理类.class文件"></a>代理类<code>.class</code>文件</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManualGeneratorDynamicClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDynamic</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;  <span class="hljs-comment">// 调用父类Proxy的构造器对父类中InvocationHandler属性进行了赋值</span>  <span class="hljs-comment">// 而这个构造器是在Proxy.newProxyInstance()方法中被调用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ManualGeneratorDynamicClass</span><span class="hljs-params">(InvocationHandler var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">super</span>(var1);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;var1&#125;);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) &#123;            <span class="hljs-keyword">throw</span> var3;        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, (Object[])<span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dynamicProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">// 调用了父类的InvocationHandler实例的invoke方法</span>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, (Object[])<span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            m1 = Class.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"equals"</span>, Class.forName(<span class="hljs-string">"java.lang.Object"</span>));            m2 = Class.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"toString"</span>);          <span class="hljs-comment">// 获取到被代理类实现的接口中的方法</span>            m3 = Class.forName(<span class="hljs-string">"io.better.jdk.proxy.dynamicproxy.IDynamic"</span>).getMethod(<span class="hljs-string">"dynamicProxy"</span>);            m0 = Class.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"hashCode"</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());        &#125;    &#125;&#125;</code></pre><p>从代码可以看出<code>ManualGeneratorDynamicClass</code>类不仅继承了<code>Proxy</code>类（解释了Porxy为什么是所有代理类的超类），还实现了<code>被代理类</code>实现的接口（解释了为什么被代理类必须实现接口？）。</p><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a><code>InvocationHandler</code></h3><p>通过上面对Proxy的了解，我们知道了代理类的方法调用最终会调用到InvocationHandler实例的invoke方法。</p><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>InvocationHandler是代理实例的调用处理程序（InvocationHandler实例）实现的接口。<br><code>每个代理实例都有一个关联的调用处理程序</code>。 当一个方法是在代理实例调用，方法调用进行编码，并分发给invoke的调用处理程序的方法。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;  <span class="hljs-comment">// 处理代理实例的方法调用并返回结果。</span>  <span class="hljs-comment">// 该方法将在调用处理程序时的方法是在一个代理实例，它与相关的调用来调用。</span>  <span class="hljs-comment">// proxy: 类型为Proxy</span>  <span class="hljs-comment">// method: 目标执行的方法</span>  <span class="hljs-comment">// args: 方法执行所需的参数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> Throwable</span>;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>运行时动态生成代理类，和被代理类解耦。</li></ul><p>缺点：</p><ul><li>被代理类必须实现接口，否则不能使用动态代理。</li></ul><h4 id="代理机制"><a href="#代理机制" class="headerlink" title="代理机制"></a>代理机制</h4><p>动态代理类（以下简称为代理类）是一种类，该类实现<code>创建类时(调用newProxyInstance方法时)</code>在运行时指定的<code>接口列表(interfaces参数)</code>，代理接口是由代理类实现的接口。代理实例是代理类的实例。<code>每个代理实例都有一个关联的调用处理程序对象，该对象实现接口InvocationHandler</code>。</p><p>通过其代理接口之一对代理实例进行的方法调用将分派给该实例的调用处理程序的invoke方法，并传递该<code>代理实例（proxy参数）</code>，一个标识所调用方法的<code>java.lang.reflect.Method对象（method参数）</code>以及一个数组包含参数的Object类型<code>（args参数）</code>。</p><h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上面我使用了动态代理，知道了动态代理一些优缺点，为了弥补Jdk动态代理的缺点，Cglib诞生了，被代理类无需实现接口也能被代理。</p><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><code>cglib</code>-字节码生成库是用于生成和转换Java字节码的高级API。AOP，测试，数据访问框架使用它来生成动态代理对象并拦截字段访问。</p><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> io.better.jdk.proxy.cglibproxy;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.util.Objects;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> better create in 2020/5/8 5:56 下午</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibBean</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">proxy</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"proxy execute ...."</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-keyword">private</span> Object proxyTarget;    <span class="hljs-function"><span class="hljs-keyword">public</span> CglibProxyFactory <span class="hljs-title">setProxyTarget</span><span class="hljs-params">(Object proxyTarget)</span> </span>&#123;        <span class="hljs-keyword">this</span>.proxyTarget = proxyTarget;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">"cglib 执行前"</span>);        Object result = method.invoke(proxyTarget, objects);        System.out.println(<span class="hljs-string">"cglib 执行后"</span>);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxyInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (Objects.isNull(proxyTarget)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"被代理对象不能为空"</span>);        &#125;        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperclass(proxyTarget.getClass());        enhancer.setCallback(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">return</span> enhancer.create();    &#125;&#125;</code></pre><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCglib</span><span class="hljs-params">()</span> </span>&#123;    CglibBean proxyTarget = <span class="hljs-keyword">new</span> CglibBean();    CglibBean proxyInstance = (CglibBean) <span class="hljs-keyword">new</span> CglibProxyFactory().setProxyTarget(proxyTarget).getProxyInstance();    proxyInstance.proxy();&#125;</code></pre><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><pre><code class="hljs txt">cglib 执行前proxy execute ....cglib 执行后</code></pre><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><p>从示例代码可以看出<code>Enhancer</code>类是创建代理对象的核心，那么Enhancer是如何创建代理类的呢？创建的代理类结构是如何呢？</p><p>在代码中一共操作了四部：</p><ol><li><p>创建Enhancer对象。</p></li><li><p>调用setSuperclass设置父类。</p></li><li><p>调用setCallback设置回调。</p></li><li><p>调用create创建代理实例。</p></li></ol><h4 id="创建Enhancer对象"><a href="#创建Enhancer对象" class="headerlink" title="创建Enhancer对象"></a>创建Enhancer对象</h4><h5 id="构造器描述"><a href="#构造器描述" class="headerlink" title="构造器描述"></a>构造器描述</h5><p>创建一个新的增强器。每个生成的对象都应使用一个新的Enhancer对象，并且不应在线程之间共享。要创建生成的类的其他实例，请使用Factory接口。</p><h5 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h5><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172422.png" srcset="/img/loading.gif" alt="image-20200509104246223" style="zoom:50%;" /><h5 id="Enhancer构造器"><a href="#Enhancer构造器" class="headerlink" title="Enhancer构造器"></a>Enhancer构造器</h5><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Source SOURCE = <span class="hljs-keyword">new</span> Source(Enhancer<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Enhancer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>(SOURCE);&#125;<span class="hljs-comment">// 父类AbstractClassGenerator构造器</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractClassGenerator</span><span class="hljs-params">(Source source)</span> </span>&#123;  <span class="hljs-keyword">this</span>.source = source;&#125;</code></pre><p>代码中将Enhancer的名称封装到了Source实例中，并调用父类AbstractClassGenerator构造器进行赋值 。</p><h4 id="设置父类"><a href="#设置父类" class="headerlink" title="设置父类"></a>设置父类</h4><h5 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h5><p>设置生成的类将继承的类。 为了方便起见，如果提供的超类实际上是接口，则将使用适当的参数来调用setInterfaces。 非接口参数不能声明为final，并且必须具有可访问的构造函数。</p><h5 id="方法setSuperclass"><a href="#方法setSuperclass" class="headerlink" title="方法setSuperclass"></a>方法<code>setSuperclass</code></h5><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class superclass;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSuperclass</span><span class="hljs-params">(Class superclass)</span> </span>&#123;<span class="hljs-comment">// 如果为接口，则获取并调用setInterfaces方法</span>  <span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; superclass.isInterface()) &#123;    setInterfaces(<span class="hljs-keyword">new</span> Class[]&#123; superclass &#125;);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; superclass.equals(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;    <span class="hljs-comment">// affects choice of ClassLoader</span>    <span class="hljs-keyword">this</span>.superclass = <span class="hljs-keyword">null</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 给superclass字段赋值</span>    <span class="hljs-keyword">this</span>.superclass = superclass;  &#125;&#125;<span class="hljs-keyword">private</span> Class[] interfaces;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInterfaces</span><span class="hljs-params">(Class[] interfaces)</span> </span>&#123;  <span class="hljs-keyword">this</span>.interfaces = interfaces;&#125;</code></pre><p>方法逻辑比较简单就是给Enhancer实例中的字段进行赋值。</p><h4 id="设置回调"><a href="#设置回调" class="headerlink" title="设置回调"></a>设置回调</h4><h5 id="方法描述-1"><a href="#方法描述-1" class="headerlink" title="方法描述"></a>方法描述</h5><p>设置要使用的单个回调。 如果使用createClass则被忽略。</p><h5 id="方法setCallback"><a href="#方法setCallback" class="headerlink" title="方法setCallback"></a>方法<code>setCallback</code></h5><pre><code class="hljs java"><span class="hljs-keyword">private</span> Callback[] callbacks;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback callback)</span> </span>&#123;    setCallbacks(<span class="hljs-keyword">new</span> Callback[]&#123; callback &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallbacks</span><span class="hljs-params">(Callback[] callbacks)</span> </span>&#123;  <span class="hljs-keyword">if</span> (callbacks != <span class="hljs-keyword">null</span> &amp;&amp; callbacks.length == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Array cannot be empty"</span>);  &#125;  <span class="hljs-keyword">this</span>.callbacks = callbacks;&#125;</code></pre><p>该方法也是给Enhancer实例中的<code>callbacks</code>字段进行赋值</p><h4 id="创建代理实例-1"><a href="#创建代理实例-1" class="headerlink" title="创建代理实例"></a>创建代理实例</h4><h5 id="方法描述-2"><a href="#方法描述-2" class="headerlink" title="方法描述"></a>方法描述</h5><p>如有必要，生成一个新类，并使用指定的回调（如果有）来创建一个新的对象实例。 使用超类的no-arg构造函数。</p><h5 id="入口-Enhancer-create"><a href="#入口-Enhancer-create" class="headerlink" title="入口-Enhancer.create"></a>入口-<code>Enhancer.create</code></h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;    classOnly = <span class="hljs-keyword">false</span>;    argumentTypes = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">return</span> createHelper();&#125;</code></pre><p><code>createHelper</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">createHelper</span><span class="hljs-params">()</span> </span>&#123;  preValidate();  Object key = KEY_FACTORY.newInstance((superclass != <span class="hljs-keyword">null</span>) ? superclass.getName() : <span class="hljs-keyword">null</span>,                                       ReflectUtils.getNames(interfaces),                                       filter == ALL_ZERO ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> WeakCacheKey&lt;CallbackFilter&gt;(filter),                                       callbackTypes,                                       useFactory,                                       interceptDuringConstruction,                                       serialVersionUID);  <span class="hljs-keyword">this</span>.currentKey = key;  Object result = <span class="hljs-keyword">super</span>.create(key);  <span class="hljs-keyword">return</span> result;&#125;</code></pre><p><code>KEY_FACTORY.newInstance</code>生成的<code>key</code>需要特别注意，后面在<code>生成代理类Class时会用此key与Class一对一绑定</code>。</p><p>继续查看父类的<code>create</code>方法。</p><h4 id="AbstractClassGenerator-create"><a href="#AbstractClassGenerator-create" class="headerlink" title="AbstractClassGenerator.create"></a><code>AbstractClassGenerator.create</code></h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Object key)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    ClassLoader loader = getClassLoader();    Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;    ClassLoaderData data = cache.get(loader);    <span class="hljs-comment">// 忽略部分代码</span>    <span class="hljs-keyword">this</span>.key = key;    <span class="hljs-comment">// 步骤①，创建代理类字节码核心入口</span>    Object obj = data.get(<span class="hljs-keyword">this</span>, getUseCache());    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Class) &#123;      <span class="hljs-keyword">return</span> firstInstance((Class) obj);    &#125;    <span class="hljs-comment">// 步骤②，根据创建代理类实例</span>    <span class="hljs-keyword">return</span> nextInstance(obj);  &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;  &#125;&#125;</code></pre><p>上诉代码中忽略了部分代码，重点关注<code>步骤①</code> 和<code>步骤②</code>对应的两个方法。</p><p>步骤①：调用<code>ClassLoaderData.get()</code>获取代理类Class对象。</p><p>步骤②：使用代理类Class对象创建代理实例。</p><h5 id="步骤①"><a href="#步骤①" class="headerlink" title="步骤①"></a>步骤①</h5><p>知道了代理对象是通过<code>ClassLoaderData.get</code>方法获取的，那么必须了解<code>ClassLoaderData</code>的作用及其结构。</p><h6 id="ClassLoaderData"><a href="#ClassLoaderData" class="headerlink" title="ClassLoaderData"></a><code>ClassLoaderData</code></h6><p>那么<code>ClassLoaderData</code>类有什么作用呢？通过Debug来看看ClassLoaderData内部结构。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172428.png" srcset="/img/loading.gif" alt="image-20200509150401851"></p><p>类结构图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172432.png" srcset="/img/loading.gif" alt="image-20200509150935264" style="zoom:50%;" /><p><code>generatedClasses</code>：用于存储已经生成的Class对象。</p><p><code>reservedClassNames</code>：用于存储已经解析的Class名称（全路径）。</p><p><code>classLoader</code>：加载生成Class对象的加载器。</p><p>可以看出ClassLoaderData内部管理生成的Class类和加载Class所需的ClassLoader，可以简单<code>理解为生成Class并存储Class的容器</code>。</p><h6 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h6><p>那么<code>ClassLoaderData</code>是如何初始化的呢 ？我们进入ClassLoaderData的构造器看看：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassLoaderData</span><span class="hljs-params">(ClassLoader classLoader)</span> </span>&#123;  <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"classLoader == null is not yet supported"</span>);  &#125;  <span class="hljs-comment">// 设置加载类使用的ClassLoader</span>  <span class="hljs-keyword">this</span>.classLoader = <span class="hljs-keyword">new</span> WeakReference&lt;ClassLoader&gt;(classLoader);  <span class="hljs-comment">// 声明了load函数</span>  Function&lt;AbstractClassGenerator, Object&gt; load =    <span class="hljs-keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(AbstractClassGenerator gen)</span> </span>&#123;      Class klass = gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">return</span> gen.wrapCachedClass(klass);    &#125;  &#125;;  <span class="hljs-comment">// 在这里对generatedClasses做了初始化</span>  generatedClasses = <span class="hljs-keyword">new</span> LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);&#125;</code></pre><p>可以看出<code>classLoader，generatedClasses</code>两个对象被进行了初始化，在这里重点注意<code>load</code>这个函数 ，<code>这个函数就是创建代理类Class的关键</code>。</p><h6 id="ClassLoaderData-get"><a href="#ClassLoaderData-get" class="headerlink" title="ClassLoaderData.get"></a><code>ClassLoaderData.get</code></h6><p>了解了<code>ClassLoaderData</code>后，我们进入 <code>get()</code>方法一探究竟：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(AbstractClassGenerator gen, <span class="hljs-keyword">boolean</span> useCache)</span> </span>&#123;<span class="hljs-comment">// useCache默认值为true</span>  <span class="hljs-keyword">if</span> (!useCache) &#123;    <span class="hljs-keyword">return</span> gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 从缓存中获取缓存的对象</span>    Object cachedValue = generatedClasses.get(gen);    <span class="hljs-keyword">return</span> gen.unwrapCachedValue(cachedValue);  &#125;&#125;</code></pre><p>如果不修改useCache的值，代码最终会调用<code>generatedClasses.get</code>方法。到这里是不是感觉<code>generatedClasses</code>这个对象是不是非常眼熟，没错他就是<code>ClassLoaderData中存放生成过Class的对象</code>。</p><p>接着进入generatedClasses对象一探究竟。</p><h6 id="LoadingCache"><a href="#LoadingCache" class="headerlink" title="LoadingCache"></a><code>LoadingCache</code></h6><p>在如何<code>LoadingCache.get</code>方法前，我们先来看看<code>LoadingCache</code>的构造函数：</p><pre><code class="hljs java"><span class="hljs-comment">// 上面ClassLoaderData构造器中最后一步会调用</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadingCache</span><span class="hljs-params">(Function&lt;K, KK&gt; keyMapper, Function&lt;K, V&gt; loader)</span> </span>&#123;    <span class="hljs-keyword">this</span>.keyMapper = keyMapper;  <span class="hljs-comment">// 用于获取 KEY_FACTORY.newInstance 创建的key的函数</span>    <span class="hljs-keyword">this</span>.loader = loader;   <span class="hljs-comment">// 用于生成代理类的Class函数</span>    <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;KK, Object&gt;();&#125;</code></pre><p>LoadingCache构造函数主要是在对<code>自身变量进行赋值</code>操作。</p><p><code>loader</code>：类型为函数，用于创建代理类Class</p><p><code>keyMapper</code>：类型为函数，用于获取前面<code>Enhancer.create</code>方法中通过<code>KEY_FACTORY.newInstance</code>创建的<code>key</code></p><p><code>map</code>：key=<code>keyMapper函数获取到的key</code>，value=<code>loader函数生成的代理Class数据</code>。</p><h6 id="LoadingCache-get"><a href="#LoadingCache-get" class="headerlink" title="LoadingCache.get"></a><code>LoadingCache.get</code></h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;  <span class="hljs-comment">// 获取到 KEY_FACTORY.newInstance 创建的key</span>  <span class="hljs-keyword">final</span> KK cacheKey = keyMapper.apply(key);  <span class="hljs-comment">// 查看是否已经存在</span>  Object v = map.get(cacheKey);  <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span> &amp;&amp; !(v <span class="hljs-keyword">instanceof</span> FutureTask)) &#123;    <span class="hljs-keyword">return</span> (V) v;  &#125;  <span class="hljs-comment">// 不存在，则创建</span>  <span class="hljs-keyword">return</span> createEntry(key, cacheKey, v);&#125;</code></pre><h6 id="LoadingCache-createEntry"><a href="#LoadingCache-createEntry" class="headerlink" title="LoadingCache.createEntry"></a><code>LoadingCache.createEntry</code></h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> V <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">final</span> K key, KK cacheKey, Object v)</span> </span>&#123;  <span class="hljs-comment">// key = AbstractClassGenerator</span>  <span class="hljs-comment">// cacheKey = Enhancer.EnhancerKey</span>    FutureTask&lt;V&gt; task;  <span class="hljs-keyword">boolean</span> creator = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;    task = (FutureTask&lt;V&gt;) v;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 创建一个Task</span>    task = <span class="hljs-keyword">new</span> FutureTask&lt;V&gt;(<span class="hljs-keyword">new</span> Callable&lt;V&gt;() &#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 到这来我们终于看到了ClassLoaderData构造器中声明的load函数被执行了</span>        <span class="hljs-comment">// (最后一步调用LoadingCache构造器，传递给LoadingCache.loader属性)</span>        <span class="hljs-keyword">return</span> loader.apply(key);      &#125;    &#125;);    <span class="hljs-comment">// 缓存Key和Task放入到map中缓存</span>    Object prevTask = map.putIfAbsent(cacheKey, task);    <span class="hljs-keyword">if</span> (prevTask == <span class="hljs-keyword">null</span>) &#123;      creator = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// 执行Task</span>      task.run();    &#125;  &#125;  V result;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 获取结果</span>    result = task.get();  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;  <span class="hljs-keyword">if</span> (creator) &#123;    <span class="hljs-comment">// 将缓存Key和生成Class对象放入到map中</span>    map.put(cacheKey, result);  &#125;  <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>这个方法主要是创建FutureTask用于异步创建Class对象，并对其结果进行了缓存，提高性能。</p><p>接下来调用<code>load.apply</code>执行函数，最终调用至<code>AbstractClassGenerator.generate</code>方法中。</p><pre><code class="hljs java">Function&lt;AbstractClassGenerator, Object&gt; load = <span class="hljs-keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() &#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(AbstractClassGenerator gen)</span> </span>&#123;    Class klass = gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">return</span> gen.wrapCachedClass(klass);  &#125;&#125;;</code></pre><h6 id="AbstractClassGenerator-generate"><a href="#AbstractClassGenerator-generate" class="headerlink" title="AbstractClassGenerator.generate"></a><code>AbstractClassGenerator.generate</code></h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Class <span class="hljs-title">generate</span><span class="hljs-params">(ClassLoaderData data)</span> </span>&#123;  Class gen;  <span class="hljs-comment">// 从ThreadLocal获取对象，默认应该为null</span>  Object save = CURRENT.get();  <span class="hljs-comment">// 设置ThreadLocal，保证此AbstractClassGenerator不被线程共享</span>  CURRENT.set(<span class="hljs-keyword">this</span>);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 获取到加载Class字节码使用的ClassLoader</span>    ClassLoader classLoader = data.getClassLoader();<span class="hljs-comment">// 步骤①</span>    <span class="hljs-keyword">byte</span>[] b = strategy.generate(<span class="hljs-keyword">this</span>);    String className = ClassNameReader.getClassName(<span class="hljs-keyword">new</span> ClassReader(b));    ProtectionDomain protectionDomain = getProtectionDomain();    <span class="hljs-keyword">synchronized</span> (classLoader) &#123; <span class="hljs-comment">// just in case</span>      <span class="hljs-keyword">if</span> (protectionDomain == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 步骤②</span>        gen = ReflectUtils.defineClass(className, b, classLoader);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 步骤②</span>        gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);      &#125;    &#125;    <span class="hljs-keyword">return</span> gen;  &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// 置为null</span>    CURRENT.set(save);  &#125;&#125;</code></pre><p>步骤①：</p><p>调用<code>strategy.generate</code>方法生成代理类字节码数组。</p><p>其默认实例为<code>GeneratorStrategy strategy = DefaultGeneratorStrategy.INSTANCE;</code>。</p><p><code>strategy.generate</code>方法最终会调用到<code>Enhancer.generateClass(ClassVisitor v)</code>方法，这里面包含了生成代理类字节码具体步骤（这里了不做讲解，有兴趣的可自行查看）。</p><p>步骤②：</p><p>调用<code>ReflectUtils.defineClass</code>方法使用传入的ClassLoader加载生成的代理类字节码数组。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class <span class="hljs-title">defineClass</span><span class="hljs-params">(String className, <span class="hljs-keyword">byte</span>[] b, ClassLoader loader, ProtectionDomain protectionDomain)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  Class c;  <span class="hljs-keyword">if</span> (DEFINE_CLASS != <span class="hljs-keyword">null</span>) &#123;    Object[] args = <span class="hljs-keyword">new</span> Object[]&#123;className, b, <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> Integer(b.length), protectionDomain &#125;;    <span class="hljs-comment">// 步骤①，使用ClassLoader加载字节码信息 </span>    c = (Class)DEFINE_CLASS.invoke(loader, args);  &#125;   <span class="hljs-comment">// 忽略部分代码</span>    Class.forName(className, <span class="hljs-keyword">true</span>, loader);  <span class="hljs-keyword">return</span> c;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method DEFINE_CLASS, DEFINE_CLASS_UNSAFE;</code></pre><p><code>DEFINE_CLASS</code>其实是<code>java.lang.ClassLoader.defineClass</code>对应的Method对象。</p><h5 id="步骤②"><a href="#步骤②" class="headerlink" title="步骤②"></a>步骤②</h5><p>走完步骤①代理类的Class对象已生成，接下来就是通过该Class对象生成代理实例。</p><p>我们进入<code>nextInstance(obj);</code>方法查看实例化流程：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">nextInstance</span><span class="hljs-params">(Object instance)</span> </span>&#123;  EnhancerFactoryData data = (EnhancerFactoryData) instance;  <span class="hljs-keyword">if</span> (classOnly) &#123;    <span class="hljs-keyword">return</span> data.generatedClass;  &#125;  Class[] argumentTypes = <span class="hljs-keyword">this</span>.argumentTypes;  Object[] arguments = <span class="hljs-keyword">this</span>.arguments;  <span class="hljs-keyword">if</span> (argumentTypes == <span class="hljs-keyword">null</span>) &#123;    argumentTypes = Constants.EMPTY_CLASS_ARRAY;    arguments = <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-comment">// 步骤①</span>  <span class="hljs-keyword">return</span> data.newInstance(argumentTypes, arguments, callbacks);&#125;</code></pre><p>该方法在调用代理类Class构造函数前，处理好对应的构造函数参数类型和参数。</p><p>重点关注步骤①：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Class[] argumentTypes, Object[] arguments, Callback[] callbacks)</span> </span>&#123;  setThreadCallbacks(callbacks);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// Explicit reference equality is added here just in case Arrays.equals does not have one</span>    <span class="hljs-keyword">if</span> (primaryConstructorArgTypes == argumentTypes ||        Arrays.equals(primaryConstructorArgTypes, argumentTypes)) &#123;<span class="hljs-comment">// 创建代理实例</span>      <span class="hljs-keyword">return</span> ReflectUtils.newInstance(primaryConstructor, arguments);    &#125;    <span class="hljs-comment">// 创建代理实例</span>    <span class="hljs-keyword">return</span> ReflectUtils.newInstance(generatedClass, argumentTypes, arguments);  &#125; <span class="hljs-keyword">finally</span> &#123;    setThreadCallbacks(<span class="hljs-keyword">null</span>);  &#125;&#125;</code></pre><p>至此Cglib创建代理对象流程分析完毕。</p><h4 id="使用Cglib手动生成Class文件"><a href="#使用Cglib手动生成Class文件" class="headerlink" title="使用Cglib手动生成Class文件"></a>使用Cglib手动生成Class文件</h4><p>分析完Cglib整个创建流程，我还不能像Jdk动态代理一样了解到生成的代理类字节码到底是怎样的？接下来我们使用Cglib手动生成一个代理类的Class文件。</p><p>由于<code>strategy.generate</code>方法所需参数较为复杂，可<code>Debug</code>至<code>byte[] b = strategy.generate(this);</code>这行代码利用IDEA的<code>Evaluate Expression</code>功能手动输入以下代码：</p><pre><code class="hljs java">FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"ManualGeneratorProxyCglibProxy.class"</span>));out.write(b);out.flush();out.close();</code></pre><p>生成文件如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibBean</span>$$<span class="hljs-title">EnhancerByCGLIB</span>$$70184645 <span class="hljs-keyword">extends</span> <span class="hljs-title">CglibBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> CGLIB$BOUND;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object CGLIB$FACTORY_DATA;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;  <span class="hljs-keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0; <span class="hljs-comment">// 我们自定义的MethodInterceptor</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object CGLIB$CALLBACK_FILTER;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method CGLIB$proxy$<span class="hljs-number">0</span>$Method;  <span class="hljs-comment">// CglibBean.proxy调用方法</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MethodProxy CGLIB$proxy$<span class="hljs-number">0</span>$Proxy;  <span class="hljs-comment">// CglibBean.proxy代理方法</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] CGLIB$emptyArgs;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$STATICHOOK1() &#123;    CGLIB$THREAD_CALLBACKS = <span class="hljs-keyword">new</span> ThreadLocal();    CGLIB$emptyArgs = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 通过反射得到代理类的Class对象</span>    Class var0 = Class.forName(<span class="hljs-string">"io.better.jdk.proxy.cglibproxy.CglibBean$$EnhancerByCGLIB$$70184645"</span>);    Class var1;    <span class="hljs-comment">// 获取到被代理类所有的方法，找到proxy，返回类型为void的方法对应的Method对象</span>    CGLIB$proxy$<span class="hljs-number">0</span>$Method = ReflectUtils.findMethods(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"proxy"</span>, <span class="hljs-string">"()V"</span>&#125;, (var1 = Class.forName(<span class="hljs-string">"io.better.jdk.proxy.cglibproxy.CglibBean"</span>)).getDeclaredMethods())[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 为proxy方法生成MethodProxy对象</span>    <span class="hljs-comment">// var1=被代理类的Class对象</span>    <span class="hljs-comment">// var2=代理类的Class对象</span>    CGLIB$proxy$<span class="hljs-number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="hljs-string">"()V"</span>, <span class="hljs-string">"proxy"</span>, <span class="hljs-string">"CGLIB$proxy$0"</span>);  &#125;  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> CGLIB$proxy$<span class="hljs-number">0</span>() &#123;    <span class="hljs-keyword">super</span>.proxy();  &#125;  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">proxy</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 获取到我们自定义的MethodInterceptor实例</span>    MethodInterceptor var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;    <span class="hljs-keyword">if</span> (var10000 == <span class="hljs-keyword">null</span>) &#123;      CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);      var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;    &#125;    <span class="hljs-keyword">if</span> (var10000 != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 调用MethodInterceptor.intercept</span>      var10000.intercept(<span class="hljs-keyword">this</span>, CGLIB$proxy$<span class="hljs-number">0</span>$Method, CGLIB$emptyArgs, CGLIB$proxy$<span class="hljs-number">0</span>$Proxy);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">super</span>.proxy();    &#125;  &#125;  <span class="hljs-keyword">static</span> &#123;    CGLIB$STATICHOOK1();  &#125;&#125;</code></pre><p>上诉代码中忽略了<code>equals，hashCode，toString</code>等方法。感兴趣的同学可以自己操作一下。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li><li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li><li>动态代理生成的类为 lass com.sun.proxy.$Proxy4，cglib代理生成的类为class com.cglib.UserDao$$EnhancerByCGLIB$$552188b6。</li><li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li><li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li><li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类</li></ol>]]></content>
    
    
    <categories>
      
      <category>Proxy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

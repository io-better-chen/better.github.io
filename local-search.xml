<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Juc-ThreadPool 解析</title>
    <link href="/2021/03/05/thread/06-Juc-Thread-Pool-Resolve/"/>
    <url>/2021/03/05/thread/06-Juc-Thread-Pool-Resolve/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述 Java 中 Juc 包下的 ThreadPoolExecutor<br>主要讲述 线程池 的核心设计以及其流程执行和源码分析</p><span id="more"></span><h2 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h2><blockquote><p>本章主要讲述线程池</p><ol><li>线程池的核心配置参数</li><li>线程池任务提交执行流程</li><li>线程池中线程新增流程</li><li>线程池中线程回收流程</li><li>线程池核心参数动态调整</li><li>线程池队列动态调整</li></ol></blockquote><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><h3 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h3><p>我们先来看看线程池的类继承图</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210304173122499.png" alt="image-20210304173122499"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Executor作为线程池的顶级接口, 定义了<code>task</code>的提交方法, 并将<code>task</code>的<code>提交</code>和<code>执行</code>进行了<code>解耦</code>.</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>Executor 接口中只有一个 <code>execute</code> 方法, 用于提交任务.</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;&#125;</code></pre></div><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><code>Executor</code>提供了向线程池中提交任务的方式,但是却没有提供管理线程池的相关方法. </p><p><code>ExecutorService</code> 定义了基于<code>execute</code>的<code>submit</code>方法, 该方法会返回一个<code>Future</code>对象, 此对象可用于停止<code>task</code>的执行或等待<code>task</code>执行成功.</p><p>同时还定义了<code>shutdown</code>方法和<code>shutdownNow</code>方法来关闭线程池</p><h4 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executor</span> </span>&#123;  <span class="hljs-comment">// 关闭线程池, 如果线程池中有task, 则会执行这些task, 该方法不会等待先前提交的task执行完成, </span>  <span class="hljs-comment">// 线程池将不再接受新task</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 尝试停止所有的task, 停止等待中的task, 并返回正在等待执行的task</span>  <span class="hljs-comment">// 此方法不等待主动执行的任务终止, 除了尽最大努力尝试停止处理正在执行的任务之外，没有任何保证.</span>  <span class="hljs-comment">// 典型的实现将通过Thread.interrupt取消，因此任何无法响应中断的任务都可能永远不会终止.</span>  <span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回当前线程池是否关闭</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回此线程池所有的task是否全部停止</span>  <span class="hljs-comment">// 请注意，除非先调用shutdown或shutdownNow, 否则isTerminated永远不会为true.</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 阻塞，直到关闭请求后所有任务完成执行，或者发生超时，或者当前线程被中断（以先发生者为准）.</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException</span>;  <span class="hljs-comment">// 提交一个task, 返回Future, Future.get方法可获取task的执行结果</span>  &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;  <span class="hljs-comment">// 同上</span>  &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;  <span class="hljs-comment">// 同上</span>  Future&lt;?&gt; submit(Runnable task);  <span class="hljs-comment">// 执行集合中所有的task</span>  &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)  <span class="hljs-comment">// 超时执行集合中所有的task</span>  &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-keyword">long</span> timeout,                                  TimeUnit unit)<span class="hljs-comment">// 执行集合中任意一个的task, 就返回</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span>;  <span class="hljs-comment">// 超时执行集合中任意一个的task, 就返回</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>;&#125;</code></pre></div><p>代码中的<code>shutdown</code>和<code>shutdownNow</code>都不保证已执行<code>task</code>的完成, 如果想要做到已执行的<code>task</code>完成后关闭线程池, 则可以使用<code>awaitTermination</code>方法.</p><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>该类是ExecutorService的基础实现,  对现<code>submit</code>，<code>invokeAny</code>和<code>invokeAll</code>等方法进行的简单的实现.</p><p>对Future进行了再次封装, 使用RunnableFuture来间接的替换了Future.</p><h4 id="核心方法-2"><a href="#核心方法-2" class="headerlink" title="核心方法"></a>核心方法</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(runnable, value);&#125;<span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;  <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();  RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);  execute(ftask);  <span class="hljs-keyword">return</span> ftask;&#125;</code></pre></div><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>此类为线程池的最终实现, 主要实现了 execute 方法,不论是 ExecutorService中的submit 方法 它们最终调用的都是 <code>execute</code> 方法.</p><h3 id="核心参数配置"><a href="#核心参数配置" class="headerlink" title="核心参数配置"></a>核心参数配置</h3><p>创建一个线程池必须要用其构造函数, 下面来看看 ThreadPoolExecutor 的构造函数</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210304183341075.png" alt="image-20210304183341075"></p><p>上面的三个构造函数最终都会调用到最后一个构造函数即参数最多的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,<span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;  <span class="hljs-comment">// 忽略代码</span>&#125;</code></pre></div><p>我们可以看到ThreadPoolExecutor的构造函数一共有四个, 但每个函数至少会有四个参数,分别是:</p><ul><li><code>corePoolSize:</code> 此参数表示当前线程池有多少<code>核心线程</code></li><li><code>maximumPoolSize:</code> 此参数表示当前线程池<code>最大</code>能创建多少<code>线程</code></li><li><code>keepAliveTime:</code> 此参数表示<code>超过核心线程数量的线程存活的时间</code></li><li><code>unit:</code> 时间单位,需要结合 <code>keepAliveTime</code> 使用</li><li><code>workQueue:</code> 此参数用于存放想线程池提交的任务</li></ul><p>而 <code>ThreadFactory</code> 和 <code>RejectedExecutionHandler</code> 分别用于创建线程和拒绝任务(<code>当队列满,且线程池中存活线程达到最大线程池</code>)</p><p>在 ThreadPoolExecutor 中默认提供了四种拒绝策略, 都已内部类的形式.</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210304184245365.png" alt="image-20210304184245365"></p><h4 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h4><p>线程的创建就是交给 ThreadFactory 参数实例来完成的, 线程池 默认使用<code>Executors.defaultThreadFactory</code>, 该工厂创建的线程拥有同一个ThreadGroup,且拥有相同的优先级和非守护进程状态. 也可以通过自定义线程池来定义线程名称和修改优先级和守护线程状态.</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<span class="hljs-comment">// 创建一个新线程 ,具有相同的ThreadGroup和优先级</span>  <span class="hljs-function">Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span></span>;&#125;</code></pre></div><p>如果要实现创建不同优先级或守护线程状态, 可自定义 ThreadFactory.</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>线程池使用了队列来存储调用线程提交的<code>task</code>. </p><p>队列的使用和线程池的大小有关系:</p><ul><li>如果线程池中运行的线程小于corePoolSize, 会直接创建线程执行task</li><li>如果线程池中运行的线程大于corePoolSize,<ul><li>队列未满直接入队,并创建一个 Worker 执行 task (此 Worker 不一定马上执行此 task)</li><li>队列已满时, 则会创建线程执行, 如果创建后的线程数大于<code>maximumPoolSize</code>, 则会执行拒绝策略.</li></ul></li></ul><p>而排队的策略有以下三种:</p><ol><li>同步队列, 比较好的队列是<code>SynchronousQueue</code></li><li>无限队列<ol><li>当线程池中执行线程达到corePoolSize时, 新提交的task将会直接排队.</li><li>maximumPoolSize属性的设置将没有意义</li></ol></li><li>有界队列<ol><li>当maximumPoolSizes有限时, 可使用有界队列, 防止资源耗尽</li></ol></li></ol><p>队列的具体实现由:</p><ol><li><code>ArrayBlockingQueue</code> : 有界的数组队列, 初始化时指定大小</li><li><code>LinkedBlockingQueue</code> : 有界的链表队列, 默认值为 Integer.MAX</li><li><code>DelayQueue</code> : 延迟队列, 只要延迟时间到期才能获取</li><li><code>SynchronousQueue</code> : 同步队列, 获取和放入是同步完成的</li><li><code>PriorityBlockingQueue</code> : 优先级队列, 可通过compareTo 来排序, 同级别的不能保证</li></ol><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>拒绝策略在<code>队列已满时</code>且<code>线程达到maximumPoolSize</code>时将会执行, 当达到前面两种情况时线程池会通过<code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code>来拒绝task的提交.</p><p><code>RejectedExecutionHandler</code>提供了四种拒绝策略实现:</p><ol><li>AbortPolicy 实现: 拒绝策略在拒绝时会抛出<code>RejectedExecutionException</code></li><li>CallerRunsPolicy 实现: 使用调用execute方法的调用线程(<code>自身而非线程池中的线程</code>)来执行task.</li><li>DiscardPolicy 实现: 删除队列中无法执行的task</li><li>DiscardOldestPolicy 实现: 丢弃队列的<code>头</code>任务, 然后重试执行(该操作可能再次失败)</li></ol><p>也可以通过实现RejectedExecutionHandler接口来实现自定义拒绝策略.</p><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>了解完线程池的创建参数后, 就可以创建一个线程池了, 这时就需要关注线程池是如何提交任务. 在线程池中submit 无论是提交 Runnable 还是 Callable 最终都会调用 execute 方法.</p><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a><code>execute</code></h4><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h5><p>先来看看源代码, 分析一下 execute 方法具体执行流程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;  <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();  <span class="hljs-comment">// 获取线程池的状态字段</span>  <span class="hljs-keyword">int</span> c = ctl.get();  <span class="hljs-comment">// step1: 如果工作线程数小于核心线程数, 则可以直接创建一个 Worker</span>  <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;    <span class="hljs-comment">// 尝试添加一个工作线程并执行task</span>    <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))      <span class="hljs-keyword">return</span>;    <span class="hljs-comment">// 失败重新获取ctl</span>    c = ctl.get();  &#125;<span class="hljs-comment">// 可能出现的情况:</span>  <span class="hljs-comment">// 1. 线程池未在运行状态(忽略)</span>  <span class="hljs-comment">// 2. task入队失败(队列已满)</span>  <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;    <span class="hljs-keyword">int</span> recheck = ctl.get();    <span class="hljs-comment">// 再次检查线程池状态, 如果未运行, 则从队列中删除此 task, 并执行拒绝策略</span>    <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))      reject(command);    <span class="hljs-comment">// 线程池运行且工作线程数量为 0, 则添加一个空任务</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);  &#125;<span class="hljs-comment">// 执行此 else if 的情况</span>  <span class="hljs-comment">// 1. 队列已满, 会导致上面的入队失败</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))    reject(command);&#125;</code></pre></div><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a><strong>执行流程</strong></h5><ul><li>步骤1: 获取线程数并判断线程池中的线程是否小于核心线程数<ul><li>小于则添加一个Worker(addWorker方法)</li><li>大于则执行步骤2</li></ul></li><li>步骤2: 判断线程池是否运行, 且task是否能插入队列成功?<ul><li>成功: 双重检查线程池状态<ul><li>未运行: 则将刚刚入队的 task 移除,并执行拒绝策略</li><li>运行中: 如果线程池工作线程为 0, 则添加一个 Worker(一个 Worker 就是一个线程)</li></ul></li><li>失败: 执行步骤3</li></ul></li><li>步骤3: 再次尝试添加Worker, 如果失败则执行拒绝策略</li></ul><p>注意上面的代码多次调用了<code>addWorker</code>方法, 顾名思义该方法添加了一个工作者去执行用户提交的task. </p><p><strong>且addWorker方法的第二个参数在第一次调用和后面一次调用时值不一样</strong> </p><p><strong>该值在 addWorker 方法中用于区分比较的值(true: 比较的是核心线程, false: 比较的是最大线程)</strong></p><h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><h5 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h5><p>Worker 主要维护线程运行任务的中断控制状态，以及其他次要记录。同时扩展了AbstractQueuedSynchronizer来简化获取和释放围绕每个任务执行的锁。</p><p>这可以防止旨在唤醒工作线程等待任务的中断，而不是中断正在运行的任务。</p><p>我们实现了一个简单的<code>非可重入互斥锁</code>，而不是使用ReentrantLock，因为我们不希望辅助任务在调用诸如setCorePoolSize之类的池控制方法时能够重新获取该锁。<br>另外，为了抑制直到线程真正开始运行任务之前的中断，我们将锁定状态初始化为负值，并在启动时将其清除（在runWorker中）。</p><h5 id="核心字段"><a href="#核心字段" class="headerlink" title="核心字段"></a>核心字段</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/** Worker运行的线程 */</span><span class="hljs-keyword">final</span> Thread thread;<span class="hljs-comment">/** 初始化Worker时要执行的task */</span>Runnable firstTask;</code></pre></div><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><div class="code-wrapper"><pre><code class="hljs java">Worker(Runnable firstTask) &#123;  setState(-<span class="hljs-number">1</span>);   <span class="hljs-keyword">this</span>.firstTask = firstTask;  <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 调用 ThreadFactory 创建线程</span>&#125;</code></pre></div><p>看完 Worker 类,我们知道了 Worker 就是一个工作线程, 而线程池中的 task 也是由 Worker 来执行的.</p><p>接下来回到 execute 方法中继续分析 addWorker 方法</p><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a><code>addWorker</code></h4><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;  <span class="hljs-comment">// 开启死循环</span>  retry:  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-keyword">int</span> c = ctl.get();    <span class="hljs-keyword">int</span> rs = runStateOf(c); <span class="hljs-comment">// 获取运行状态</span>    <span class="hljs-comment">// step1: 检查队列和线程池状态和firstTask参数</span>    <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;        ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 死循环</span>    <span class="hljs-keyword">for</span> (;;) &#123;      <span class="hljs-keyword">int</span> wc = workerCountOf(c);  <span class="hljs-comment">// 获取线程池中的工作线程</span>      <span class="hljs-comment">// step2: 判断工作线程是否达到阈值</span>      <span class="hljs-comment">// 这里的 core 就解释了上面为什么了 workerCoun&gt;corePoolSize 传递的参数为 false</span>      <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      <span class="hljs-comment">// 工作线程自增 1, 失败说明其他线程也调用了此方法</span>      <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c)) &#123;        <span class="hljs-keyword">break</span> retry;      &#125;      c = ctl.get();      <span class="hljs-keyword">if</span> (runStateOf(c) != rs)  <span class="hljs-comment">// 线程池状态发生改变(调用了 shutdown 方法), 继续自旋</span>        <span class="hljs-keyword">continue</span> retry;    &#125;  &#125;    <span class="hljs-comment">// 执行到此,说明workerCount已经自增成功</span>  <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;  Worker w = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 实例化Worker</span>    w = <span class="hljs-keyword">new</span> Worker(firstTask);    <span class="hljs-keyword">final</span> Thread t = w.thread; <span class="hljs-comment">// 获取到Worker的thread, 此线程使用线程池的ThreadFactory创建</span>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 获取到锁(线程池级别)</span>      <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;      mainLock.lock();      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 忽略部分代码</span>        workers.add(w);        <span class="hljs-comment">// 将Worker添加到hash表中, 方便后期线程释放 回收处理</span>        <span class="hljs-comment">// 忽略部分代码</span>      &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock(); <span class="hljs-comment">// 解锁</span>      &#125;      <span class="hljs-keyword">if</span> (workerAdded) &#123;        t.start();      <span class="hljs-comment">// 添加成功启动Worker的线程</span>        workerStarted = <span class="hljs-keyword">true</span>;      &#125;    &#125;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span> (! workerStarted)  <span class="hljs-comment">// worker启动失败, 执行</span>      addWorkerFailed(w);    &#125;  <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre></div><h5 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h5><p>大致分为两个阶段: </p><ol><li>修改<code>workerCount</code>数量<ol><li>开启一个死循环, 获取到线程池运行状态, 判断状态和队列及入参是否合法,不合法直接返回</li><li>在开启一个死循环, 比较workerCount是否超过maximumPoolSize或corePoolSize, 超过直接返回.</li><li>对工作线程数进行自增+1 操作成功,结束第一阶段.<ol><li>自增失败的情况: 1. 其他线程修改了workerCount 2. 线程池状态发生改变</li><li>如果其他线程修改了 workerCount,则继续执行内层循环, 直到修改 workerCount成功</li><li>如果是线程池状态改变, 则继续外层循环</li></ol></li></ol></li><li>创建 Worker<ol><li>创建一个 Worker 实例, 并获取到其线程, 如果Worker 中的线程为空, 说明 ThreadFactory 创建线程失败</li><li>获取到线程池的锁, 将 Worker 实例放入到 workers 集合中, 方便后续线程销毁</li><li>启动 Worker 中的线程, 如果启动失败, 执行步骤 4</li><li>执行<code>addWorkerFailed</code>方法</li></ol></li></ol><h4 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h4><p>当 Worker 创建完成后, 如果其线程启动失败则会执行<code>addWorkerFailed</code>方法来对线程池做一个回滚操作</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> </span>&#123;  <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;  mainLock.lock();  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">if</span> (w != <span class="hljs-keyword">null</span>)      workers.remove(w);   <span class="hljs-comment">// 从队列中删除 task</span>    decrementWorkerCount(); <span class="hljs-comment">// 自减 workCount</span>    tryTerminate();    <span class="hljs-comment">// 尝试终止线程池</span>  &#125; <span class="hljs-keyword">finally</span> &#123;    mainLock.unlock();  &#125;&#125;</code></pre></div><h5 id="线程池终止"><a href="#线程池终止" class="headerlink" title="线程池终止"></a>线程池终止</h5><p><code>tryTerminate</code> 大致逻辑是: 当线程池处于 <code>SHUTDOWN 且队列为空</code>或处于<code>STOP 且队列为空</code>时将线程池状态转变成<code>TERMINATED</code>. 如果可以终止,但 workerCount 不为 0 则中断一个空闲 Worker 保证传播关闭信号.</p><h4 id="Worker-run"><a href="#Worker-run" class="headerlink" title="Worker.run"></a>Worker.run</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>从上面的代码中我们看到了当Worker 新建成功后会调用其 <code>Thread.start</code>方法. 那 Runnable 是在何时传递给这个线程的呢?</p><p>查看 Worker 的构造函数得知:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);</code></pre></div><p>因为 Worker 本身继承了 AQS 且实现了 Runnable 接口, 所以当调用了 Thread.start 方法会执行 Worker.run 方法.</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    runWorker(<span class="hljs-keyword">this</span>);&#125;</code></pre></div><p>在 Worker.run 方法调用了 runWorker 方法</p><h5 id="运行-Worker"><a href="#运行-Worker" class="headerlink" title="运行 Worker"></a>运行 Worker</h5><p>先来看看 runWorker 的代码, 简单梳理一下流程:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;  <span class="hljs-comment">// step1: 获取Worker的thread和task, 并解锁</span>  Thread wt = Thread.currentThread();  Runnable task = w.firstTask;  w.firstTask = <span class="hljs-keyword">null</span>;  w.unlock(); <span class="hljs-comment">// 疑问: 为什么要解锁?</span>  <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// step2: 循环获取任务</span>    <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;      w.lock();       <span class="hljs-comment">// 线程池如果停止,保证线程中断,反之保证线程非中断</span>      <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp;runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())&#123;         wt.interrupt();  <span class="hljs-comment">// 中断Worker线程</span>      &#125;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// step3: 执行前操作</span>        beforeExecute(wt, task);        Throwable thrown = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;          task.run();  <span class="hljs-comment">// 调用Runnable.run方法</span>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;          thrown = x; <span class="hljs-keyword">throw</span> x;        &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;          thrown = x; <span class="hljs-keyword">throw</span> x;        &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;          thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);        &#125; <span class="hljs-keyword">finally</span> &#123;          afterExecute(task, thrown);  <span class="hljs-comment">// step4: 执行后操作</span>        &#125;      &#125; <span class="hljs-keyword">finally</span> &#123;        task = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 将task的引用置为空, 方便回收</span>        w.completedTasks++;        w.unlock();      &#125;    &#125;    completedAbruptly = <span class="hljs-keyword">false</span>;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// setp5: 当 task.run 出现异常时执行, 销毁当前 Worker</span>    processWorkerExit(w, completedAbruptly);  &#125;&#125;</code></pre></div><h5 id="执行流程-2"><a href="#执行流程-2" class="headerlink" title="执行流程"></a>执行流程</h5><ol><li>获取 Worker 的线程, 并解锁(Worker 构造时已经加锁了), 初始 task 为空则调用 <code>getTask</code> 获取任务</li><li>task 执行前先加锁, 避免线程池状态更改时(<code>SHUTDOWN</code>), task 执行了</li><li>调用 <code>beforeExecute</code> 前置方法</li><li>执行 task, 是否出现异常, 出现异常执行最后一步</li><li>执行完成调用<code>afterExecute</code>后置方法, 并对数据进行自增</li><li>出现异常,则调用<code>processWorkerExit</code>方法回收当前 Worker</li></ol><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210305112210966.png" alt="image-20210305112210966"  /><h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a><code>getTask</code></h4><p>在 Worker 的启动代码中知道了 Worker 是如何执行 task 的, 缺不太了解是如何获取 Task 的, 而获取 Task 则是调用 getTask 方法实现的.</p><h5 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h5><p>该方法根据当前线程池的配置来设置阻塞或定时获取任务, 但出现以下一些情况则会返回 null:</p><ol><li>当 workerCount &gt; maximumPoolSize , 即超过了最大线程数, 不能再创建 Worker 了</li><li>线程池状态为 <code>STOP</code></li><li>线程池状态为 <code>SHUTDOWN</code> 或<code>队列为空</code></li><li>Worker 等待 task 的时间超过了 <code>keepAliveTime</code>(workerCount &gt; corePoolSize 的情况)</li></ol><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span>  <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 自旋等待task</span>    <span class="hljs-keyword">int</span> c = ctl.get();    <span class="hljs-keyword">int</span> rs = runStateOf(c);    <span class="hljs-comment">// 线程池处于 SHUTDOWN 且 (线程池处于 STOP 或队列为空)</span>    <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;       decrementWorkerCount();  <span class="hljs-comment">// 自减 workerCount, 并返回 null</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;    <span class="hljs-keyword">int</span> wc = workerCountOf(c);  <span class="hljs-comment">// 获取 workerConut</span><span class="hljs-comment">// allowCoreThreadTimeOut: 表示是否开启核心线程过期销毁</span>    <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;    <span class="hljs-comment">// 如果超过了最大线程数 或 已超时</span>    <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))        &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123; <span class="hljs-comment">// 队列为空</span>      <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="hljs-comment">// 自减 workerCount</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 根据当前 workerCount 来判断是否应该超时从队列中获取 task</span>      Runnable r = timed ?        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS):workQueue.take();      <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span> r;      timedOut = <span class="hljs-keyword">true</span>;   <span class="hljs-comment">// 超时, 继续下一次自旋(最终会退出)</span>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;      timedOut = <span class="hljs-keyword">false</span>;    &#125;  &#125;&#125;</code></pre></div><h5 id="执行流程-3"><a href="#执行流程-3" class="headerlink" title="执行流程"></a>执行流程</h5><ol><li>开启自旋, 判断线程池状态, 如果处于 SHUTDOWN 或 STOP 或 队列为空 则直接返回 null</li><li>获取到 workerCount, 判断是否开启核心线程超时(<code>allowCoreThreadTimeOut</code>)<ol><li>未开启则比较 workerCount &gt; coolPoolSize 是否成立</li><li>开启则从队列获取 task 时为超时获取</li></ol></li><li>判断 workerCount &gt; maximumPoolSize 和 队列为空 和 超时过(<code>timedOut</code>) 等条件是否成立<ol><li>成立则修改 workerCount , 成功返回 null , 失败(其他 Worker 可能也在修改 workerCount)则继续自旋</li></ol></li><li>根据步骤2 的结果判断中队列中获取是<code>超时</code>获取还是<code>阻塞</code>获取, 如果是超时获取且结果为空, 则会进入下一次自旋再次执行步骤 1,2,3中的判断逻辑.</li></ol><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210305141210441.png" alt="image-20210305141210441"></p><h4 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a><code>processWorkerExit</code></h4><h5 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h5><p>该方法用于销毁当前 Worker, 当 <code>getTask 返回 null</code>, 或 <code>workerCount &gt; maximumPoolSize</code>就会销毁当前 Worker</p><h5 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;  <span class="hljs-comment">// completedAbruptly: 标识当前 Worker 是否是因为task 执行异常而需要销毁的</span>  <span class="hljs-keyword">if</span> (completedAbruptly)    decrementWorkerCount();  <span class="hljs-comment">// step1: 统计所有 worker 完成的 task 数量</span>  <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;  mainLock.lock();   <span class="hljs-keyword">try</span> &#123;    completedTaskCount += w.completedTasks;  <span class="hljs-comment">// 统计完成的 task 数量</span>    workers.remove(w); <span class="hljs-comment">// 删除此 Worker 的引用</span>  &#125; <span class="hljs-keyword">finally</span> &#123;    mainLock.unlock();  &#125;  <span class="hljs-comment">// step2: 尝试终止此 Worker</span>  tryTerminate();   <span class="hljs-comment">// 此方法在 addWorker 失败时调用的一致</span>  <span class="hljs-keyword">int</span> c = ctl.get();  <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;   <span class="hljs-comment">// 线程池未处于 STOP 状态</span>    <span class="hljs-keyword">if</span> (!completedAbruptly) &#123; <span class="hljs-comment">// 条件成立, 说明不是因为异常导致此 Worker 销毁, 可能是队列没有任务</span>      <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;      <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())   <span class="hljs-comment">// 如果队列不为空</span>        min = <span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span>    &#125;    <span class="hljs-comment">// 进入到这里有两个可能:</span>    <span class="hljs-comment">// 1. completedAbruptly=false, 在 runWorker 中只有 while 循环条件不满足才会执行</span>    <span class="hljs-comment">// 2. 上面的if (workerCountOf(c) &gt;= min) 判断不成立, 即 workerCount&lt;corePoolSize</span>        <span class="hljs-comment">// 此时创建一个新的 Worker 来替换此 Worker</span>    addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);  &#125;&#125;</code></pre></div><h3 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h3><p>线程池关闭有两个方法可以进行操作: <code>shutdown</code> <code>shutdownNow</code></p><p>它两的区别是: </p><ul><li><p><code>shutdown</code> : 等待正在执行任务的 Worker 执行完成, 不接受新的 task 提交</p></li><li><p><code>shutdownNow</code> : 尝试停止所有正在执行的任务, 从队列中删除等待执行的 task 并返回</p><ul><li>此实现通过<code>Thread.interrupt</code>取消任务，因此任何无法响应中断的任务都可能永远不会终止。</li></ul></li></ul><h3 id="动态参数配置"><a href="#动态参数配置" class="headerlink" title="动态参数配置"></a>动态参数配置</h3><p>虽然网上有线程池配置的公式, 但是公司不一定适合所有场景, 因此线程池提供了动态修改线程池的方法.</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210305152123194.png" alt="image-20210305152123194"></p><p>其中我们比较关心的是核心线程, 最大线程, 队列大小的设置</p><h4 id="核心线程设置"><a href="#核心线程设置" class="headerlink" title="核心线程设置"></a>核心线程设置</h4><h5 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h5><p>核心线程的配置可以通过 <code>setCorePoolSize()</code> 来设置.</p><p>此方法用于设置核心线程数。 这将覆盖在构造函数中设置的任何值。 如果新值小于当前值，则多余的现有线程将在下次空闲时终止。 如果更大，将在需要时启动新线程以执行任何排队的任务。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCorePoolSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;  <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();  <span class="hljs-comment">// 计算核心线程差值, 利于后面判断</span>  <span class="hljs-keyword">int</span> delta = corePoolSize - <span class="hljs-keyword">this</span>.corePoolSize;  <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;  <span class="hljs-comment">// 先赋值</span>  <span class="hljs-comment">// workerCount 超过 corePoolSize</span>  <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)    interruptIdleWorkers(); <span class="hljs-comment">// 中断Worker, 调用 Worker 中 Thread.interrupt 方法实现</span>  <span class="hljs-comment">// workerCount 还未达到 corePoolSize</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delta &gt; <span class="hljs-number">0</span>) &#123;     <span class="hljs-keyword">int</span> k = Math.min(delta, workQueue.size()); <span class="hljs-comment">// 如果新 corePoolSize 还未达到 和 workQueueSize 至少有一个task, 则创建一个 Worker</span>    <span class="hljs-keyword">while</span> (k-- &gt; <span class="hljs-number">0</span> &amp;&amp; addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>)) &#123;      <span class="hljs-keyword">if</span> (workQueue.isEmpty())        <span class="hljs-keyword">break</span>;    &#125;  &#125;&#125;</code></pre></div><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol><li>计算 <code>新corePoolSize</code> 和<code>旧corePoolSize</code> 的差值, 并修改线程池的 corePoolSize</li><li>判断 workerCount 是否大于新 corePoolSize 是否成立, 成立则中断多余的 Worker, 反之继续执行</li><li>判断是否需要新增 Worker(delta&gt;0), 成立则开启自旋创建, 当 delta&lt;=0 或队列为空时结束</li></ol><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20210305172152265.png" alt="image-20210305172152265"></p><h4 id="最大线程设置"><a href="#最大线程设置" class="headerlink" title="最大线程设置"></a>最大线程设置</h4><h5 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h5><p>设置允许的最大线程数。 这将覆盖在构造函数中设置的任何值。 如果新值小于当前值，则多余的现有线程将在下次空闲时终止。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMaximumPoolSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maximumPoolSize)</span> </span>&#123;  <span class="hljs-keyword">if</span> (maximumPoolSize &lt;= <span class="hljs-number">0</span> || maximumPoolSize &lt; corePoolSize)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();  <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;  <span class="hljs-comment">// workerCount &gt; 新maximumPoolSize, 则中断多余的 Worker</span>  <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)    interruptIdleWorkers();&#125;</code></pre></div><h4 id="队列大小设置"><a href="#队列大小设置" class="headerlink" title="队列大小设置"></a>队列大小设置</h4><p>线程池没有提供修改队列大小的方法, 当时提供了获取队列的方法: <code>getQueue</code>, 该方法返回的类型为 <code>BlockingQueue</code></p><p>常用的是 <code>LinkedBlockingQueue</code> 但是其 capacity 是 final 类型的, 不支持修改,  可以自行拷贝一份源代码,将其 <code>capacity</code> 修改成非 final 的, 并提供 <code>get set</code> 方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此线程池的核心参数和以及动态调整, 实际场景中参数的配置可能是根据场景 QPS 进行变化的, 所以一般都会使用线程池监控, 来监控线程池的状态. </p><p>本文主要偏向于源码的分析, 和对线程池执行流程的分析, 需要将整个流程串起来. 才能更好的理解线程池.</p><p>一些看法和理解如有错误,请指出, 多多交流. </p><p>推荐文章:</p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团</a> </p><p><a href="https://www.cnblogs.com/thisiswhy/p/12690630.html">博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
      <tag>源码分析</tag>
      
      <tag>ThreadPool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Juc-AQS 源码分析</title>
    <link href="/2021/03/05/thread/05-Juc-Aqs-SourceCode-Resolve/"/>
    <url>/2021/03/05/thread/05-Juc-Aqs-SourceCode-Resolve/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述 Java 中 Juc 包下的 AbstractQueuedSynchronizer<br>主要讲述 AQS 的设计及其独占模式和共享模式的获取和释放流程</p><span id="more"></span><h2 id="本章简介"><a href="#本章简介" class="headerlink" title="本章简介"></a>本章简介</h2><blockquote><p>本章主要讲述 JUC 包下的 AQS 的设计与现实, 同时了解 AQS 中独占和共享模式的运转原理和机制</p><ol><li>AQS 的设计和实现</li><li>AQS 中队列介绍及其变体</li><li>AQS 中独占和共享模式的源代码分析</li></ol></blockquote><h2 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h2><p>此类为AbstractQueuedSynchronizer的父类,  一个同步器框架有可能在一个时刻被某一个线程独占，<code>AbstractOwnableSynchronizer</code>就是为所有的同步器实现和锁相关实现提供了基础的保存、获取和设置独占线程的功能.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 一个线程可以独占的同步器,  此类提供了创建锁和相关的同步器（可能涉及所有权概念）的基础</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * AbstractOwnableSynchronizer 类本身并不管理或使用此信息。 </span><span class="hljs-comment"> * 但是，子类和工具可以使用适当维护的值来帮助控,制和监视访问并提供诊断。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3737899427754241961L</span>;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> </span>&#123; &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">    * 独占模式同步的当前所有者</span><span class="hljs-comment">    */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;  <span class="hljs-comment">/**</span><span class="hljs-comment">    * 设置当前拥有独占访问权的线程</span><span class="hljs-comment">    * null参数表示没有线程拥有访问权限, 否则, 此方法不会强加任何同步或&#123;<span class="hljs-doctag">@code</span> volatile&#125;字段访问</span><span class="hljs-comment">    */</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> </span>&#123;    exclusiveOwnerThread = thread;  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title">getExclusiveOwnerThread</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> exclusiveOwnerThread;  &#125;&#125;</code></pre></div><h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a><code>AbstractQueuedSynchronizer</code></h2><p>Juc 包下的多数同步器都是基于<code>AbstractQueuedSynchronizer（简称 AQS）</code>框架实现的，AQS为<code>同步状态</code>的<code>原子性管理</code>、<code>线程的阻塞</code>和<code>解除阻塞</code>以及<code>排队</code>提供了一种通用的机制。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>同步器一般包含两种方法，一种是<code>acquire</code>，另一种是<code>release</code>。acquire操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而release操作则是通过某种方式改变同步状态，使得一或多个被acquire阻塞的线程继续执行。</p><p>但是 Juc 包中不同的同步器其相应的 API 页不相，<code>Lock.lock，Semaphore.acquire，CountDownLatch.await</code>（但本质都是<code>acquire</code>或<code>release</code>操作），但都支持下面的操作：</p><ul><li>阻塞和非阻塞同步</li><li>可选的超时设置，让调用者可以放弃等待</li><li>通过中断实现任务取消，通常分为两个版本，一个<code>acquire</code>可取消，而另一个不可以。</li></ul><p>同步器的实现根据其状态分为两种：<code>独占状态</code>和<code>共享状态</code>。</p><ul><li>独占状态：同步器在同一时间允许一个线程执行（<code>Lock</code>）</li><li>共享状态：同步器在同一时间允许多个线程执行（<code>Semaphore</code>）</li></ul><h3 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h3><p><code>acquire</code>和<code>release</code>简单的伪代码实现：</p><p><code>acquire</code>操作：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (synchronization state does not allow acquire) &#123;    enqueue current thread <span class="hljs-keyword">if</span> not already queued;    possibly block current thread;&#125;dequeue current thread <span class="hljs-keyword">if</span> it was queued;</code></pre></div><p><code>release</code>操作：</p><div class="code-wrapper"><pre><code class="hljs java">update synchronization state;<span class="hljs-keyword">if</span> (state may permit a blocked thread to acquire)    unblock one or more queued threads;</code></pre></div><p>实现上面的操作，需要下面三个操作：</p><ul><li>同步状态的原子性管理；</li><li>线程的阻塞与解除阻塞；</li><li>队列的管理；</li></ul><h4 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h4><p>AQS类使用单个<code>int</code>（32位）来保存同步状态，并暴露出<code>getState</code>、<code>setState</code>以及<code>compareAndSet</code>操作来读取和更新这个状态。</p><p>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义<code>tryAcquire</code>和<code>tryRelease</code>方法，以控制<code>acquire</code>和<code>release</code>操作。当同步状态满足时，<code>tryAcquire</code>方法必须返回<code>true</code>，而当新的同步状态允许后续<code>acquire</code>时，<code>tryRelease</code>方法也必须返回<code>true</code>。这些方法都接受一个<code>int</code>类型的参数用于传递想要的状态。</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>Juc包中提供了一个<code>LockSupport</code>类，其<code>LockSupport.park</code>和<code>LockSupport.unpark</code>用于替换传统的 <code>Thread.suspend</code>和 <code>Thread.resume</code>（同一产生死锁），<code>LockSupport.unpark</code>方法被提前调用也是可以的。</p><p><code>LockSupport.unpark</code>的调用是没有被计数的，因此在一个<code>park</code>调用前多次调用<code>unpark</code>方法只会解除一个<code>park</code>操作。</p><p>另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可能有“剩余的”<code>unpark</code>操作。</p><p>但是，在缺少一个<code>unpark</code>操作时，下一次调用<code>park</code>就会阻塞。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的FIFO队列，因此，框架不支持基于优先级的同步。</p><p>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，已知 MCS 和 CLH 两种锁队列，但在 AQS 中使用了 CLH 锁队列，因为CLH 更容易实现<code>超时</code>和<code>取消</code>功能。AQS 基于 CLH 进行了修改和 CLH有较大的出入。</p><p><img src="http://ifeve.com/wp-content/uploads/2013/01/CLHNode.png" alt=""></p><p>第一个对CLH队列主要的修改是添加了 next 字段，来用于唤醒后继节点</p><p>第二个对CLH队列主要的修改是将每个节点都有的状态字段用于控制阻塞而非自旋。</p><p>而AQS中同步队列的基础实现是其内部类<code>Node</code></p><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;  <span class="hljs-comment">// 标记共享模式</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();  <span class="hljs-comment">// 标记排他模式</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 取消状态</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED = <span class="hljs-number">1</span>;  <span class="hljs-comment">//表示后续节点需要释放</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL = -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 节点出去等待状态</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;  <span class="hljs-comment">// 下一个acquireShared应该无条件传播</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;  <span class="hljs-comment">// 状态字段</span>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;    <span class="hljs-comment">// 前继节点, 在入队期间分配，并且仅在出队时将其清空, 前置节点取消时, 会短路</span>  <span class="hljs-keyword">volatile</span> Node prev;  <span class="hljs-comment">// 前继节点, 在排队过程中分配，在绕过取消的前任对象时进行调整，并在出队时清零</span>  <span class="hljs-comment">// 被取消节点的next字段设置为指向节点本身而不是null</span>  <span class="hljs-keyword">volatile</span> Node next;  <span class="hljs-comment">// 使该节点排队的线程。在构造上初始化，使用后消失</span>  <span class="hljs-keyword">volatile</span> Thread thread;  <span class="hljs-comment">// 链接到等待条件的下一个节点，或者链接到特殊值SHARED</span>  <span class="hljs-comment">// 由于条件队列仅在以独占模式保存时才被访问，因此我们只需要一个简单的链接队列即可在节点等待条件时保存节点。</span>  <span class="hljs-comment">// 然后将它们转移到队列中以重新获取</span>  <span class="hljs-comment">// 由于条件只能是互斥的，因此我们使用特殊值来表示共享模式来保存字段</span>  <span class="hljs-comment">// 下一个等待节点</span>  Node nextWaiter;  Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span>  &#125;  Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span>    <span class="hljs-keyword">this</span>.nextWaiter = mode;    <span class="hljs-keyword">this</span>.thread = thread;  &#125;  Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span>    <span class="hljs-keyword">this</span>.waitStatus = waitStatus;    <span class="hljs-keyword">this</span>.thread = thread;  &#125;  <span class="hljs-comment">// 返回ture表示当前节点处于共享模式等待</span>  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> nextWaiter == SHARED;  &#125;  <span class="hljs-comment">// 返回前一个节点, 如果为null抛出空指针异常</span>  <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;    Node p = prev;    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">else</span>      <span class="hljs-keyword">return</span> p;  &#125;&#125;</code></pre></div><p><code>waitStatus</code>的取值:</p><ul><li><code>CANCELLED</code>: 由于超时或中断导致该节点被取消,被取消节点的线程永远不会再次阻塞</li><li><code>CONDITION</code>: 该节点当前在<code>条件队列</code>中, 在传输之前, 它不会用作<code>同步队列</code>节点, 此时状态将设置为<code>0</code>.</li><li><code>SIGNAL</code>: 当前节点的后继节点被阻塞, 如果当前节点释放或取消时必须唤醒其后继节点</li><li><code>PROPAGATE</code>:  此状态值通常只设置到调用了<code>doReleaseShared()</code>方法的头节点，确保<code>releaseShared()</code>方法的调用可以传播到其他的所有节点，简单理解就是共享模式下节点释放的传递标记。</li></ul><p>非负值表示节点不需要发信号, 对于常规同步节点，该字段初始化为0, 对于条件节点，该字段初始化为CONDITION<br>使用CAS对其进行修改</p><p><code>nextWaiter</code>该字段字面意思是:下一个等待节点，其实有三个取值:</p><ul><li><code>Node.EXCLUSIVE</code>: 独占模式</li><li><code>Node.SHARED</code>: 共享模式</li><li>其他值: <strong>代表Condition等待队列中当前节点的下一个等待节点</strong></li></ul><h2 id="队列变体"><a href="#队列变体" class="headerlink" title="队列变体"></a>队列变体</h2><p>知道了AQS 的队列是使用的CLH队列的变体, 所以有必要看看 CLH 和 MCS 两个队列.</p><h3 id="CLH-锁队列"><a href="#CLH-锁队列" class="headerlink" title="CLH 锁队列"></a>CLH 锁队列</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CLH_Lock</span> </span>&#123;  <span class="hljs-keyword">final</span> AtomicReference&lt;Node&gt; tail = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-keyword">new</span> Node());  <span class="hljs-keyword">final</span> ThreadLocal&lt;Node&gt; current;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">_CLH_Lock</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.current = <span class="hljs-keyword">new</span> ThreadLocal&lt;Node&gt;() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> Node <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;        Node node = <span class="hljs-keyword">new</span> Node();        System.out.println(<span class="hljs-string">&quot;构造器: &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;-&quot;</span> + node);        <span class="hljs-keyword">return</span> node;      &#125;    &#125;;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    _CLH_Lock lock = <span class="hljs-keyword">new</span> _CLH_Lock();    Runnable runnable = () -&gt; &#123;      <span class="hljs-keyword">try</span> &#123;        lock.lock();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取到了锁&quot;</span>);        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;释放到了锁&quot;</span>);        lock.unlock();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;;    <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;线程 A&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;线程 B&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;线程 C&quot;</span>).start();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Node own = <span class="hljs-keyword">this</span>.current.get();    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-&quot;</span> + own);    own.locked = <span class="hljs-keyword">true</span>;    Node preNode = tail.getAndSet(own);    <span class="hljs-keyword">while</span> (preNode.locked) &#123;      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始自旋....&quot;</span>);      TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;    current.get().locked = <span class="hljs-keyword">false</span>;  &#125;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> locked = <span class="hljs-keyword">false</span>;  &#125;&#125;</code></pre></div><p>CLH 队列类似于一个伪链表，每个线程在通过 CAS 操作替换 <code>tail</code> 节点引用后，拿到上一个线程节点引用，不断循环检测该线程节点中的 blocked 字段（这个操作就是自旋）。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20200831111943196.png" alt=""></p><h3 id="MCS锁队列"><a href="#MCS锁队列" class="headerlink" title="MCS锁队列"></a>MCS锁队列</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MCS_Lock</span> </span>&#123;  <span class="hljs-keyword">final</span> AtomicReference&lt;Node&gt; tail = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-keyword">null</span>);  ThreadLocal&lt;Node&gt; current;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">_MCS_Lock</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.current = <span class="hljs-keyword">new</span> ThreadLocal&lt;Node&gt;() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> Node <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node();      &#125;    &#125;;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Node own = current.get();    Node preNode = tail.getAndSet(own);    <span class="hljs-keyword">if</span> (Objects.nonNull(preNode)) &#123;      preNode.next = own;      own.locked = <span class="hljs-keyword">true</span>;      <span class="hljs-keyword">while</span> (own.locked) &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始自旋....&quot;</span>);        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);      &#125;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;    Node own = current.get();    <span class="hljs-keyword">if</span> (Objects.isNull(own.next)) &#123;      <span class="hljs-comment">// CAS操作失败，说明当前节点后面新加入了节点</span>      <span class="hljs-keyword">if</span> (tail.compareAndSet(own, <span class="hljs-keyword">null</span>)) &#123;        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">// 条件不成立，执行下面的解锁流程代码</span>      <span class="hljs-keyword">while</span> (own.next == <span class="hljs-keyword">null</span>) &#123;      &#125;    &#125;    own.next.locked = <span class="hljs-keyword">false</span>;    own.next = <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">volatile</span> Node next;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> locked;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    _MCS_Lock lock = <span class="hljs-keyword">new</span> _MCS_Lock();    Runnable runnable = () -&gt; &#123;      <span class="hljs-keyword">try</span> &#123;        lock.lock();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取到了锁&quot;</span>);        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;释放到了锁&quot;</span>);        lock.unlock();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;;    <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;线程 A&quot;</span>).start();    <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;线程 B&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);    <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;线程 C&quot;</span>).start();  &#125;&#125;</code></pre></div><p>MCS 是一个真正的链表通过 <code>next</code> 字段来关联下一个线程节点，但是相对于 CLH 它的 CAS 操作多了</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/image-20200831144343389.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CLH 适用于SMP 系统架构，不适用于NUMA架构(内存分隔)，如果前一个节点的内存过远会导致性能下降。</p><p>CLH 对比 MCS: </p><p>（1）从代码实现来看，CLH比MCS要简单得多。</p><p>（2）从自旋的条件来看，CLH依靠前驱节点自旋，而MCS是依靠自身自旋。</p><p>（3）从链表队列来看，CLH的队列是隐式的，MCS的队列是物理存在的，通过 next 字段。</p><p>（4）CLH 锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。</p><p>（5）CLH 适合CPU个数不多的计算机硬件架构上，MCS则适合拥有很多CPU的硬件架构上</p><p>（6）CLH和MCS实现的自旋锁都是不可重入的</p><h2 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h2><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;  <span class="hljs-comment">// 如果tryAcquire获取失败, 且添加队列</span>  <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))    selfInterrupt();&#125;</code></pre></div><p><code>acquire</code>方法在独占模式下修改<code>同步状态</code>, 会至少调用一次<code>tryAcquire</code>方法, 如果<code>tryAcquire</code>返回<code>true</code>代表状态修改成功, 反之则尝试调用<code>acquireQueued</code>方法入队. </p><p><code>addWaiter</code>是入队操作, 而<code>acquireQueued</code>则是从队列中获取操作.</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 1. 获取到 tail 节点, 如果不为空,则调用 cas 将 node 入队</span><span class="hljs-comment">// 2. 如果为空,则调用 enq 方法初始化队列,且将 node 节点入队</span><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;  Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);  Node pred = tail;  <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;    node.prev = pred;    <span class="hljs-comment">// 入队操作</span>    <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;      pred.next = node;      <span class="hljs-keyword">return</span> node;    &#125;  &#125;  <span class="hljs-comment">// 队列为空,则进行初始化</span>  enq(node);  <span class="hljs-keyword">return</span> node;&#125;</code></pre></div><h4 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h4><p>在调用<code>addWaiter</code>进行入队操作时, 可能会出现队列为初始化的情况, 即<code>pred == null</code>.此时调用了 <code>enq</code> 来对队列进行初始化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;  <span class="hljs-keyword">for</span> (;;) &#123;    Node t = tail;    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果为空,则进行处处华</span>      <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))        tail = head;    &#125;     <span class="hljs-comment">// 不为空</span>    <span class="hljs-keyword">else</span> &#123;      node.prev = t; <span class="hljs-comment">// 先设置尾节点的前置节点,保证队列的完整性</span>      <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="hljs-comment">// 在 CAS 设置尾节点</span>        t.next = node;        <span class="hljs-keyword">return</span> t;      &#125;    &#125;  &#125;&#125;</code></pre></div><h4 id="自旋获取"><a href="#自旋获取" class="headerlink" title="自旋获取"></a>自旋获取</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 入队成功后,再次从队列中获取锁</span><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;  <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (;;) &#123;      <span class="hljs-comment">// step1: 获取到当前节点的前置节点</span>      <span class="hljs-keyword">final</span> Node p = node.predecessor();      <span class="hljs-comment">// step2: 如果前置节点是头节点,则说明前置节点已经获取到锁, 且再次调用tryAcquire方法获取锁</span>      <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;        <span class="hljs-comment">// 成功,说明前置节点已经释放了搜</span>        setHead(node);        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>        failed = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> interrupted;      &#125;      <span class="hljs-comment">// step3: 此时前置节点可能还未释放锁, 则判断是否应该阻塞当前节点</span>      <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())        interrupted = <span class="hljs-keyword">true</span>;    &#125;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span> (failed)      cancelAcquire(node);  &#125;&#125;</code></pre></div><p>在自旋时, 前置节点的状态: </p><ol><li>waitStatus=0: 说明当前节点可以继续自旋, 说不定下次自旋就能获取到锁</li><li>waitStatus&gt;0: 说明前置节点已经取消, 更新当前节点的前置节点, 并进行下次自旋</li><li>waitStatus&lt;0: 说明当前节点可以阻塞, 这个状态可能是当前节点在执行<code>shouldParkAfterFailedAcquire</code>修改的.</li></ol><h4 id="获取失败后更新状态"><a href="#获取失败后更新状态" class="headerlink" title="获取失败后更新状态"></a>获取失败后更新状态</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;  <span class="hljs-keyword">int</span> ws = pred.waitStatus;  <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) <span class="hljs-comment">// 前置状态为 SIGNAL,说明当前节点需要被唤醒, 可以安全的的被阻塞</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 返回 true,则会执行 parkAndCheckInterrupt 方法</span>  <span class="hljs-comment">// 大于 0,说明前置节点已经取消, 则从前置节点向前查找,直到遇到未取消的节点,</span>  <span class="hljs-comment">// 将当前节点的 prev 指向为取消的节点</span>  <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">do</span> &#123;      <span class="hljs-comment">// 寻找未取消的前置节点</span>      node.prev = pred = pred.prev;    &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);    <span class="hljs-comment">// 更新当前节点的 prev</span>    pred.next = node;  &#125;   <span class="hljs-comment">// 此时状态只能是 0 或 PROPAGATE, 表明当前节点需要一个唤醒信号</span>  <span class="hljs-comment">// 而 PROPAGATE 是在共享模式下使用的, CONDITION 则是在条件队列中时的状态</span>  <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 将前置节点状态更新成 SINGAL</span>    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p><strong>当前节点的唤醒是保存在前置节点中的</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;  <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;    Node h = head;    <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 头节点不为空,且状态不等于0</span>      unparkSuccessor(h);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">// 唤醒后续节点</span><span class="hljs-comment">// 回顾获取的代码, 在后续节点获取失败后可能会修改前置节点的状态(shouldParkAfterFailedAcquire方法)</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;  <span class="hljs-comment">// 如果状态为正数(可能需要唤醒)</span>  <span class="hljs-keyword">int</span> ws = node.waitStatus;  <span class="hljs-comment">// 此时waitStatus是SINGAL,</span>  <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)    compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>); <span class="hljs-comment">// 更新成 0, 利于后续节点获取锁</span>  <span class="hljs-comment">// 后继节点</span>  Node s = node.next;  <span class="hljs-comment">// 疑问: 后继节点为 null 或已取消为啥还要从尾节点开始遍历</span>  <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;    s = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 当上面判断成立时的一瞬间, 可能有新节点入队了, 这么做就是为了避免新节点的加入,而被忽略</span>    <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)      <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)        s = t;  &#125;  <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)    <span class="hljs-comment">// 解锁后继线程</span>    LockSupport.unpark(s.thread);&#125;</code></pre></div><h4 id="后继节点状态"><a href="#后继节点状态" class="headerlink" title="后继节点状态"></a>后继节点状态</h4><p>在执行释放时, 后继节点可能处于以下几种状态:</p><ol><li>已经阻塞.</li><li>还在<code>acquireQueued</code>方法中执行自旋,还未阻塞.</li><li>已经取消.</li></ol><h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><p>在<code>unparkSuccessor</code>中将当前节点的状态更新成了 0</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)    compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);</code></pre></div><p>而后继节点在获取失败后可能在执行 spaf 将前置节点置为 SIGNAL</p><div class="code-wrapper"><pre><code class="hljs java">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</code></pre></div><p><strong>为什么这是个优化操作呢?</strong></p><p>假设队列 : <code>A -&gt; B -&gt; C</code></p><p>假设 B 已经自旋了一次(获取失败), 调用<code>spaf</code>方法将 A 的状态设置成了 SIGNAL, 进行下一次自旋, 此时 A 会有两种操作:</p><ol><li>调用release方法, 此时 A 的状态会变成 0, B 在下一次自旋后发现 A 的状态变成了 0, 则会继续自旋</li><li>未调用release方法, 此时 A 的状态还是 SIGNAL(被 B 修改的), 此时 B 在下一次自旋后就可以被阻塞了</li></ol><p>这样可以加速锁的获取, 避免了一次没必要的 park. </p><h3 id="取消获取"><a href="#取消获取" class="headerlink" title="取消获取"></a>取消获取</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelAcquire</span><span class="hljs-params">(Node node)</span> </span>&#123;  <span class="hljs-comment">// 为空忽略</span>  <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span>;  node.thread = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 线程置为空</span><span class="hljs-comment">// 跳过取消的节点</span>  Node pred = node.prev;  <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)    node.prev = pred = pred.prev;<span class="hljs-comment">// 获取点未取消前置节点的前置节点</span>  Node predNext = pred.next;<span class="hljs-comment">// 修改 ws</span>  node.waitStatus = Node.CANCELLED;<span class="hljs-comment">// 如果是尾节点,则直接 CAS 更新</span>  <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;    compareAndSetNext(pred, predNext, <span class="hljs-keyword">null</span>);  &#125;   <span class="hljs-comment">// 非尾节点</span>  <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span>    <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span>    <span class="hljs-keyword">int</span> ws;    <span class="hljs-keyword">if</span> (pred != head &amp;&amp;  <span class="hljs-comment">// 前置节点不是头节点</span>        ((ws = pred.waitStatus) == Node.SIGNAL || <span class="hljs-comment">// pred.ws = SIGNAL</span>         (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; <span class="hljs-comment">// </span>        pred.thread != <span class="hljs-keyword">null</span>) &#123;            Node next = node.next; <span class="hljs-comment">// 获取当前节点的后继节点</span>      <span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// 后继节点有效</span>        compareAndSetNext(pred, predNext, next); <span class="hljs-comment">// 将 pred 前置节点的 next 修改成 node.next</span>    &#125;     <span class="hljs-comment">// 1. pred 为头节点s</span>    <span class="hljs-keyword">else</span> &#123;      unparkSuccessor(node);  <span class="hljs-comment">// 解锁后继者</span>    &#125;    node.next = node; <span class="hljs-comment">// help GC</span>  &#125;&#125;</code></pre></div><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h2 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h2><p>共享模式下的<code>获取</code>和<code>释放</code>和独占模式有一些区别, 共享模式下,锁是可以被多个线程锁持有的.</p><p>下面的会涉及到源代码的分析, 再看每行代码时, 都要记住一点:<code>所有的方法都有可能并发执行</code></p><h3 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;  <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)    doAcquireShared(arg);&#125;</code></pre></div><p><code>tryAcquireShared</code>返回值有以下几种情况:</p><ul><li><code>&lt;0</code>: 表示获取失败</li><li><code>=0</code>:表示获取成功,但是后继节点不能获取成功</li><li><code>&gt;0</code>:表示获取成功</li></ul><h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a><code>doAcquireShared</code></h4><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 执行共享获取操作</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;  <span class="hljs-comment">// step1: 入队</span>  <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);  <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (;;) &#123;      <span class="hljs-comment">// step2: 前继节点</span>      <span class="hljs-keyword">final</span> Node p = node.predecessor();      <span class="hljs-keyword">if</span> (p == head) &#123;        <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);        <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// step2.1: 设置头节点并传播</span>          setHeadAndPropagate(node, r);        &#125;<span class="hljs-comment">// 忽略部分代码</span>      &#125;<span class="hljs-comment">// step3: 修改当前节点状态,并根据状态阻塞</span>      <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())        interrupted = <span class="hljs-keyword">true</span>;    &#125;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span> (failed)      cancelAcquire(node);  &#125;&#125;</code></pre></div><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol><li>调用<code>addWaiter</code>进行入队操作, 只不过是共享模式</li><li>判断前置节点是否是头节点<ol><li>是头节点:  再次尝试获取, 如果成功, 调用<code>setHeadAndPropagate</code>方法传播, 反之执行步骤 3</li><li>非头节点:  执行步骤 3</li></ol></li><li>获取失败后, 根据前置节点状态 判断是否应该阻塞当前节点</li></ol><h5 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a><code>setHeadAndPropagate</code></h5><p>我们知道只要当当前节点的前继节点为头节点且再次 <code>tryAcquireShared</code> 成功后再回执行 <code>shp</code> 方法</p><p>注意: shp 是<code>setHeadAndPropagate</code>方法的简称</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// propagate 为 tryAcquireShared 的返回值</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;  Node h = head;   setHead(node);  <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||      (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;    Node s = node.next;  <span class="hljs-comment">// 获取后继节点</span>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())  <span class="hljs-comment">// 如果处于共享模式</span>      doReleaseShared();<span class="hljs-comment">// 执行释放操作</span>  &#125;&#125;</code></pre></div><p>调用 <code>setHead</code> 方法后, 此前的 <code>head</code> 已经不在队列中了</p><p>如果 node.next 不为空且处于共享模式, 调用 <code>doReleaseShared()</code> 方法, 此方法在 <code>releaseShared</code> 会一起讲解</p><h3 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h3><h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;  <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;    doReleaseShared();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p>可以看到在调用了<code>tryReleaseShared</code>方法后,如果成功则会调用<code>doReleaseShared</code>, 这和上面<code>共享获取</code>时<code>setHeadAndPropagate</code>方法中调用的方法是一致的.</p><h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a><code>doReleaseShared</code></h4><p>此时我们知道在 <code>acquireShared</code> 和 <code>releaseShared</code> 中都会调用此方法, 该方法至少会被一个节点调用两次.</p><p>在分析这个方法前, 假设现在有三个节点为别是: <code>A, B, C</code> 且假设入队顺序是 <code>A -&gt; B -&gt; C</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 如果需要信号, 头节点通常将会以这种方式唤醒后继节点, 如果没有则将状态更新为PROPAGATE,以确保传播</span>  <span class="hljs-comment">// 此外，在执行此操作时，必须循环以防添加新节点。</span>  <span class="hljs-keyword">for</span> (;;) &#123;    Node h = head;    <span class="hljs-comment">// 该判断只能保证在此时此刻队列中至少有两个节点, 可能在执行下面的代码中,队列从可能就只有一个节点了</span>    <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;      <span class="hljs-keyword">int</span> ws = h.waitStatus;      <span class="hljs-comment">// 疑问:A.ws为什么是 SIGNAL</span>      <span class="hljs-comment">// A 成为头节点, B 获取锁失败在执行 spaf 方法时修改</span>      <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;        <span class="hljs-comment">// 疑问: 为什么会更新失败? </span>        <span class="hljs-comment">// B 在执行完 spaf 方法可能没阻塞, 再次自旋获取到锁了, 并成为了头节点, 所以造成此时A执行CAS失败</span>        <span class="hljs-comment">// 更新成 0 是为了加速后续节点在执行 spaf 后不被阻塞</span>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>)) &#123;          <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 解锁后继者</span>        unparkSuccessor(h);      &#125;      <span class="hljs-comment">// 后继节点不需要信号,则更新状态为PROPAGATE, 失败则自旋</span>      <span class="hljs-comment">// 疑问: 什么情况会进入此 else if</span>      <span class="hljs-comment">// A刚成为头节点(默认为 0), B执行 spaf 还未将 A.ws修改成 SIGNAL 此时 A 会进入 else if</span>      <span class="hljs-comment">// 疑问: compareAndSetWaitStatus(h, 0, Node.PROPAGATE)为什么失败?</span>      <span class="hljs-comment">// 当 ws==0 成立时,此时 B 在 spaf 将 A.ws 修改了 SIGNAL, 所以会失败</span>      <span class="hljs-comment">// 注意: 这个 else if 主要就是处理并预防有新节点加入</span>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))        <span class="hljs-keyword">continue</span>;    &#125;<span class="hljs-comment">// 执行此判断的条件, 成功调用unparkSuccessor方法或队列中没有两个节点</span>    <span class="hljs-keyword">if</span> (h == head)      <span class="hljs-keyword">break</span>;  &#125;&#125;</code></pre></div><h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a><code>unparkSuccessor</code></h4><p>解锁后继线程, 该方法只有在 CAS 将 head.ws修改成 0 成功时才会执行</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;  <span class="hljs-comment">/*</span><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><span class="hljs-comment">     */</span>  <span class="hljs-keyword">int</span> ws = node.waitStatus;  <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 疑问: 为什么要将 ws 更新成 0</span>    <span class="hljs-comment">// 后继线程在执行完 shp 没有被阻塞, 继续执行下次自旋, </span>    <span class="hljs-comment">// 下次在执行 shp 时后继节点发现前置节点的 ws改变了, 继续自旋, 避免了阻塞</span>    compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 跳过取消节点</span>  Node s = node.next;  <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;    s = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)      <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)        s = t;  &#125;  <span class="hljs-comment">// 不为空</span>  <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)    <span class="hljs-comment">// 解锁线程, 则后继节点继续自旋, 获取锁</span>    LockSupport.unpark(s.thread);&#125;</code></pre></div><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>至此 AQS 中独占和共享模式下的 acquire 和 release 操作的细节都已分析完毕, 了解 AQS 对学习JUC 包下的类非常有帮助, 如果看完本章还有疑惑, 可以查看一下其它博客. </p><p><a href="https://cloud.tencent.com/developer/article/1187386">CLH 锁</a></p><p><a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">同步框架说明文档</a></p><p><a href="https://www.cnblogs.com/micrari/p/6937995.html">AQS讲解</a></p><p><a href="https://segmentfault.com/a/1190000016447307">AQS讲解</a></p>]]></content>
    
    
    <categories>
      
      <category>Juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Juc</tag>
      
      <tag>Aqs</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins Pipeline</title>
    <link href="/2020/10/09/jenkins/01-jenkins-introduction/"/>
    <url>/2020/10/09/jenkins/01-jenkins-introduction/</url>
    
    <content type="html"><![CDATA[<p>该文章主要Jenkins Pipeline的使用</p><span id="more"></span><h2 id="Jenkins-Pipeline"><a href="#Jenkins-Pipeline" class="headerlink" title="Jenkins-Pipeline"></a>Jenkins-Pipeline</h2><h3 id="Pipeline-Block"><a href="#Pipeline-Block" class="headerlink" title="Pipeline Block"></a>Pipeline Block</h3><blockquote><p>所有有效的声明式流水线必须包含在一个 <code>pipeline</code>块中</p><div class="code-wrapper"><pre><code class="hljs groovy">pipeline &#123;  &#125;</code></pre></div><p>遵循Groovy语法。</p><p>特点：</p><ol><li>流水线顶层必须是一个 <code>pipeline&#123;&#125;</code>。</li><li>没有分号作为语句分隔符，每条语句都必须在自己的行上。</li><li>块只能由<code>节段，指令，步骤或赋值语句</code>组成。 *属性引用语句被视为无参方法调用。例如：input被视为input()。</li></ol></blockquote><h3 id="Agent-Block"><a href="#Agent-Block" class="headerlink" title="Agent Block"></a>Agent Block</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p><code>agent</code> 部分指定了整个流水线或特定的部分, 将会在Jenkins环境中执行的位置，这取决于 <code>agent</code> 区域的位置。</p><p>该部分必须在 <code>pipeline</code> 块的顶层被定义, 但是 stage 级别的使用是可选的。</p></blockquote><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><blockquote><p><code>any</code>：在任何可用的代理上执行流水线或阶段。例如: <code>agent any</code></p><p><code>label</code>：在提供了标签的 Jenkins 环境中可用的代理上执行流水线或阶段。 例如: <code>agent &#123; label &#39;node-1&#39; &#125;</code></p><p><code>node</code>： <code>agent &#123; node &#123; label &#39;labelName&#39; &#125; &#125;</code> 和 <code>agent &#123; label &#39;labelName&#39; &#125;</code> 一样, 但是 <code>node</code> 允许额外的选项 (比如 <code>customWorkspace</code> )。</p></blockquote><h3 id="Post-Block"><a href="#Post-Block" class="headerlink" title="Post Block"></a>Post Block</h3><blockquote><p><code>post</code> 部分定义一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps">steps</a> ，这些阶段根据流水线或阶段的完成情况而运行(取决于流水线中 <code>post</code> 部分的位置)。</p><p><code>post</code>支持<code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code>, <code>unstable</code>, 和 <code>aborted</code>块中任意一个。</p><p>这些条件块允许在 <code>post</code> 部分的步骤的执行取决于流水线或阶段的完成状态。</p></blockquote><h4 id="块对应的条件"><a href="#块对应的条件" class="headerlink" title="块对应的条件"></a>块对应的条件</h4><blockquote><p><code>always</code>:无论流水线或阶段的完成状态如何，都允许在 <code>post</code> 部分运行该步骤。</p><p><code>changed</code>:当前流水线或阶段的完成状态与它之前的运行不同时，才能执行。</p><p><code>failure</code>:当前流水线或阶段的完成状态为”failure”，才能执行,。</p><p><code>success</code>:当前流水线或阶段的完成状态为”success”，才能执行。</p><p><code>unstable</code>:当前流水线或阶段的完成状态为”unstable”，才能执行, 通常由于测试失败,代码违规等造成。通常web UI是黄色。</p><p><code>aborted</code>:当前流水线或阶段的完成状态为”aborted”，才能执行, 通常由于流水线被手动的aborted。通常web UI是灰色。</p></blockquote><h3 id="Stages-块"><a href="#Stages-块" class="headerlink" title="Stages 块"></a>Stages 块</h3><blockquote><p>包含一系列一个或多个 <a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#stage">stage</a> 指令, <code>stages</code> 部分是流水线描述的大部分”工作” 的位置。</p></blockquote><div class="code-wrapper"><pre><code class="hljs groovy">pipeline &#123;    agent any    stages &#123;         stage(<span class="hljs-string">&#x27;Example&#x27;</span>) &#123;            steps &#123;                echo <span class="hljs-string">&#x27;Hello World&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="Steps块"><a href="#Steps块" class="headerlink" title="Steps块"></a>Steps块</h3><blockquote><p><code>steps</code> 部分在给定的 <code>stage</code> 指令中执行的定义了一系列的一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps">steps</a></p></blockquote><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><blockquote><p><code>environment</code> 指令制定一个 键-值对序列，该序列将被定义为所有步骤的环境变量，或者是特定于阶段的步骤， 这取决于 <code>environment</code> 指令在流水线内的位置。</p><p>该指令支持一个特殊的助手方法 <code>credentials()</code> ，该方法可用于在Jenkins环境中通过标识符访问预定义的凭证。</p></blockquote><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><blockquote><p><code>options</code> 指令允许从流水线内部配置特定于流水线的选项。</p></blockquote><h5 id="可用选项"><a href="#可用选项" class="headerlink" title="可用选项"></a>可用选项</h5><ul><li><p>buildDiscarder</p><p>为最近的流水线运行的特定数量保存组件和控制台输出。例如: <code>options &#123; buildDiscarder(logRotator(numToKeepStr: &#39;1&#39;)) &#125;</code></p></li><li><p>disableConcurrentBuilds</p><p>不允许同时执行流水线。 可被用来防止同时访问共享资源等。 例如: <code>options &#123; disableConcurrentBuilds() &#125;</code></p></li><li><p>overrideIndexTriggers</p><p>允许覆盖分支索引触发器的默认处理。 如果分支索引触发器在多分支或组织标签中禁用, <code>options &#123; overrideIndexTriggers(true) &#125;</code> 将只允许它们用于促工作。否则, <code>options &#123; overrideIndexTriggers(false) &#125;</code> 只会禁用改作业的分支索引触发器。</p></li><li><p>skipDefaultCheckout</p><p>在<code>agent</code> 指令中，跳过从源代码控制中检出代码的默认情况。例如: <code>options &#123; skipDefaultCheckout() &#125;</code></p></li><li><p>skipStagesAfterUnstable</p><p>一旦构建状态变得UNSTABLE，跳过该阶段。例如: <code>options &#123; skipStagesAfterUnstable() &#125;</code></p></li><li><p>checkoutToSubdirectory</p><p>在工作空间的子目录中自动地执行源代码控制检出。例如: <code>options &#123; checkoutToSubdirectory(&#39;foo&#39;) &#125;</code></p></li><li><p>timeout</p><p>设置流水线运行的超时时间, 在此之后，Jenkins将中止流水线。例如: <code>options &#123; timeout(time: 1, unit: &#39;HOURS&#39;) &#125;</code></p></li><li><p>retry</p><p>在失败时, 重新尝试整个流水线的指定次数。 For example: <code>options &#123; retry(3) &#125;</code></p></li><li><p>timestamps</p><p>预谋所有由流水线生成的控制台输出，与该流水线发出的时间一致。 例如: <code>options &#123; timestamps() &#125;</code></p></li></ul><h5 id="可选的阶段选项"><a href="#可选的阶段选项" class="headerlink" title="可选的阶段选项"></a>可选的阶段选项</h5><ul><li><p>skipDefaultCheckout</p><p>在 <code>agent</code> 指令中跳过默认的从源代码控制中检出代码。例如: <code>options &#123; skipDefaultCheckout() &#125;</code></p></li><li><p>timeout</p><p>设置此阶段的超时时间, 在此之后， Jenkins 会终止该阶段。 例如: <code>options &#123; timeout(time: 1, unit: &#39;HOURS&#39;) &#125;</code></p></li><li><p>retry</p><p>在失败时, 重试此阶段指定次数。 例如: <code>options &#123; retry(3) &#125;</code></p></li><li><p>timestamps</p><p>预谋此阶段生成的所有控制台输出以及该行发出的时间一致。例如: <code>options &#123; timestamps() &#125;</code></p></li></ul><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><blockquote><p>定义自动安装和放置 <code>PATH</code> 的工具的一部分。</p></blockquote><div class="code-wrapper"><pre><code class="hljs groovy">pipeline &#123;    agent any    tools &#123;        maven <span class="hljs-string">&#x27;apache-maven-3.0.1&#x27;</span>     &#125;    stages &#123;        stage(<span class="hljs-string">&#x27;Example&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;mvn --version&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs groovy">when &#123;branch <span class="hljs-string">&#x27;development&#x27;</span>&#125;</code></pre></div><p>when 用于判断</p><div class="code-wrapper"><pre><code class="hljs groovy">pipeline &#123;  agent any  stages &#123;    stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;      steps &#123;        <span class="hljs-comment">/* `make check` 在测试失败后返回非零的退出码；</span><span class="hljs-comment">         * 使用 `true` 允许流水线继续进行</span><span class="hljs-comment">         */</span>        sh <span class="hljs-string">&#x27;make check || true&#x27;</span>         junit <span class="hljs-string">&#x27;**/target/*.xml&#x27;</span>       &#125;    &#125;  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs groovy">choice(  <span class="hljs-symbol">description:</span> <span class="hljs-string">&#x27;Run flyway database migration using latest master branch from prices in what environment?&#x27;</span>,  <span class="hljs-symbol">name:</span> <span class="hljs-string">&#x27;environment&#x27;</span>,  <span class="hljs-symbol">choices:</span> [<span class="hljs-string">&#x27;PRE&#x27;</span>, <span class="hljs-string">&#x27;PRO&#x27;</span>])</code></pre></div><p>input</p><div class="code-wrapper"><pre><code class="hljs groovy">input &#123;  message <span class="hljs-string">&quot;是否继续?&quot;</span>  ok <span class="hljs-string">&quot;发布 &quot;</span>  submitter <span class="hljs-string">&quot;alice,bob&quot;</span>  parameters &#123;    string(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;IP&#x27;</span>, <span class="hljs-attr">defaultValue:</span> <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;线上节点 1&#x27;</span>)  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sh">nohup java -jar -Dspring.profiles.active=prod /data/jars/admin-io-better-cn-api/master/admin-io-better-cn-api-master.jar &gt;/data/nohup.out 2&gt;&amp;1 &amp;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sh">ps -ef |grep java|grep admin-io-better-cn-api-master.jar|grep prod|grep -v grep|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span></code></pre></div><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote><p>BUILD_ID</p><p>当前构建的 ID，与 Jenkins 版本 1.597+ 中创建的构建号 BUILD_NUMBER 是完全相同的。</p><p>BUILD_NUMBER</p><p>当前构建号，比如 “153”。</p><p>BUILD_TAG</p><p>字符串 <code>jenkins-$&#123;JOB_NAME&#125;-$&#123;BUILD_NUMBER&#125;</code>。可以放到源代码、jar 等文件中便于识别。</p><p>BUILD_URL</p><p>可以定位此次构建结果的 URL（比如 <a href="http://buildserver/jenkins/job/MyJobName/17/">http://buildserver/jenkins/job/MyJobName/17/</a> ）</p><p>EXECUTOR_NUMBER</p><p>用于识别执行当前构建的执行者的唯一编号（在同一台机器的所有执行者中）。这个就是你在“构建执行状态”中看到的编号，只不过编号从 0 开始，而不是 1。</p><p>JAVA_HOME</p><p>如果你的任务配置了使用特定的一个 JDK，那么这个变量就被设置为此 JDK 的 JAVA_HOME。当设置了此变量时，PATH 也将包括 JAVA_HOME 的 bin 子目录。</p><p>JENKINS_URL</p><p>Jenkins 服务器的完整 URL，比如 <a href="https://example.com:port/jenkins/">https://example.com:port/jenkins/</a> （注意：只有在“系统设置”中设置了 Jenkins URL 才可用）。</p><p>JOB_NAME</p><p>本次构建的项目名称，如 “foo” 或 “foo/bar”。</p><p>NODE_NAME</p><p>运行本次构建的节点名称。对于 master 节点则为 “master”。</p><p>WORKSPACE</p><p>workspace 的绝对路径。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI</tag>
      
      <tag>Jenkins</tag>
      
      <tag>Pipeline</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-Bean定义</title>
    <link href="/2020/05/09/spring/03-spring-bean-definition/"/>
    <url>/2020/05/09/spring/03-spring-bean-definition/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-BeanDefinition"><a href="#Ioc-BeanDefinition" class="headerlink" title="Ioc-BeanDefinition"></a>Ioc-BeanDefinition</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><p>本文主要讲述BeanDefinition的作用，以及BeanDefinition子接口或实现类的使用和介绍。</p><p>不会涉及BeanDefinitionReader（读取生成BeanDefinition）和BeanDefinitionRegistry（注册BeanDefinition）相关的东西，只关注BeanDefinition本身的东西。</p></blockquote><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>BeanDefinition描述了一个bean实例，该实例具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p><p>BeanDefinition主要是用来描述Bean，里面存放Bean元数据：比如<code>Bean类名、scope、属性、构造函数参数列表、依赖的Bean、是否是单例类、是否是懒加载</code>等一些列信息。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180454.png" alt="image-20200513192525817" style="zoom:50%;" /><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeAccessor</span>, <span class="hljs-title">BeanMetadataElement</span> </span>&#123;<span class="hljs-comment">// 设置Bean实例在Ioc中的名称</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBeanClassName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanClassName)</span></span>;  <span class="hljs-function">String <span class="hljs-title">getBeanClassName</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置是否单例</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setScope</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String scope)</span></span>;  <span class="hljs-function">String <span class="hljs-title">getScope</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置是否懒加载</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLazyInit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> lazyInit)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isLazyInit</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置当前Bean依赖的Bean</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDependsOn</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String... dependsOn)</span></span>;  String[] getDependsOn();  <span class="hljs-comment">// 当前Bean是否是唯一</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPrimary</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> primary)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimary</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回此bean的构造函数参数值。</span>  <span class="hljs-comment">// ConstructorArgumentValues包装了当前Bean的构造函数参数值</span>  <span class="hljs-function">ConstructorArgumentValues <span class="hljs-title">getConstructorArgumentValues</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 返回要应用到Bean的新实例的属性值。</span>  <span class="hljs-comment">// MutablePropertyValues包装了当前Bean的属性值</span>  <span class="hljs-function">MutablePropertyValues <span class="hljs-title">getPropertyValues</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置自定义初始化方法</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInitMethodName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String initMethodName)</span></span>;  <span class="hljs-function">String <span class="hljs-title">getInitMethodName</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 设置自定义销毁方法</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDestroyMethodName</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String destroyMethodName)</span></span>;  <span class="hljs-function">String <span class="hljs-title">getDestroyMethodName</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 是否单例</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 是否多例</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 是否抽象</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAbstract</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回原始的BeanDefinition；如果没有，则返回null。 允许获取修饰的bean定义（如果有）。</span>  <span class="hljs-comment">// 请注意，此方法返回直接发起者。 遍历发起者链以找到用户定义的原始BeanDefinition。</span>  <span class="hljs-function">BeanDefinition <span class="hljs-title">getOriginatingBeanDefinition</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>代码中BeanDefinition继承了<code>AttributeAccessor</code>, <code>BeanMetadataElement</code>两接口，让我们来看一下这两个接口。</p><h3 id="BeanMetadataElement"><a href="#BeanMetadataElement" class="headerlink" title="BeanMetadataElement"></a><code>BeanMetadataElement</code></h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanMetadataElement</span> </span>&#123;  <span class="hljs-comment">// 返回此元数据元素的配置源Object（可以为null）。</span>  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">getSource</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;&#125;</code></pre></div><h3 id="AttributeAccessor"><a href="#AttributeAccessor" class="headerlink" title="AttributeAccessor"></a><code>AttributeAccessor</code></h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 定义用于将元数据附加到任意对象或从任意对象访问元数据的通用协定的接口。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeAccessor</span> </span>&#123;  <span class="hljs-comment">// 将名称定义的属性设置为提供的值。 如果value为null，则删除该属性。</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Object value)</span></span>;<span class="hljs-comment">// 获取由名称标识的属性的值。 如果属性不存在，则返回null。</span>  <span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(String name)</span></span>;  <span class="hljs-comment">// 删除由名称标识的属性的值。 如果属性不存在，则返回null。</span>  <span class="hljs-function">Object <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String name)</span></span>;  <span class="hljs-comment">// 存在由名称标识的属性的值返回true，否则返回false</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttribute</span><span class="hljs-params">(String name)</span></span>;<span class="hljs-comment">// 返回所有属性的名称。</span>  String[] attributeNames();&#125;</code></pre></div><h3 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a><code>AbstractBeanDefinition</code></h3><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>AbstractBeanDefinition是BeanDefinition最完整的实现，内部提供了大量的的属性字段来封装Bean的元数据信息。</p><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanMetadataAttributeAccessor</span></span><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinition</span>, <span class="hljs-title">Cloneable</span> </span>&#123;<span class="hljs-comment">// 忽略部分常量</span><span class="hljs-comment">// 属性字段</span>  <span class="hljs-comment">// BeanDefinition对应的Class</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Object beanClass;  <span class="hljs-keyword">private</span> String scope = SCOPE_DEFAULT;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> abstractFlag = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">private</span> Boolean lazyInit; <span class="hljs-comment">// 是否懒加载</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> autowireMode = AUTOWIRE_NO;   <span class="hljs-comment">// 自动注入模式</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> dependencyCheck = DEPENDENCY_CHECK_NONE;  <span class="hljs-comment">// 依赖检查</span>  <span class="hljs-keyword">private</span> String[] dependsOn;<span class="hljs-comment">// 依赖</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> autowireCandidate = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> primary = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();  <span class="hljs-keyword">private</span> Supplier&lt;?&gt; instanceSupplier;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> nonPublicAccessAllowed = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> lenientConstructorResolution = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> String factoryBeanName;  <span class="hljs-keyword">private</span> String factoryMethodName;  <span class="hljs-keyword">private</span> ConstructorArgumentValues constructorArgumentValues;  <span class="hljs-comment">// 构造函数参数</span>  <span class="hljs-keyword">private</span> MutablePropertyValues propertyValues;<span class="hljs-comment">// 属性参数</span>  <span class="hljs-keyword">private</span> MethodOverrides methodOverrides = <span class="hljs-keyword">new</span> MethodOverrides();  <span class="hljs-keyword">private</span> String initMethodName;  <span class="hljs-keyword">private</span> String destroyMethodName;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enforceInitMethod = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enforceDestroyMethod = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> synthetic = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> role = BeanDefinition.ROLE_APPLICATION;  <span class="hljs-keyword">private</span> String description;  <span class="hljs-keyword">private</span> Resource resource;    <span class="hljs-comment">// 忽略属性get/set方法</span>    <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> cloneBeanDefinition();&#125;<span class="hljs-comment">// 克隆BeanDefinition</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractBeanDefinition <span class="hljs-title">cloneBeanDefinition</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h4 id="GenericBeanDefinition"><a href="#GenericBeanDefinition" class="headerlink" title="GenericBeanDefinition"></a><code>GenericBeanDefinition</code></h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>GenericBeanDefinition是一站式的用于标准bean定义。 像任何bean定义一样，它允许指定一个类以及可选的构造函数参数值和属性值。通过其<code>parentName</code>属性灵活的指定父BeanDefinition。</p><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanDefinition</span> </span>&#123;  <span class="hljs-meta">@Nullable</span>  <span class="hljs-keyword">private</span> String parentName;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericBeanDefinition</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericBeanDefinition</span><span class="hljs-params">(BeanDefinition original)</span> </span>&#123;    <span class="hljs-keyword">super</span>(original);  &#125;  <span class="hljs-comment">// 实现克隆BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">cloneBeanDefinition</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GenericBeanDefinition(<span class="hljs-keyword">this</span>);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object other)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == other) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span> (!(other <span class="hljs-keyword">instanceof</span> GenericBeanDefinition)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    GenericBeanDefinition that = (GenericBeanDefinition) other;    <span class="hljs-keyword">return</span> (ObjectUtils.nullSafeEquals(<span class="hljs-keyword">this</span>.parentName, that.parentName) &amp;&amp; <span class="hljs-keyword">super</span>.equals(other));  &#125;&#125;</code></pre></div><p>可以看出GenericBeanDefinition继承了AbstractBeanDefinition类，新增了一个<code>parentName</code>属性。GenericBeanDefinition因为这个属性可以动态定义父依赖项，而不是将角色“硬编码”为根bean定义。</p><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGenericBeanDefinition</span><span class="hljs-params">()</span> </span>&#123;  AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();  GenericBeanDefinition parentBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();  parentBeanDefinition.setBeanClass(IocParentBean.class);  parentBeanDefinition.setBeanClassName(IocParentBean.class.getName());  parentBeanDefinition.setInitMethodName(<span class="hljs-string">&quot;init&quot;</span>);  applicationContext.registerBeanDefinition(<span class="hljs-string">&quot;iocParentBean&quot;</span>, parentBeanDefinition);  GenericBeanDefinition childBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();  childBeanDefinition.setBeanClass(IocBean.class);  childBeanDefinition.setParentName(parentBeanDefinition.getBeanClassName());  applicationContext.registerBeanDefinition(<span class="hljs-string">&quot;iocBean&quot;</span>, childBeanDefinition);  System.out.println(applicationContext.getBeanDefinition(<span class="hljs-string">&quot;iocParentBean&quot;</span>));  System.out.println(applicationContext.getBeanDefinition(<span class="hljs-string">&quot;iocBean&quot;</span>));&#125;</code></pre></div><h5 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h5><div class="code-wrapper"><pre><code class="hljs txt">Generic bean: class [io.better.spring.ioc.IocParentBean]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=init; destroyMethodName=null Generic bean with parent &#x27;io.better.spring.ioc.IocParentBean&#x27;: class [io.better.spring.ioc.IocBean]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null</code></pre></div><h4 id="RootBeanDefinition"><a href="#RootBeanDefinition" class="headerlink" title="RootBeanDefinition"></a><code>RootBeanDefinition</code></h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>一个RooBeanDefinition表示合并的BeanDefinition，该定义在运行时支持Spring BeanFactory中的特定bean。它可能是由多个相互继承的原始bean定义创建的，通常定义为GenericBeanDefinitions。<code>RootBeanDefinition</code>本质上是运行时的 “统一” BeanDefinition 视图。</p><p>但是，从Spring 2.5开始，以编程方式注册bean定义的首选方法是GenericBeanDefinition类。</p><h5 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanDefinition</span> </span>&#123;<span class="hljs-comment">// BeanDefinitionHolder存储有Bean的名称、别名、BeanDefinition</span>  <span class="hljs-keyword">private</span> BeanDefinitionHolder decoratedDefinition;  <span class="hljs-comment">// AnnotatedElement表示此VM中当前正在运行的程序的带注释元素。方便使用反射读取注释信息</span>  <span class="hljs-keyword">private</span> AnnotatedElement qualifiedElement;  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stale; <span class="hljs-comment">// 确定是否需要重新合并定义</span>  <span class="hljs-keyword">boolean</span> allowCaching = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">boolean</span> isFactoryMethodUnique = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">volatile</span> ResolvableType targetType;  <span class="hljs-keyword">volatile</span> Class&lt;?&gt; resolvedTargetType; <span class="hljs-comment">// 缓存给定BeanDefinition的对应的Class。</span>  <span class="hljs-keyword">volatile</span> Boolean isFactoryBean; <span class="hljs-comment">// 如果该bean是工厂bean，则进行缓存。</span>  <span class="hljs-keyword">volatile</span> ResolvableType factoryMethodReturnType;<span class="hljs-comment">// 缓存通用类型的工厂方法的返回类型。</span>  <span class="hljs-keyword">volatile</span> Method factoryMethodToIntrospect;  <span class="hljs-comment">// 缓存用于自省的唯一工厂方法候选。</span>    <span class="hljs-keyword">final</span> Object constructorArgumentLock = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">// 以下四个构造函数字段的通用锁。</span>  Executable resolvedConstructorOrFactoryMethod; <span class="hljs-comment">// 缓存已解析的构造函数或工厂方法</span>  <span class="hljs-keyword">boolean</span> constructorArgumentsResolved = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 将构造函数参数标记为已解析。</span>  Object[] resolvedConstructorArguments; <span class="hljs-comment">// 构造函数解析的参数数组</span>  Object[] preparedConstructorArguments;  <span class="hljs-comment">// 缓存部分准备好的构造函数参数。</span>  <span class="hljs-keyword">final</span> Object postProcessingLock = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">// 以下两个后处理字段的通用锁</span>  <span class="hljs-keyword">boolean</span> postProcessed = <span class="hljs-keyword">false</span>;  <span class="hljs-comment">// 指示是否应用MergedBeanDefinitionPostProcessor</span>  <span class="hljs-keyword">volatile</span> Boolean beforeInstantiationResolved;  <span class="hljs-comment">// 表示实例化之前的后处理器已启动</span>  <span class="hljs-keyword">private</span> Set&lt;Member&gt; externallyManagedConfigMembers;  <span class="hljs-keyword">private</span> Set&lt;String&gt; externallyManagedInitMethods;  <span class="hljs-keyword">private</span> Set&lt;String&gt; externallyManagedDestroyMethods;&#125;</code></pre></div><p>RootBeanDefiniiton保存了以下信息：</p><ol><li>持有的BeanDefinitionHolder定义了id、别名与Bean的对应关系。</li><li>AnnotatedElement获取Bean的注解信息。</li><li>具体的工厂方法（Class类型），包括工厂方法的返回类型，工厂方法的Method对象</li><li>缓存了构造函数、构造函数参数。</li></ol><h4 id="ChildBeanDefinition"><a href="#ChildBeanDefinition" class="headerlink" title="ChildBeanDefinition"></a><code>ChildBeanDefinition</code></h4><p>从其父级继承设置的Bean的BeanDefinition。ChildBeanDefinition对父beanDefinition有固定的依赖性。ChildBeanDefinition将从父对象继承构造函数参数值，属性值和方法替代，并可以选择添加新值。如果指定了init方法，destroy方法和/或静态工厂方法，则它们将覆盖相应的父设置。其余设置将始终从子定义中获取：取决于，自动装配模式，依赖项检查，单例，懒加载。</p><p>从Spring 2.5开始，以编程方式注册Bean定义的首选方法是GenericBeanDefinition类。</p><hr><h3 id="AnnotatedBeanDefinition"><a href="#AnnotatedBeanDefinition" class="headerlink" title="AnnotatedBeanDefinition"></a><code>AnnotatedBeanDefinition</code></h3><p>AnnotatedBeanDefinition扩展了BeanDefinition，可向外暴露Bean的<code>AnnotationMetadata</code>信息，无需加载Bean。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnnotatedBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanDefinition</span> </span>&#123;<span class="hljs-comment">// 返回Bean的注解元数据信息</span>  <span class="hljs-function">AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 获取此bean定义的factory方法的元数据（如果有）</span>  <span class="hljs-function">MethodMetadata <span class="hljs-title">getFactoryMethodMetadata</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h4 id="ScannedGenericBeanDefinition"><a href="#ScannedGenericBeanDefinition" class="headerlink" title="ScannedGenericBeanDefinition"></a><code>ScannedGenericBeanDefinition</code></h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>基于ASM ClassReader的GenericBeanDefinition类的扩展，支持通过AnnotatedBeanDefinition接口公开的注解元数据。此类不会尽早加载Bean类。而是从ASM ClassReader解析的“ .class”文件本身中检索所有相关的元数据。</p><p>它在功能上等效于AnnotatedGenericBeanDefinition.AnnotatedGenericBeanDefinition（AnnotationMetadata），但按类型区分已扫描的bean和已通过其他方式注册或检测的bean。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScannedGenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotatedBeanDefinition</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata metadata;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScannedGenericBeanDefinition</span><span class="hljs-params">(MetadataReader metadataReader)</span> </span>&#123;    Assert.notNull(metadataReader, <span class="hljs-string">&quot;MetadataReader must not be null&quot;</span>);    <span class="hljs-comment">// 获取到注解元数据信息</span>    <span class="hljs-keyword">this</span>.metadata = metadataReader.getAnnotationMetadata();    setBeanClassName(<span class="hljs-keyword">this</span>.metadata.getClassName());  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.metadata;  &#125;&#125;</code></pre></div><p><code>MetadataReader</code>：用于访问类元数据的简单入口，由<code>ASM org.springframework.asm.ClassReader</code>读取。</p><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;iocBean1&quot;)</span><span class="hljs-meta">@Order(1)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBean</span> </span>&#123;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testScannedGenericBeanDefinition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  SimpleMetadataReaderFactory simpleMetadataReaderFactory = <span class="hljs-keyword">new</span> SimpleMetadataReaderFactory();  MetadataReader metadataReader =     simpleMetadataReaderFactory.getMetadataReader(<span class="hljs-string">&quot;io.better.spring.ioc.IocBean&quot;</span>);  ScannedGenericBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);  AnnotationMetadata metadata = beanDefinition.getMetadata();  Set&lt;String&gt; annotationTypes = metadata.getAnnotationTypes();  System.out.println(annotationTypes);&#125;</code></pre></div><h5 id="示例结果-1"><a href="#示例结果-1" class="headerlink" title="示例结果"></a>示例结果</h5><div class="code-wrapper"><pre><code class="hljs txt">[org.springframework.stereotype.Component, org.springframework.core.annotation.Order]</code></pre></div><h4 id="AnnotatedGenericBeanDefinition"><a href="#AnnotatedGenericBeanDefinition" class="headerlink" title="AnnotatedGenericBeanDefinition"></a>AnnotatedGenericBeanDefinition</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>AnnotatedGenericBeanDefinition</p><p>这个GenericBeanDefinition变体主要用于测试希望在AnnotatedBeanDefinition上运行的代码，例如Spring组件扫描支持中的策略实现（默认定义类是org.springframework.context.annotation.ScannedGenericBeanDefinition，它也实现了AnnotatedBeanDefinition接口） 。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotatedGenericBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotatedBeanDefinition</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata metadata;  <span class="hljs-keyword">private</span> MethodMetadata factoryMethodMetadata;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotatedGenericBeanDefinition</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;    setBeanClass(beanClass);    <span class="hljs-keyword">this</span>.metadata = AnnotationMetadata.introspect(beanClass);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.metadata;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-meta">@Nullable</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> MethodMetadata <span class="hljs-title">getFactoryMethodMetadata</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.factoryMethodMetadata;  &#125;&#125;</code></pre></div><h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAnnotatedGenericBeanDefinition</span><span class="hljs-params">()</span> </span>&#123;  AnnotatedGenericBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(IocBean.class);    System.out.println(beanDefinition.getMetadata().getAnnotationTypes());&#125;</code></pre></div><h5 id="示例结果-2"><a href="#示例结果-2" class="headerlink" title="示例结果"></a>示例结果</h5><div class="code-wrapper"><pre><code class="hljs txt">[org.springframework.stereotype.Component]</code></pre></div><h4 id="ConfigurationClassBeanDefinition"><a href="#ConfigurationClassBeanDefinition" class="headerlink" title="ConfigurationClassBeanDefinition"></a><code>ConfigurationClassBeanDefinition</code></h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><p>该类是<code>ConfigurationClassBeanDefinitionReader</code>中的私有静态内部类。</p><p>而<code>ConfigurationClassBeanDefinitionReader</code>作用是将<code>@Configuration</code>注解标识的类生成<code>ConfigurationClass</code>实例，在通过<code>ConfigurationClassBeanDefinition</code>将其转换成BeanDefinition并注册到<code>BeanDefinitionRegistry</code>中。</p><p>而<code>ConfigurationClassBeanDefinition</code>的作用就是将<code>@Configuration</code>标识的类生成BeanDefinition（XML等其他配置源无效）。</p><h5 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigurationClassBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RootBeanDefinition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotatedBeanDefinition</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotationMetadata annotationMetadata;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodMetadata factoryMethodMetadata;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConfigurationClassBeanDefinition</span><span class="hljs-params">(ConfigurationClass configClass, MethodMetadata beanMethodMetadata)</span> </span><span class="hljs-function">  </span>&#123;    <span class="hljs-keyword">this</span>.annotationMetadata = configClass.getMetadata();    <span class="hljs-keyword">this</span>.factoryMethodMetadata = beanMethodMetadata;    setLenientConstructorResolution(<span class="hljs-keyword">false</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.annotationMetadata;  &#125;&#125;</code></pre></div><p>在ConfigurationClassBeanDefinition构造函数中我们看到ConfigurationClass类，一个ConfigurationClass代表着一个用户定义的@Configuration类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>AbstractBeanDefinition</strong>：<ul><li>AbstractBeanDefinition是完善且具体的BeanDefinition类的基类，其中排除了GenericBeanDefinition，RootBeanDefinition和ChildBeanDefinition的常用属性。自动装配常数与AutowireCapableBeanFactory接口中定义的常数匹配。</li></ul></li><li><strong>GenericBeanDefinition</strong>：<ul><li>GenericBeanDefinition是一站式的用于标准bean定义。 像任何bean定义一样，它允许指定一个类以及可选的构造函数参数值和属性值。</li></ul></li><li><strong>AnnotatedBeanDefinition</strong>：<ul><li>表示注解类型的BeanDefinition，有两个重要的属性，AnnotationMetadata，MethodMetadata分别表示BeanDefinition的注解元信息和方法元信息。</li></ul></li><li><strong>RootBeanDefinition</strong>：<ul><li>代表一个<code>Xml，Java Config</code>来的BeanDefinition</li></ul></li><li><strong>ChildBeanDefinition</strong>:<ul><li>可以让子Bean定义拥有从父Bean定义哪里继承配置的能力</li></ul></li><li><strong>AnnotatedGenericBeanDefinition</strong>：<ul><li>表示<code>@Configuration</code>注解注释的Bean</li></ul></li><li><strong>ScannedGenericBeanDefinition</strong>：<ul><li>表示<code>@Component、@Service、@Controller、@Repository</code>等注解注释的Bean</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Proxy-代理</title>
    <link href="/2020/04/06/java/proxy/"/>
    <url>/2020/04/06/java/proxy/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述代模式以及其实现方式，主要是 <code>静态代理</code> , <code>动态代理</code>, <code>Cglib代理</code>.</p><span id="more"></span><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://zh.wikipedia.org/wiki/代理模式">代理模式</a>是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><p>在<code>Java</code>中实现代理主要有三种方式：</p><ul><li>静态代码</li><li>动态代理</li><li>Cglib代理</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在静态代理中，需要为每一个被代理对象创建一个代理类，并实现同一个接口。</p><p>示例代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 父接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IConsumer</span> </span>&#123;  <span class="hljs-comment">// 消费</span>  <span class="hljs-function">String <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 代理对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IConsumer</span> </span>&#123;  <span class="hljs-keyword">private</span> Consumer consumer;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConsumerProxy</span><span class="hljs-params">(Consumer consumer)</span> </span>&#123;    <span class="hljs-keyword">this</span>.consumer = consumer;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;代理对象执行前的代码&quot;</span>);    String consumer = <span class="hljs-keyword">this</span>.consumer.consumer();    System.out.println(<span class="hljs-string">&quot;代理对象执行后的代码&quot;</span>);    <span class="hljs-keyword">return</span> consumer;  &#125;&#125;<span class="hljs-comment">// 被代理对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IConsumer</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;消费方法被调用了&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success&quot;</span>;  &#125;&#125;</code></pre></div><p>从代码中看出，<code>ConsumerProxy</code>代理对象持有了<code>Consumer</code>被代理对象的引用，并在<code>consumer方法</code>中调用了<code>被代理对象的consumer方法</code>。来看看实际测试代码：</p><p>测试代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStaticProxy</span><span class="hljs-params">()</span> </span>&#123;    Consumer consumer = <span class="hljs-keyword">new</span> Consumer();    IConsumer consumerProxy = <span class="hljs-keyword">new</span> ConsumerProxy(consumer);    System.out.println(consumerProxy.consumer());&#125;</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs txt">代理对象执行前的代码消费方法被调用了代理对象执行后的代码Success</code></pre></div><p><strong>优点：可以最大程度扩展被代理对象的功能。</strong></p><p><strong>缺点：被代理对象会随着代理对象的增加而增加，代码冗余。如果接口新增方法，代理对象和被代理对象都需要实现。</strong></p><p>基于静态代理的缺点，有没有一种代理能够动态的生成代理对象呢？</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>动态代理利用了<a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/">JDK API</a>，动态的在内存中构建代理对象，从而实现对目标对象的代理功能。</p><p>动态代理又被称为JDK代理或接口代理。</p><p>相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。</p><p>先来看一个示例，了解一下动态代理的基本使用。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ①</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDynamic</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dynamicProxy</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// ②</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dynamic</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDynamic</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dynamicProxy</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;目标方法执行了&quot;</span>);    &#125;&#125;<span class="hljs-comment">// ③</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxyInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Object proxyTarget;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DynamicProxyInvocation</span><span class="hljs-params">(Object proxyTarget)</span> </span>&#123;        <span class="hljs-keyword">this</span>.proxyTarget = proxyTarget;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;代理执行前&quot;</span>);        Object invokeResult = method.invoke(proxyTarget, args);        System.out.println(<span class="hljs-string">&quot;代理执行后&quot;</span>);        <span class="hljs-keyword">return</span> invokeResult;    &#125;&#125;</code></pre></div><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDynamicProxy</span><span class="hljs-params">()</span> </span>&#123;    Dynamic proxyTarget = <span class="hljs-keyword">new</span> Dynamic();    IDynamic dynamicProxy = (IDynamic) Proxy.newProxyInstance(proxyTarget.getClass().getClassLoader(),            proxyTarget.getClass().getInterfaces(), <span class="hljs-keyword">new</span> DynamicProxyInvocation(proxyTarget));    dynamicProxy.dynamicProxy();&#125;</code></pre></div><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><div class="code-wrapper"><pre><code class="hljs txt">代理执行前目标方法执行了代理执行后</code></pre></div><p>在上面的代码中，看到了很多未知的接口和类，主要是<code>Proxy类</code>，<code>InvocationHandler接口</code>。</p><h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a><code>Proxy</code></h3><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p><code>Proxy.newProxyInstance()</code>方法返回的<code>代理类是如何生成</code>？为什么Jdk 的动态代理<code>被代理类必须实现接口</code>？</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Proxy提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的<code>超类</code>。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>从上面的示例代码可以看出代理类的实例是由<code>Proxy.newProxyInstance</code>返回的，那么我们重点关注<code>Proxy.newProxyInstance</code>这个方法。</p><h5 id="创建代理实例"><a href="#创建代理实例" class="headerlink" title="创建代理实例"></a>创建代理实例</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> InvocationHandler h;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(InvocationHandler h)</span> </span>&#123;  Objects.requireNonNull(h);  <span class="hljs-keyword">this</span>.h = h;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> </span>&#123;  <span class="hljs-comment">// 忽略部分代码</span>    <span class="hljs-comment">// 步骤①</span>  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);  <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;    checkNewProxyPermission(Reflection.getCallerClass(), cl);  &#125;<span class="hljs-comment">// 步骤②</span>  <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);  <span class="hljs-keyword">final</span> InvocationHandler ih = h;  <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        cons.setAccessible(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> Object[]&#123;h&#125;);  <span class="hljs-comment">// 忽略部分代码</span>&#125;</code></pre></div><p>在<code>newProxyInstance</code>方法中有两个比较核心的步骤，分别如下：</p><p>步骤①：获取代理类的<code>Class</code>实例。</p><p>步骤②：获取代理类带有<code>InvocationHandler</code>参数的构造方法。</p><p>除了上面两个比较重要的步骤，还需要关注<code>InvocationHandler h</code>和<code>Proxy(InvocationHandler h)</code>，后面会进行讲解。</p><h5 id="获取代理类字节码"><a href="#获取代理类字节码" class="headerlink" title="获取代理类字节码"></a>获取代理类字节码</h5><p><code>getProxyClass0</code>最终会调用到<code>ProxyClassFactory.apply()</code>方法中，具体操作细节，可自行Debug查看调用链。</p><div class="code-wrapper"><pre><code class="hljs java">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String proxyClassNamePrefix = <span class="hljs-string">&quot;$Proxy&quot;</span>;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;    <span class="hljs-comment">// 忽略部分代码</span>    <span class="hljs-keyword">long</span> num = nextUniqueNumber.getAndIncrement();    String proxyName = proxyPkg + proxyClassNamePrefix + num;<span class="hljs-comment">// 步骤①</span>    <span class="hljs-keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(      proxyName, interfaces, accessFlags);    <span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">// 步骤② 定义Class，native方法</span>      <span class="hljs-keyword">return</span> defineClass0(loader, proxyName,                          proxyClassFile, <span class="hljs-number">0</span>, proxyClassFile.length);    &#125; <span class="hljs-keyword">catch</span> (ClassFormatError e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(e.toString());    &#125;&#125;</code></pre></div><p>步骤①：调用<code>ProxyGenerator.generateProxyClass</code>生成代理类.class的字节数组。</p><p>步骤②：调用<code>defineClass0</code>生成.class文件，并加载到Jvm中。</p><h4 id="手动生成Class"><a href="#手动生成Class" class="headerlink" title="手动生成Class"></a>手动生成Class</h4><p>从上面我们得知了Proxy类在最后调用了<code>ProxyGenerator.generateProxyClass</code>方法生成了代理类的<code>.class</code>字节数组。那么生成的<code>.class</code>结构是怎样的呢？让我们来手动触发调用一下。</p><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyGeneratorTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">byte</span>[] dynamicObj = ProxyGenerator.generateProxyClass(      <span class="hljs-string">&quot;ManualGeneratorDynamicClass&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;IDynamic.class&#125;, <span class="hljs-number">17</span>);    FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;ManualGeneratorDynamicClass.class&quot;</span>));    out.write(dynamicObj);    out.flush();    out.close();  &#125;&#125;</code></pre></div><h5 id="代理类-class文件"><a href="#代理类-class文件" class="headerlink" title="代理类.class文件"></a>代理类<code>.class</code>文件</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManualGeneratorDynamicClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDynamic</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;  <span class="hljs-comment">// 调用父类Proxy的构造器对父类中InvocationHandler属性进行了赋值</span>  <span class="hljs-comment">// 而这个构造器是在Proxy.newProxyInstance()方法中被调用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ManualGeneratorDynamicClass</span><span class="hljs-params">(InvocationHandler var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">super</span>(var1);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;var1&#125;);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) &#123;            <span class="hljs-keyword">throw</span> var3;        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, (Object[])<span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dynamicProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">// 调用了父类的InvocationHandler实例的invoke方法</span>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, (Object[])<span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;            <span class="hljs-keyword">throw</span> var2;        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);        &#125;    &#125;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);          <span class="hljs-comment">// 获取到被代理类实现的接口中的方法</span>            m3 = Class.forName(<span class="hljs-string">&quot;io.better.jdk.proxy.dynamicproxy.IDynamic&quot;</span>).getMethod(<span class="hljs-string">&quot;dynamicProxy&quot;</span>);            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());        &#125;    &#125;&#125;</code></pre></div><p>从代码可以看出<code>ManualGeneratorDynamicClass</code>类不仅继承了<code>Proxy</code>类（解释了Porxy为什么是所有代理类的超类），还实现了<code>被代理类</code>实现的接口（解释了为什么被代理类必须实现接口？）。</p><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a><code>InvocationHandler</code></h3><p>通过上面对Proxy的了解，我们知道了代理类的方法调用最终会调用到InvocationHandler实例的invoke方法。</p><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>InvocationHandler是代理实例的调用处理程序（InvocationHandler实例）实现的接口。<br><code>每个代理实例都有一个关联的调用处理程序</code>。 当一个方法是在代理实例调用，方法调用进行编码，并分发给invoke的调用处理程序的方法。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;  <span class="hljs-comment">// 处理代理实例的方法调用并返回结果。</span>  <span class="hljs-comment">// 该方法将在调用处理程序时的方法是在一个代理实例，它与相关的调用来调用。</span>  <span class="hljs-comment">// proxy: 类型为Proxy</span>  <span class="hljs-comment">// method: 目标执行的方法</span>  <span class="hljs-comment">// args: 方法执行所需的参数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> Throwable</span>;&#125;</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>运行时动态生成代理类，和被代理类解耦。</li></ul><p>缺点：</p><ul><li>被代理类必须实现接口，否则不能使用动态代理。</li></ul><h4 id="代理机制"><a href="#代理机制" class="headerlink" title="代理机制"></a>代理机制</h4><p>动态代理类（以下简称为代理类）是一种类，该类实现<code>创建类时(调用newProxyInstance方法时)</code>在运行时指定的<code>接口列表(interfaces参数)</code>，代理接口是由代理类实现的接口。代理实例是代理类的实例。<code>每个代理实例都有一个关联的调用处理程序对象，该对象实现接口InvocationHandler</code>。</p><p>通过其代理接口之一对代理实例进行的方法调用将分派给该实例的调用处理程序的invoke方法，并传递该<code>代理实例（proxy参数）</code>，一个标识所调用方法的<code>java.lang.reflect.Method对象（method参数）</code>以及一个数组包含参数的Object类型<code>（args参数）</code>。</p><h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上面我使用了动态代理，知道了动态代理一些优缺点，为了弥补Jdk动态代理的缺点，Cglib诞生了，被代理类无需实现接口也能被代理。</p><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><code>cglib</code>-字节码生成库是用于生成和转换Java字节码的高级API。AOP，测试，数据访问框架使用它来生成动态代理对象并拦截字段访问。</p><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> io.better.jdk.proxy.cglibproxy;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.util.Objects;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> better create in 2020/5/8 5:56 下午</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibBean</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">proxy</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;proxy execute ....&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-keyword">private</span> Object proxyTarget;    <span class="hljs-function"><span class="hljs-keyword">public</span> CglibProxyFactory <span class="hljs-title">setProxyTarget</span><span class="hljs-params">(Object proxyTarget)</span> </span>&#123;        <span class="hljs-keyword">this</span>.proxyTarget = proxyTarget;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;cglib 执行前&quot;</span>);        Object result = method.invoke(proxyTarget, objects);        System.out.println(<span class="hljs-string">&quot;cglib 执行后&quot;</span>);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxyInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (Objects.isNull(proxyTarget)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;被代理对象不能为空&quot;</span>);        &#125;        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperclass(proxyTarget.getClass());        enhancer.setCallback(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">return</span> enhancer.create();    &#125;&#125;</code></pre></div><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCglib</span><span class="hljs-params">()</span> </span>&#123;    CglibBean proxyTarget = <span class="hljs-keyword">new</span> CglibBean();    CglibBean proxyInstance = (CglibBean) <span class="hljs-keyword">new</span> CglibProxyFactory().setProxyTarget(proxyTarget).getProxyInstance();    proxyInstance.proxy();&#125;</code></pre></div><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><div class="code-wrapper"><pre><code class="hljs txt">cglib 执行前proxy execute ....cglib 执行后</code></pre></div><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><p>从示例代码可以看出<code>Enhancer</code>类是创建代理对象的核心，那么Enhancer是如何创建代理类的呢？创建的代理类结构是如何呢？</p><p>在代码中一共操作了四部：</p><ol><li><p>创建Enhancer对象。</p></li><li><p>调用setSuperclass设置父类。</p></li><li><p>调用setCallback设置回调。</p></li><li><p>调用create创建代理实例。</p></li></ol><h4 id="创建Enhancer对象"><a href="#创建Enhancer对象" class="headerlink" title="创建Enhancer对象"></a>创建Enhancer对象</h4><h5 id="构造器描述"><a href="#构造器描述" class="headerlink" title="构造器描述"></a>构造器描述</h5><p>创建一个新的增强器。每个生成的对象都应使用一个新的Enhancer对象，并且不应在线程之间共享。要创建生成的类的其他实例，请使用Factory接口。</p><h5 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h5><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172422.png" alt="image-20200509104246223" style="zoom:50%;" /><h5 id="Enhancer构造器"><a href="#Enhancer构造器" class="headerlink" title="Enhancer构造器"></a>Enhancer构造器</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Source SOURCE = <span class="hljs-keyword">new</span> Source(Enhancer.class.getName());<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Enhancer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>(SOURCE);&#125;<span class="hljs-comment">// 父类AbstractClassGenerator构造器</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractClassGenerator</span><span class="hljs-params">(Source source)</span> </span>&#123;  <span class="hljs-keyword">this</span>.source = source;&#125;</code></pre></div><p>代码中将Enhancer的名称封装到了Source实例中，并调用父类AbstractClassGenerator构造器进行赋值 。</p><h4 id="设置父类"><a href="#设置父类" class="headerlink" title="设置父类"></a>设置父类</h4><h5 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h5><p>设置生成的类将继承的类。 为了方便起见，如果提供的超类实际上是接口，则将使用适当的参数来调用setInterfaces。 非接口参数不能声明为final，并且必须具有可访问的构造函数。</p><h5 id="方法setSuperclass"><a href="#方法setSuperclass" class="headerlink" title="方法setSuperclass"></a>方法<code>setSuperclass</code></h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class superclass;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSuperclass</span><span class="hljs-params">(Class superclass)</span> </span>&#123;<span class="hljs-comment">// 如果为接口，则获取并调用setInterfaces方法</span>  <span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; superclass.isInterface()) &#123;    setInterfaces(<span class="hljs-keyword">new</span> Class[]&#123; superclass &#125;);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; superclass.equals(Object.class)) &#123;    <span class="hljs-comment">// affects choice of ClassLoader</span>    <span class="hljs-keyword">this</span>.superclass = <span class="hljs-keyword">null</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 给superclass字段赋值</span>    <span class="hljs-keyword">this</span>.superclass = superclass;  &#125;&#125;<span class="hljs-keyword">private</span> Class[] interfaces;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInterfaces</span><span class="hljs-params">(Class[] interfaces)</span> </span>&#123;  <span class="hljs-keyword">this</span>.interfaces = interfaces;&#125;</code></pre></div><p>方法逻辑比较简单就是给Enhancer实例中的字段进行赋值。</p><h4 id="设置回调"><a href="#设置回调" class="headerlink" title="设置回调"></a>设置回调</h4><h5 id="方法描述-1"><a href="#方法描述-1" class="headerlink" title="方法描述"></a>方法描述</h5><p>设置要使用的单个回调。 如果使用createClass则被忽略。</p><h5 id="方法setCallback"><a href="#方法setCallback" class="headerlink" title="方法setCallback"></a>方法<code>setCallback</code></h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Callback[] callbacks;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback callback)</span> </span>&#123;    setCallbacks(<span class="hljs-keyword">new</span> Callback[]&#123; callback &#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallbacks</span><span class="hljs-params">(Callback[] callbacks)</span> </span>&#123;  <span class="hljs-keyword">if</span> (callbacks != <span class="hljs-keyword">null</span> &amp;&amp; callbacks.length == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Array cannot be empty&quot;</span>);  &#125;  <span class="hljs-keyword">this</span>.callbacks = callbacks;&#125;</code></pre></div><p>该方法也是给Enhancer实例中的<code>callbacks</code>字段进行赋值</p><h4 id="创建代理实例-1"><a href="#创建代理实例-1" class="headerlink" title="创建代理实例"></a>创建代理实例</h4><h5 id="方法描述-2"><a href="#方法描述-2" class="headerlink" title="方法描述"></a>方法描述</h5><p>如有必要，生成一个新类，并使用指定的回调（如果有）来创建一个新的对象实例。 使用超类的no-arg构造函数。</p><h5 id="入口-Enhancer-create"><a href="#入口-Enhancer-create" class="headerlink" title="入口-Enhancer.create"></a>入口-<code>Enhancer.create</code></h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;    classOnly = <span class="hljs-keyword">false</span>;    argumentTypes = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">return</span> createHelper();&#125;</code></pre></div><p><code>createHelper</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">createHelper</span><span class="hljs-params">()</span> </span>&#123;  preValidate();  Object key = KEY_FACTORY.newInstance((superclass != <span class="hljs-keyword">null</span>) ? superclass.getName() : <span class="hljs-keyword">null</span>,                                       ReflectUtils.getNames(interfaces),                                       filter == ALL_ZERO ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> WeakCacheKey&lt;CallbackFilter&gt;(filter),                                       callbackTypes,                                       useFactory,                                       interceptDuringConstruction,                                       serialVersionUID);  <span class="hljs-keyword">this</span>.currentKey = key;  Object result = <span class="hljs-keyword">super</span>.create(key);  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p><code>KEY_FACTORY.newInstance</code>生成的<code>key</code>需要特别注意，后面在<code>生成代理类Class时会用此key与Class一对一绑定</code>。</p><p>继续查看父类的<code>create</code>方法。</p><h4 id="AbstractClassGenerator-create"><a href="#AbstractClassGenerator-create" class="headerlink" title="AbstractClassGenerator.create"></a><code>AbstractClassGenerator.create</code></h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Object key)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    ClassLoader loader = getClassLoader();    Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;    ClassLoaderData data = cache.get(loader);    <span class="hljs-comment">// 忽略部分代码</span>    <span class="hljs-keyword">this</span>.key = key;    <span class="hljs-comment">// 步骤①，创建代理类字节码核心入口</span>    Object obj = data.get(<span class="hljs-keyword">this</span>, getUseCache());    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Class) &#123;      <span class="hljs-keyword">return</span> firstInstance((Class) obj);    &#125;    <span class="hljs-comment">// 步骤②，根据创建代理类实例</span>    <span class="hljs-keyword">return</span> nextInstance(obj);  &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;  &#125;&#125;</code></pre></div><p>上诉代码中忽略了部分代码，重点关注<code>步骤①</code> 和<code>步骤②</code>对应的两个方法。</p><p>步骤①：调用<code>ClassLoaderData.get()</code>获取代理类Class对象。</p><p>步骤②：使用代理类Class对象创建代理实例。</p><h5 id="步骤①"><a href="#步骤①" class="headerlink" title="步骤①"></a>步骤①</h5><p>知道了代理对象是通过<code>ClassLoaderData.get</code>方法获取的，那么必须了解<code>ClassLoaderData</code>的作用及其结构。</p><h6 id="ClassLoaderData"><a href="#ClassLoaderData" class="headerlink" title="ClassLoaderData"></a><code>ClassLoaderData</code></h6><p>那么<code>ClassLoaderData</code>类有什么作用呢？通过Debug来看看ClassLoaderData内部结构。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172428.png" alt="image-20200509150401851"></p><p>类结构图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200509172432.png" alt="image-20200509150935264" style="zoom:50%;" /><p><code>generatedClasses</code>：用于存储已经生成的Class对象。</p><p><code>reservedClassNames</code>：用于存储已经解析的Class名称（全路径）。</p><p><code>classLoader</code>：加载生成Class对象的加载器。</p><p>可以看出ClassLoaderData内部管理生成的Class类和加载Class所需的ClassLoader，可以简单<code>理解为生成Class并存储Class的容器</code>。</p><h6 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h6><p>那么<code>ClassLoaderData</code>是如何初始化的呢 ？我们进入ClassLoaderData的构造器看看：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassLoaderData</span><span class="hljs-params">(ClassLoader classLoader)</span> </span>&#123;  <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;classLoader == null is not yet supported&quot;</span>);  &#125;  <span class="hljs-comment">// 设置加载类使用的ClassLoader</span>  <span class="hljs-keyword">this</span>.classLoader = <span class="hljs-keyword">new</span> WeakReference&lt;ClassLoader&gt;(classLoader);  <span class="hljs-comment">// 声明了load函数</span>  Function&lt;AbstractClassGenerator, Object&gt; load =    <span class="hljs-keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(AbstractClassGenerator gen)</span> </span>&#123;      Class klass = gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">return</span> gen.wrapCachedClass(klass);    &#125;  &#125;;  <span class="hljs-comment">// 在这里对generatedClasses做了初始化</span>  generatedClasses = <span class="hljs-keyword">new</span> LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);&#125;</code></pre></div><p>可以看出<code>classLoader，generatedClasses</code>两个对象被进行了初始化，在这里重点注意<code>load</code>这个函数 ，<code>这个函数就是创建代理类Class的关键</code>。</p><h6 id="ClassLoaderData-get"><a href="#ClassLoaderData-get" class="headerlink" title="ClassLoaderData.get"></a><code>ClassLoaderData.get</code></h6><p>了解了<code>ClassLoaderData</code>后，我们进入 <code>get()</code>方法一探究竟：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(AbstractClassGenerator gen, <span class="hljs-keyword">boolean</span> useCache)</span> </span>&#123;<span class="hljs-comment">// useCache默认值为true</span>  <span class="hljs-keyword">if</span> (!useCache) &#123;    <span class="hljs-keyword">return</span> gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 从缓存中获取缓存的对象</span>    Object cachedValue = generatedClasses.get(gen);    <span class="hljs-keyword">return</span> gen.unwrapCachedValue(cachedValue);  &#125;&#125;</code></pre></div><p>如果不修改useCache的值，代码最终会调用<code>generatedClasses.get</code>方法。到这里是不是感觉<code>generatedClasses</code>这个对象是不是非常眼熟，没错他就是<code>ClassLoaderData中存放生成过Class的对象</code>。</p><p>接着进入generatedClasses对象一探究竟。</p><h6 id="LoadingCache"><a href="#LoadingCache" class="headerlink" title="LoadingCache"></a><code>LoadingCache</code></h6><p>在如何<code>LoadingCache.get</code>方法前，我们先来看看<code>LoadingCache</code>的构造函数：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 上面ClassLoaderData构造器中最后一步会调用</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadingCache</span><span class="hljs-params">(Function&lt;K, KK&gt; keyMapper, Function&lt;K, V&gt; loader)</span> </span>&#123;    <span class="hljs-keyword">this</span>.keyMapper = keyMapper;  <span class="hljs-comment">// 用于获取 KEY_FACTORY.newInstance 创建的key的函数</span>    <span class="hljs-keyword">this</span>.loader = loader;   <span class="hljs-comment">// 用于生成代理类的Class函数</span>    <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;KK, Object&gt;();&#125;</code></pre></div><p>LoadingCache构造函数主要是在对<code>自身变量进行赋值</code>操作。</p><p><code>loader</code>：类型为函数，用于创建代理类Class</p><p><code>keyMapper</code>：类型为函数，用于获取前面<code>Enhancer.create</code>方法中通过<code>KEY_FACTORY.newInstance</code>创建的<code>key</code></p><p><code>map</code>：key=<code>keyMapper函数获取到的key</code>，value=<code>loader函数生成的代理Class数据</code>。</p><h6 id="LoadingCache-get"><a href="#LoadingCache-get" class="headerlink" title="LoadingCache.get"></a><code>LoadingCache.get</code></h6><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;  <span class="hljs-comment">// 获取到 KEY_FACTORY.newInstance 创建的key</span>  <span class="hljs-keyword">final</span> KK cacheKey = keyMapper.apply(key);  <span class="hljs-comment">// 查看是否已经存在</span>  Object v = map.get(cacheKey);  <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span> &amp;&amp; !(v <span class="hljs-keyword">instanceof</span> FutureTask)) &#123;    <span class="hljs-keyword">return</span> (V) v;  &#125;  <span class="hljs-comment">// 不存在，则创建</span>  <span class="hljs-keyword">return</span> createEntry(key, cacheKey, v);&#125;</code></pre></div><h6 id="LoadingCache-createEntry"><a href="#LoadingCache-createEntry" class="headerlink" title="LoadingCache.createEntry"></a><code>LoadingCache.createEntry</code></h6><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> V <span class="hljs-title">createEntry</span><span class="hljs-params">(<span class="hljs-keyword">final</span> K key, KK cacheKey, Object v)</span> </span>&#123;  <span class="hljs-comment">// key = AbstractClassGenerator</span>  <span class="hljs-comment">// cacheKey = Enhancer.EnhancerKey</span>    FutureTask&lt;V&gt; task;  <span class="hljs-keyword">boolean</span> creator = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;    task = (FutureTask&lt;V&gt;) v;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 创建一个Task</span>    task = <span class="hljs-keyword">new</span> FutureTask&lt;V&gt;(<span class="hljs-keyword">new</span> Callable&lt;V&gt;() &#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 到这来我们终于看到了ClassLoaderData构造器中声明的load函数被执行了</span>        <span class="hljs-comment">// (最后一步调用LoadingCache构造器，传递给LoadingCache.loader属性)</span>        <span class="hljs-keyword">return</span> loader.apply(key);      &#125;    &#125;);    <span class="hljs-comment">// 缓存Key和Task放入到map中缓存</span>    Object prevTask = map.putIfAbsent(cacheKey, task);    <span class="hljs-keyword">if</span> (prevTask == <span class="hljs-keyword">null</span>) &#123;      creator = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// 执行Task</span>      task.run();    &#125;  &#125;  V result;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 获取结果</span>    result = task.get();  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;  <span class="hljs-keyword">if</span> (creator) &#123;    <span class="hljs-comment">// 将缓存Key和生成Class对象放入到map中</span>    map.put(cacheKey, result);  &#125;  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>这个方法主要是创建FutureTask用于异步创建Class对象，并对其结果进行了缓存，提高性能。</p><p>接下来调用<code>load.apply</code>执行函数，最终调用至<code>AbstractClassGenerator.generate</code>方法中。</p><div class="code-wrapper"><pre><code class="hljs java">Function&lt;AbstractClassGenerator, Object&gt; load = <span class="hljs-keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() &#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(AbstractClassGenerator gen)</span> </span>&#123;    Class klass = gen.generate(ClassLoaderData.<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">return</span> gen.wrapCachedClass(klass);  &#125;&#125;;</code></pre></div><h6 id="AbstractClassGenerator-generate"><a href="#AbstractClassGenerator-generate" class="headerlink" title="AbstractClassGenerator.generate"></a><code>AbstractClassGenerator.generate</code></h6><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Class <span class="hljs-title">generate</span><span class="hljs-params">(ClassLoaderData data)</span> </span>&#123;  Class gen;  <span class="hljs-comment">// 从ThreadLocal获取对象，默认应该为null</span>  Object save = CURRENT.get();  <span class="hljs-comment">// 设置ThreadLocal，保证此AbstractClassGenerator不被线程共享</span>  CURRENT.set(<span class="hljs-keyword">this</span>);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 获取到加载Class字节码使用的ClassLoader</span>    ClassLoader classLoader = data.getClassLoader();<span class="hljs-comment">// 步骤①</span>    <span class="hljs-keyword">byte</span>[] b = strategy.generate(<span class="hljs-keyword">this</span>);    String className = ClassNameReader.getClassName(<span class="hljs-keyword">new</span> ClassReader(b));    ProtectionDomain protectionDomain = getProtectionDomain();    <span class="hljs-keyword">synchronized</span> (classLoader) &#123; <span class="hljs-comment">// just in case</span>      <span class="hljs-keyword">if</span> (protectionDomain == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 步骤②</span>        gen = ReflectUtils.defineClass(className, b, classLoader);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 步骤②</span>        gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);      &#125;    &#125;    <span class="hljs-keyword">return</span> gen;  &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// 置为null</span>    CURRENT.set(save);  &#125;&#125;</code></pre></div><p>步骤①：</p><p>调用<code>strategy.generate</code>方法生成代理类字节码数组。</p><p>其默认实例为<code>GeneratorStrategy strategy = DefaultGeneratorStrategy.INSTANCE;</code>。</p><p><code>strategy.generate</code>方法最终会调用到<code>Enhancer.generateClass(ClassVisitor v)</code>方法，这里面包含了生成代理类字节码具体步骤（这里了不做讲解，有兴趣的可自行查看）。</p><p>步骤②：</p><p>调用<code>ReflectUtils.defineClass</code>方法使用传入的ClassLoader加载生成的代理类字节码数组。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class <span class="hljs-title">defineClass</span><span class="hljs-params">(String className, <span class="hljs-keyword">byte</span>[] b, ClassLoader loader, ProtectionDomain protectionDomain)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  Class c;  <span class="hljs-keyword">if</span> (DEFINE_CLASS != <span class="hljs-keyword">null</span>) &#123;    Object[] args = <span class="hljs-keyword">new</span> Object[]&#123;className, b, <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> Integer(b.length), protectionDomain &#125;;    <span class="hljs-comment">// 步骤①，使用ClassLoader加载字节码信息 </span>    c = (Class)DEFINE_CLASS.invoke(loader, args);  &#125;   <span class="hljs-comment">// 忽略部分代码</span>    Class.forName(className, <span class="hljs-keyword">true</span>, loader);  <span class="hljs-keyword">return</span> c;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method DEFINE_CLASS, DEFINE_CLASS_UNSAFE;</code></pre></div><p><code>DEFINE_CLASS</code>其实是<code>java.lang.ClassLoader.defineClass</code>对应的Method对象。</p><h5 id="步骤②"><a href="#步骤②" class="headerlink" title="步骤②"></a>步骤②</h5><p>走完步骤①代理类的Class对象已生成，接下来就是通过该Class对象生成代理实例。</p><p>我们进入<code>nextInstance(obj);</code>方法查看实例化流程：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">nextInstance</span><span class="hljs-params">(Object instance)</span> </span>&#123;  EnhancerFactoryData data = (EnhancerFactoryData) instance;  <span class="hljs-keyword">if</span> (classOnly) &#123;    <span class="hljs-keyword">return</span> data.generatedClass;  &#125;  Class[] argumentTypes = <span class="hljs-keyword">this</span>.argumentTypes;  Object[] arguments = <span class="hljs-keyword">this</span>.arguments;  <span class="hljs-keyword">if</span> (argumentTypes == <span class="hljs-keyword">null</span>) &#123;    argumentTypes = Constants.EMPTY_CLASS_ARRAY;    arguments = <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-comment">// 步骤①</span>  <span class="hljs-keyword">return</span> data.newInstance(argumentTypes, arguments, callbacks);&#125;</code></pre></div><p>该方法在调用代理类Class构造函数前，处理好对应的构造函数参数类型和参数。</p><p>重点关注步骤①：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Class[] argumentTypes, Object[] arguments, Callback[] callbacks)</span> </span>&#123;  setThreadCallbacks(callbacks);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// Explicit reference equality is added here just in case Arrays.equals does not have one</span>    <span class="hljs-keyword">if</span> (primaryConstructorArgTypes == argumentTypes ||        Arrays.equals(primaryConstructorArgTypes, argumentTypes)) &#123;<span class="hljs-comment">// 创建代理实例</span>      <span class="hljs-keyword">return</span> ReflectUtils.newInstance(primaryConstructor, arguments);    &#125;    <span class="hljs-comment">// 创建代理实例</span>    <span class="hljs-keyword">return</span> ReflectUtils.newInstance(generatedClass, argumentTypes, arguments);  &#125; <span class="hljs-keyword">finally</span> &#123;    setThreadCallbacks(<span class="hljs-keyword">null</span>);  &#125;&#125;</code></pre></div><p>至此Cglib创建代理对象流程分析完毕。</p><h4 id="使用Cglib手动生成Class文件"><a href="#使用Cglib手动生成Class文件" class="headerlink" title="使用Cglib手动生成Class文件"></a>使用Cglib手动生成Class文件</h4><p>分析完Cglib整个创建流程，我还不能像Jdk动态代理一样了解到生成的代理类字节码到底是怎样的？接下来我们使用Cglib手动生成一个代理类的Class文件。</p><p>由于<code>strategy.generate</code>方法所需参数较为复杂，可<code>Debug</code>至<code>byte[] b = strategy.generate(this);</code>这行代码利用IDEA的<code>Evaluate Expression</code>功能手动输入以下代码：</p><div class="code-wrapper"><pre><code class="hljs java">FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;ManualGeneratorProxyCglibProxy.class&quot;</span>));out.write(b);out.flush();out.close();</code></pre></div><p>生成文件如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibBean</span>$$<span class="hljs-title">EnhancerByCGLIB</span>$$70184645 <span class="hljs-keyword">extends</span> <span class="hljs-title">CglibBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> CGLIB$BOUND;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object CGLIB$FACTORY_DATA;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;  <span class="hljs-keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0; <span class="hljs-comment">// 我们自定义的MethodInterceptor</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object CGLIB$CALLBACK_FILTER;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method CGLIB$proxy$<span class="hljs-number">0</span>$Method;  <span class="hljs-comment">// CglibBean.proxy调用方法</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MethodProxy CGLIB$proxy$<span class="hljs-number">0</span>$Proxy;  <span class="hljs-comment">// CglibBean.proxy代理方法</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] CGLIB$emptyArgs;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> CGLIB$STATICHOOK1() &#123;    CGLIB$THREAD_CALLBACKS = <span class="hljs-keyword">new</span> ThreadLocal();    CGLIB$emptyArgs = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 通过反射得到代理类的Class对象</span>    Class var0 = Class.forName(<span class="hljs-string">&quot;io.better.jdk.proxy.cglibproxy.CglibBean$$EnhancerByCGLIB$$70184645&quot;</span>);    Class var1;    <span class="hljs-comment">// 获取到被代理类所有的方法，找到proxy，返回类型为void的方法对应的Method对象</span>    CGLIB$proxy$<span class="hljs-number">0</span>$Method = ReflectUtils.findMethods(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;proxy&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>&#125;, (var1 = Class.forName(<span class="hljs-string">&quot;io.better.jdk.proxy.cglibproxy.CglibBean&quot;</span>)).getDeclaredMethods())[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 为proxy方法生成MethodProxy对象</span>    <span class="hljs-comment">// var1=被代理类的Class对象</span>    <span class="hljs-comment">// var2=代理类的Class对象</span>    CGLIB$proxy$<span class="hljs-number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-string">&quot;proxy&quot;</span>, <span class="hljs-string">&quot;CGLIB$proxy$0&quot;</span>);  &#125;  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> CGLIB$proxy$<span class="hljs-number">0</span>() &#123;    <span class="hljs-keyword">super</span>.proxy();  &#125;  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">proxy</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 获取到我们自定义的MethodInterceptor实例</span>    MethodInterceptor var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;    <span class="hljs-keyword">if</span> (var10000 == <span class="hljs-keyword">null</span>) &#123;      CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);      var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;    &#125;    <span class="hljs-keyword">if</span> (var10000 != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 调用MethodInterceptor.intercept</span>      var10000.intercept(<span class="hljs-keyword">this</span>, CGLIB$proxy$<span class="hljs-number">0</span>$Method, CGLIB$emptyArgs, CGLIB$proxy$<span class="hljs-number">0</span>$Proxy);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">super</span>.proxy();    &#125;  &#125;  <span class="hljs-keyword">static</span> &#123;    CGLIB$STATICHOOK1();  &#125;&#125;</code></pre></div><p>上诉代码中忽略了<code>equals，hashCode，toString</code>等方法。感兴趣的同学可以自己操作一下。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li><li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li><li>动态代理生成的类为 lass com.sun.proxy.$Proxy4，cglib代理生成的类为class com.cglib.UserDao$$EnhancerByCGLIB$$552188b6。</li><li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li><li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li><li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类</li></ol>]]></content>
    
    
    <categories>
      
      <category>Proxy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-BeanDefinition读取</title>
    <link href="/2020/03/09/spring/04-spring-bean-definition-reader/"/>
    <url>/2020/03/09/spring/04-spring-bean-definition-reader/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-BeanDefinition的读取与注册"><a href="#Ioc-BeanDefinition的读取与注册" class="headerlink" title="Ioc-BeanDefinition的读取与注册"></a>Ioc-BeanDefinition的读取与注册</h1><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><blockquote><p> 本文主要讲述BeanDefinition的读取与注册，主要涉及到的接口是BeanDefinitionReader和BeanDefinitionRegistry。</p><p> 本文会从这两个接口出发，分析其实现类，不同环境的不同实现，及其优缺点。</p></blockquote><h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BeanDefinitionReader接口是个一个BeanDefinition的读取规范定义接口，定义了 “资源” 和 “字符串” 位置参数指定加载方法。</p><p>当然，具体的BeanDefinitionReader可以为BeanDefinition添加特定于其BeanDefinition格式的其他加载和注册方法。</p><p>具体的BeanDefinitionReader不必实现此接口。它仅对希望遵循标准命名约定的bean定义读者提供建议。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180030.png" alt="image-20200516101622162"></p><p>老版本中经常使用的是<code>XMLBeanDefinitionReader</code>，注解驱动版本中经常使用<code>AnnotatedBeanDefinitionReader</code>。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;  <span class="hljs-comment">// 返回一个BeanFactory注册BeanDefinition，其实现了BeanDefinitionRegistry接口</span>  <span class="hljs-comment">// 封装了与BeanDefinition处理相关的方法。</span>  <span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 返回资源加载器以用于资源位置</span>  <span class="hljs-comment">// 可以检查ResourcePatternResolver接口并进行相应的转换，以针对给定的资源模式加载多个资源。</span>  <span class="hljs-comment">// 返回值为null表示此BeanDefinitionReader无法使用绝对资源加载</span>  <span class="hljs-function">ResourceLoader <span class="hljs-title">getResourceLoader</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回用于加载Bean的类加载器</span>  <span class="hljs-comment">// null建议不要急于加载Bean类，而只是用类名注册Bean定义，并在以后（或永不解析）相应的类。</span>  <span class="hljs-function">ClassLoader <span class="hljs-title">getBeanClassLoader</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回BeanNameGenerator用于匿名Bean名称（未指定显式Bean名称）。</span>  <span class="hljs-function">BeanNameGenerator <span class="hljs-title">getBeanNameGenerator</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 使用指定的Resource加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 使用指定的Resource数组加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 使用指定的location加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 使用指定的location数组加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;&#125;</code></pre></div><p>BeanDefinitionReader重载了不同参数的<code>loadBeanDefinitions</code>方法用于加载BeanDefinition。</p><h3 id="AbstractBeanDefinitionReader"><a href="#AbstractBeanDefinitionReader" class="headerlink" title="AbstractBeanDefinitionReader"></a><code>AbstractBeanDefinitionReader</code></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>AbstractBeanDefinitionReader是实现了BeanDefinitionReader接口抽象基类。提供常见的属性，例如要处理的BeanFactory以及用于加载bean类的类加载器。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBeanDefinitionReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionReader</span>, <span class="hljs-title">EnvironmentCapable</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinitionRegistry registry;  <span class="hljs-comment">// BeanDefinition注册器</span>  <span class="hljs-keyword">private</span> ResourceLoader resourceLoader; <span class="hljs-comment">// 资源加载器</span>  <span class="hljs-keyword">private</span> ClassLoader beanClassLoader;<span class="hljs-comment">// 类加载器</span>  <span class="hljs-keyword">private</span> Environment environment;<span class="hljs-comment">// 环境变量</span>  <span class="hljs-keyword">private</span> BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;  <span class="hljs-comment">// Bean名称生成器</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;    Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);    <span class="hljs-keyword">this</span>.registry = registry;    <span class="hljs-comment">// 如果实现了资源加载器接口</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registry <span class="hljs-keyword">instanceof</span> ResourceLoader) &#123;      <span class="hljs-keyword">this</span>.resourceLoader = (ResourceLoader) <span class="hljs-keyword">this</span>.registry;    &#125;<span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 创建默认资源加载器</span>      <span class="hljs-keyword">this</span>.resourceLoader = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();    &#125;    <span class="hljs-comment">// 判断拥有环境变量信息</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registry <span class="hljs-keyword">instanceof</span> EnvironmentCapable) &#123;      <span class="hljs-keyword">this</span>.environment = ((EnvironmentCapable) <span class="hljs-keyword">this</span>.registry).getEnvironment();    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 创建一个标准的环境变量对象</span>      <span class="hljs-keyword">this</span>.environment = <span class="hljs-keyword">new</span> StandardEnvironment();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;    Assert.notNull(resources, <span class="hljs-string">&quot;Resource array must not be null&quot;</span>);    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (Resource resource : resources) &#123;      <span class="hljs-comment">// 最终会调用子类实现的loadBeanDefinitions方法</span>      count += loadBeanDefinitions(resource);    &#125;    <span class="hljs-keyword">return</span> count;  &#125;&#125;</code></pre></div><p><code>AbstractBeanDefinitionReader</code>对<code>BeanDefinitionReader</code>进行了简单的实现，声明<code>registry</code>，<code>resourceLoader</code>，<code>beanClassLoader</code>，<code>environment</code>，<code>beanNameGenerator</code>等属性。</p><h3 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a><code>XmlBeanDefinitionReader</code></h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>XmlBeanDefinitionReader用于读取XML，将实际的XML文档读取委托给<code>BeanDefinitionDocumentReader</code>接口的实现。</p><p>此类加载DOM Document 并将BeanDefinitionDocumentReader应用于该Document。</p><h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlBeanDefinitionReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanDefinitionReader</span> </span>&#123;    <span class="hljs-comment">// BeanDefinitionDocumentReader读取解析Document并转换成BeanDefinition</span>    <span class="hljs-keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass =      DefaultBeanDefinitionDocumentReader.class;    <span class="hljs-comment">// 命名空间解析器</span>    <span class="hljs-keyword">private</span> NamespaceHandlerResolver namespaceHandlerResolver;    <span class="hljs-comment">// 将XML文件加载成Document对象</span>    <span class="hljs-keyword">private</span> DocumentLoader documentLoader = <span class="hljs-keyword">new</span> DefaultDocumentLoader();    <span class="hljs-comment">// 用于解析XML中的DTD文件</span>    <span class="hljs-keyword">private</span> EntityResolver entityResolver;    <span class="hljs-comment">// 绑定当前线程正在处理的XML文件集合 </span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded =      <span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">&quot;XML bean definition resources currently being loaded&quot;</span>);    <span class="hljs-comment">// 构造器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XmlBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;      <span class="hljs-keyword">super</span>(registry);    &#125;    <span class="hljs-comment">// 实现BeanDefinitionReader定义的接口</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;      <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> EncodedResource(resource));    &#125;    <span class="hljs-comment">// 重载的loadBeanDefinitions方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;      <span class="hljs-comment">// 获取当前线程正在处理的XML集合</span>      Set&lt;EncodedResource&gt; currentResources = <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.get();      <span class="hljs-keyword">if</span> (currentResources == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 为空则初始化</span>        currentResources = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 默认大小为4</span>        <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);      &#125;      <span class="hljs-keyword">if</span> (!currentResources.add(encodedResource)) &#123;   <span class="hljs-comment">// 将当前正在处理的encodedResource添加到Set集合中</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-comment">// 添加失败报错</span>          <span class="hljs-string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="hljs-string">&quot; - check your import definitions!&quot;</span>);      &#125;      <span class="hljs-comment">// 获取到XMl文件的输入流</span>      InputStream inputStream = encodedResource.getResource().getInputStream();      <span class="hljs-comment">// 一个InputSource代表一个XML实体</span>      InputSource inputSource = <span class="hljs-keyword">new</span> InputSource(inputStream);      <span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 为InputSource设置编码</span>        inputSource.setEncoding(encodedResource.getEncoding());      &#125;      <span class="hljs-comment">// 调用doLoadBeanDefinitions方法(真正的执行操作)</span>      <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());    &#125;    <span class="hljs-comment">// 忽略部分代码</span>  &#125;  <span class="hljs-comment">// 根据指定的XML文件加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">// 使用documentLoader将XML转换成Document</span>      Document doc = doLoadDocument(inputSource, resource);      <span class="hljs-comment">// 注册BeanDefinition</span>      <span class="hljs-keyword">int</span> count = registerBeanDefinitions(doc, resource);      <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (SAXParseException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (SAXException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (ParserConfigurationException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (IOException ex) &#123;&#125;    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;&#125;  &#125;  <span class="hljs-comment">// 将XML转换成Docment</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> Document <span class="hljs-title">doLoadDocument</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="hljs-keyword">this</span>.errorHandler,                                            getValidationModeForResource(resource), isNamespaceAware());  &#125;  <span class="hljs-comment">// 注册BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;    <span class="hljs-comment">// 创建BeanDefinition文档读取器，</span>    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();    <span class="hljs-keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;  &#125;  <span class="hljs-comment">// 创建BeanDefinitionDocumentReader对象，用于将Document解析成BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> BeanDefinitionDocumentReader <span class="hljs-title">createBeanDefinitionDocumentReader</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(<span class="hljs-keyword">this</span>.documentReaderClass);  &#125;  <span class="hljs-comment">// XmlReaderContext是ReaderContext的扩展，提供对XmlBeanDefinitionReader中配置的NamespaceHandlerResolver的访问。</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> XmlReaderContext <span class="hljs-title">createReaderContext</span><span class="hljs-params">(Resource resource)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XmlReaderContext(resource, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.eventListener,                                <span class="hljs-keyword">this</span>.sourceExtractor, <span class="hljs-keyword">this</span>, getNamespaceHandlerResolver());  &#125;  <span class="hljs-comment">// 命名空间解析器</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> NamespaceHandlerResolver <span class="hljs-title">getNamespaceHandlerResolver</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.namespaceHandlerResolver == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">this</span>.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.namespaceHandlerResolver;  &#125;&#125;</code></pre></div><p><code>XMLBeanDefinitionReader</code>实际上只做了<code>Document</code>文档的解析操作，真正的解析BeanDefinition操作交给了<code>BeanDefinitionDocumentReader</code>（接口）实例（默认为<code>DefaultBeanDefinitionDocumentReader</code>）来解析。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>Xml</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;iocBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.better.spring.ioc.IocBean&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test-xml&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testXmlBeanDefinitionReader</span><span class="hljs-params">()</span> </span>&#123;    AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();    BeanDefinitionReader definitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(applicationContext);    definitionReader.loadBeanDefinitions(<span class="hljs-string">&quot;Ioc.xml&quot;</span>);    applicationContext.refresh();    IocBean iocBean = (IocBean) applicationContext.getBean(<span class="hljs-string">&quot;iocBean&quot;</span>);    System.out.println(iocBean);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs txt">IocBean ConstructorIocBean custom initIocBean&#123;name=&#x27;test-xml&#x27;&#125;</code></pre></div><h4 id="BeanDefinitionDocumentReader"><a href="#BeanDefinitionDocumentReader" class="headerlink" title="BeanDefinitionDocumentReader"></a>BeanDefinitionDocumentReader</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>SPI，<code>BeanDefinitionDocumentReader</code>用于解析带有BeanDefinition的Xml Document。</p><h5 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionDocumentReader</span> </span>&#123;  <span class="hljs-comment">//注册BeanDefinition，doc：当前Xml对应的Document对象，readerContext：当前BeanDefinitionReader的长下文</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;&#125;</code></pre></div><h4 id="DefaultBeanDefinitionDocumentReader"><a href="#DefaultBeanDefinitionDocumentReader" class="headerlink" title="DefaultBeanDefinitionDocumentReader"></a>DefaultBeanDefinitionDocumentReader</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>BeanDefinitionDocumentReader的唯一实现类，封装了解析并组装BeanDefinition的具体操作。</p><h5 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultBeanDefinitionDocumentReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionDocumentReader</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT;<span class="hljs-comment">// 常量，标识一些标签</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NESTED_BEANS_ELEMENT = <span class="hljs-string">&quot;beans&quot;</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ALIAS_ELEMENT = <span class="hljs-string">&quot;alias&quot;</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME_ATTRIBUTE = <span class="hljs-string">&quot;name&quot;</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ALIAS_ATTRIBUTE = <span class="hljs-string">&quot;alias&quot;</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String IMPORT_ELEMENT = <span class="hljs-string">&quot;import&quot;</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESOURCE_ATTRIBUTE = <span class="hljs-string">&quot;resource&quot;</span>;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PROFILE_ATTRIBUTE = <span class="hljs-string">&quot;profile&quot;</span>;  <span class="hljs-comment">// 当前BeanDefinitionReader的上下文</span>  <span class="hljs-keyword">private</span> XmlReaderContext readerContext;<span class="hljs-comment">// 解析Document中的值并赋值给BeanDefinition</span>  <span class="hljs-keyword">private</span> BeanDefinitionParserDelegate delegate;  <span class="hljs-comment">// 核心入口</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;    <span class="hljs-keyword">this</span>.readerContext = readerContext;    doRegisterBeanDefinitions(doc.getDocumentElement());  &#125;  <span class="hljs-comment">// 核心方法</span>  <span class="hljs-comment">// </span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> </span>&#123;    BeanDefinitionParserDelegate parent = <span class="hljs-keyword">this</span>.delegate;    <span class="hljs-keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<span class="hljs-comment">// 处理Xml前置操作</span>    preProcessXml(root);    <span class="hljs-comment">// 解析BeanDefinition</span>    parseBeanDefinitions(root, <span class="hljs-keyword">this</span>.delegate);    <span class="hljs-comment">// 处理Xml后置操作</span>    postProcessXml(root);    <span class="hljs-keyword">this</span>.delegate = parent;  &#125;  <span class="hljs-comment">// 解析BeanDefinition核心方法</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;      NodeList nl = root.getChildNodes();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;        Node node = nl.item(i);        <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123; <span class="hljs-comment">// 是否是元素标签</span>          Element ele = (Element) node;          <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;            <span class="hljs-comment">// 处理默认元素</span>            parseDefaultElement(ele, delegate);          &#125;          <span class="hljs-keyword">else</span> &#123;            delegate.parseCustomElement(ele);          &#125;        &#125;      &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;      delegate.parseCustomElement(root);    &#125;  &#125;  <span class="hljs-comment">// 解析默认元素</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;    <span class="hljs-comment">// import标签</span>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;      importBeanDefinitionResource(ele);    &#125;    <span class="hljs-comment">// alias标签</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;      processAliasRegistration(ele);    &#125;    <span class="hljs-comment">// beans标签</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;      processBeanDefinition(ele, delegate);    &#125;    <span class="hljs-comment">// 内嵌bean标签</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;      <span class="hljs-comment">// recurse</span>      doRegisterBeanDefinitions(ele);    &#125;  &#125;  <span class="hljs-comment">// 解析beans标签，并调用registry进行注册</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;    <span class="hljs-comment">// BeanDefinitionHolder内部包装了一个BeanDefinition</span>    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);      <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 注册BeanDefinition</span>        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());      &#125;      <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;&#125;      <span class="hljs-comment">// 发布注册完成事件</span>      getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));    &#125;  &#125;&#125;</code></pre></div><p>在<code>DefaultBeanDefinitionDocumentReader</code>中处理<code>Bean标签</code>的逻辑交给了<code>BeanDefinitionParserDelegate</code>对象来进行操作，并通过<code>XmlReaderContext</code>获取到<code>Registry</code>，最后将解析好的BeanDefinition注册进容器。</p><p>伴随着Xml方法的繁琐，笨重，Spring在4.2版本后提供了注解配置的方式来替换Xml配置的方法，那么注解是怎样读取 BeanDefinition的呢？</p><h3 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a><code>AnnotatedBeanDefinitionReader</code></h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>AnnotatedBeanDefinitionReader是个方便的适配器，用于以编程方式注册Bean类。这是<code>ClassPathBeanDefinitionScanner</code>的替代方法，它应用注解的相同解析，但仅适用于显式注册的类。</p><p><strong>该类不仅仅读取BeanDefinition，同时会注册BeanDefinition。</strong></p><h4 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotatedBeanDefinitionReader</span> </span>&#123;<span class="hljs-comment">// BeanDefinition注册器</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinitionRegistry registry;<span class="hljs-comment">// Bean名称生成器</span>  <span class="hljs-keyword">private</span> BeanNameGenerator beanNameGenerator = AnnotationBeanNameGenerator.INSTANCE;  <span class="hljs-keyword">private</span> ScopeMetadataResolver scopeMetadataResolver = <span class="hljs-keyword">new</span> AnnotationScopeMetadataResolver();  <span class="hljs-comment">// </span>  <span class="hljs-keyword">private</span> ConditionEvaluator conditionEvaluator;  <span class="hljs-comment">// 构造函数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;    <span class="hljs-keyword">this</span>(registry, getOrCreateEnvironment(registry));  &#125;  <span class="hljs-comment">// 使用指定的Class数组注册Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;    <span class="hljs-keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;      registerBean(componentClass);    &#125;  &#125;<span class="hljs-comment">// 使用执行的Class注册Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;    doRegisterBean(beanClass, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);  &#125; <span class="hljs-comment">// 使用指定的Class和名称注册Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-meta">@Nullable</span> String name)</span> </span>&#123;    doRegisterBean(beanClass, name, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);  &#125;  <span class="hljs-comment">// 使用指定的Class和Annotation Class数组注册Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>&#123;    doRegisterBean(beanClass, <span class="hljs-keyword">null</span>, qualifiers, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);  &#125;    <span class="hljs-comment">// 忽略部分重载的registerBean方法</span>  <span class="hljs-comment">// 真正执行注册BeanDefinition的地方</span>  <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String name,</span></span><span class="hljs-function"><span class="hljs-params">                                  Class&lt;? extends Annotation&gt;[] qualifiers, Supplier&lt;T&gt; supplier,</span></span><span class="hljs-function"><span class="hljs-params">                                  BeanDefinitionCustomizer[] customizers)</span> </span>&#123;<span class="hljs-comment">// 创建BeanDefinition</span>    AnnotatedGenericBeanDefinition abd = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;      <span class="hljs-keyword">return</span>;    &#125;    abd.setInstanceSupplier(supplier);    <span class="hljs-comment">// 解析BeanDefinition的作用域</span>    ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);    abd.setScope(scopeMetadata.getScopeName());    <span class="hljs-comment">// 生成Bean名称</span>    String beanName = (name != <span class="hljs-keyword">null</span> ? name : <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="hljs-keyword">this</span>.registry));    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);    <span class="hljs-comment">// 处理Bean上声明的注解信息</span>    <span class="hljs-keyword">if</span> (qualifiers != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;        <span class="hljs-keyword">if</span> (Primary.class == qualifier) &#123;          abd.setPrimary(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 唯一</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Lazy.class == qualifier) &#123;          abd.setLazyInit(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 懒加载</span>        &#125;        <span class="hljs-keyword">else</span> &#123;          abd.addQualifier(<span class="hljs-keyword">new</span> AutowireCandidateQualifier(qualifier));        &#125;      &#125;    &#125;    <span class="hljs-comment">// 定制BeanDefinition，与BeanDefinitionBuilder.applyCustomizers 用法一致</span>    <span class="hljs-keyword">if</span> (customizers != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;        customizer.customize(abd);      &#125;    &#125;<span class="hljs-comment">// 生成BeanDefinitionHolder</span>    BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(abd, beanName);    <span class="hljs-comment">// 创建作用域代理</span>    definitionHolder =       AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);    <span class="hljs-comment">// 向容器中注册Bean</span>    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);  &#125;&#125;</code></pre></div><p>可以看出AnnotatedBeanDefinitionReader注册Bean的方法明显比XmlBeanDefinitionReader的处理方式简单了很多，</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAnnotatedBeanDefinitionReader</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 创建ApplicationContext</span>  AnnotationConfigApplicationContext applicationContext =     <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocBean.class);<span class="hljs-comment">// 获取Bean</span>  IocBean iocBean = applicationContext.getBean(IocBean.class);  System.out.println(iocBean);&#125;</code></pre></div><p><code>AnnotationConfigApplicationContext</code>类中声明了<code>AnnotatedBeanDefinitionReader</code>，<code>ClassPathBeanDefinitionScanner</code>对象，并在构造函数中做了初始化。</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180020.png" alt="image-20200517154640954" style="zoom:50%;" /><p><code>ClassPathBeanDefinitionScanner</code>用于扫描<code>ClassPath</code>下带<code>@Component，@Repository，@Service，@Controller</code>注解的类。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此BeanDefinitionReader的分析完成，我们一共分析了两个BeanDefinitionReader规范实现，分别对应<code>Xml读取（XmlBeanDefinitionReader）</code>和<code>注解读取（AnnotatedBeanDefinitionReader）</code>。</p><p><code>XmlBeanDefinitionReader</code>：内部将BeanDefinition的读取交给了BeanDefinitionDocumentReader来进行操作。</p><p><code>AnnotatedBeanDefinitionReader</code>：不仅能读取BeanDefinition，并且还能注册BeanDefinition。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reflection-反射</title>
    <link href="/2020/02/06/java/reflection/"/>
    <url>/2020/02/06/java/reflection/</url>
    
    <content type="html"><![CDATA[<p>该文章主要讲述Java中Reflection反射相关的API使用，以及一些常见问题。</p><span id="more"></span><h1 id="Jdk-Reflection"><a href="#Jdk-Reflection" class="headerlink" title="Jdk-Reflection"></a>Jdk-Reflection</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>Class的实例表示正在运行的Java应用程序的类和接口</code>。 枚举是一种类和注释是一种接口。</p><p>每个数组都属于一个被映射成Class对象的类，该对象由具有相同元素类型和大小的所有数组共享。 </p><p>原始类型<code>(boolean， byte， char， short， int， long， float，double)</code>，以及关键字<code>void</code>也表示为Class对象。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><strong>Class没有公共构造函数。 相反， Class对象由Java虚拟机的类加载并通过调用自动构造defineClass的类加载器方法</strong>。</p><h3 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h3><p>获取Class对象的方式一共有三种：通过<code>Class.forName(&quot;全路径包名&quot;)，类.class，类实例.getClass()</code>。</p><p>示例代码：</p><div class="code-wrapper"><pre><code class="hljs java">Class&lt;?&gt; stringClass = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);Class&lt;?&gt; integerClass = String.class;Class&lt;?&gt; stringObjClass = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>).getClass();System.out.println(stringClass == integerClass);System.out.println(stringObjClass == integerClass);</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs txt">truetrue</code></pre></div><p>输出的结果证实了相同元素类型的Class实例是相同且共享的。</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>在这个阶段会讲述Class类中常用方法的使用</p><p><code>ReflectionBean</code>类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectionBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassBean</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> Integer age;  String phone;  <span class="hljs-keyword">protected</span> String address;  <span class="hljs-keyword">public</span> Boolean sex;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflection</span><span class="hljs-params">()</span> </span>&#123;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflection</span><span class="hljs-params">(String name)</span> </span>&#123;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validInfo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> name != <span class="hljs-keyword">null</span> &amp;&amp; name.length() &gt; <span class="hljs-number">0</span> &amp;&amp; Objects.nonNull(age);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String name)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReflectionBean</span><span class="hljs-params">()</span> </span>&#123;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReflectionBean <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReflectionBean();  &#125;&#125;</code></pre></div><p><code>ClassBean</code>类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassBean</span> </span>&#123;    <span class="hljs-keyword">private</span> String className;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validClassName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> className != <span class="hljs-keyword">null</span> &amp;&amp; className.length() &gt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassBean</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassBean</span><span class="hljs-params">(String className)</span> </span>&#123;        <span class="hljs-keyword">this</span>.className = className;    &#125;&#125;</code></pre></div><h4 id="Construtor"><a href="#Construtor" class="headerlink" title="Construtor"></a><code>Construtor</code></h4><p>一个<code>Constructor</code>对应着类中的一个构造函数，可以使用<code>Class.getConstructors()</code>获取指定类所有的构造函数(私有无法获取)。也可以使用<code>Class.getConstructor(Class&lt;?&gt; ... paramType)</code>获取指定参数的构造方法。</p><p>测试代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;    Constructor&lt;ReflectionBean&gt; specificConstructor = reflectionBeanClass.getConstructor(String.class);    System.out.println(specificConstructor.getName());    System.out.println(Arrays.toString(specificConstructor.getParameterAnnotations()));    System.out.println(specificConstructor.getParameterCount());    System.out.println(Arrays.toString(specificConstructor.getParameterTypes()));    Constructor&lt;?&gt;[] constructors = reflectionBeanClass.getConstructors();    System.out.println(Arrays.toString(constructors));&#125;</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs txt">io.better.jdk.reflection.ReflectionBean[[Ljava.lang.annotation.Annotation;@1b701da1]1[class java.lang.String][public io.better.jdk.reflection.ReflectionBean(java.lang.String), public io.better.jdk.reflection.ReflectionBean()]</code></pre></div><p>上面代码中演示了<code>Class.getConstructors</code>和<code>Class.getConstructor(Class&lt;?&gt; ..params)</code>获取构造方法。</p><p>通过Constructor对象我们可以获取到构造方法中的<code>注解，参数，参数类型，参数数量</code>等信息，但这两种方式都不能获取私有构造方法。那如何获取私有的构造器呢？</p><p>使用<code>getDeclaredConstructors()</code>和<code>getDeclaredConstructor(Class&lt;?&gt; ..params)</code>可以获取到类中所有的构造方法，包括私有的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredConstructors</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;  <span class="hljs-comment">// 获取所有构造方法，包括私有</span>  Constructor&lt;?&gt;[] declaredConstructors = reflectionBeanClass.getDeclaredConstructors();  <span class="hljs-comment">// 获取指定构造方法</span>  Constructor&lt;ReflectionBean&gt; specificDeclaredConstructor = reflectionBeanClass.getDeclaredConstructor(String.class, Integer.class);&#125;</code></pre></div><p>介绍完<code>Constructor</code>对象的获取方式后，接下来通过<code>Constructor</code>对象来实例化目标对象。</p><p>我们可以通过<code>Constructor.newInstance(Object ...params)</code>方法传入实际的参数来创建目标对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConstructorInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;  <span class="hljs-comment">// 获取指定参数的公共构造方法</span>  Constructor&lt;ReflectionBean&gt; stringConstructor = reflectionBeanClass.getConstructor(String.class);  <span class="hljs-comment">// 实例化</span>  ReflectionBean reflectionBean = stringConstructor.newInstance(<span class="hljs-string">&quot;Constructor&quot;</span>);    System.out.println(reflectionBean);  <span class="hljs-comment">// 获取指定参数的私有构造方法</span>  Constructor&lt;ReflectionBean&gt; declaredConstructor = reflectionBeanClass.getDeclaredConstructor(String.class, Integer.class);  <span class="hljs-comment">// 设置成可访问，不设置，会出现访问私有构造方法</span>  declaredConstructor.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// 实例化</span>  reflectionBean = declaredConstructor.newInstance(<span class="hljs-string">&quot;DeclaredConstructor&quot;</span>, <span class="hljs-number">1</span>);  System.out.println(reflectionBean);&#125;</code></pre></div><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><code>Method</code></h4><p>讲完<code>Constructor</code>的使用，已经能通过其创建对象了，那如何调用目标对象中的方法呢？</p><p>与Constructor类似，Class提供了<code>getMethods，getMethod(String methodName, Class&lt;?&gt; ...paramType)</code>方法分别获取执行类的<code>所有方法(包括静态方法，父类继承下来的方法)</code>和<code>指定方法</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;    Method[] methods = reflectionBeanClass.getMethods();    Method method = reflectionBeanClass.getMethod(<span class="hljs-string">&quot;reflection&quot;</span>, String.class);    System.out.println(<span class="hljs-string">&quot;指定方法: &quot;</span> + method.getName());    <span class="hljs-keyword">for</span> (Method item : methods) &#123;        System.out.println(item);    &#125;&#125;</code></pre></div><p>执行结果：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200506163345.png" alt="image-20200506141809485"></p><p>从结果可以看出，私有方法未被获取到，和Constructor类似这两个方法不能获取私有方法，要想获取私有方法必须使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;<span class="hljs-comment">// 获取所有方法，包括私有方法</span>    Method[] methods = reflectionBeanClass.getDeclaredMethods();<span class="hljs-comment">// 获取指定私有方法</span>    Method method = reflectionBeanClass.getDeclaredMethod(<span class="hljs-string">&quot;validInfo&quot;</span>);    System.out.println(method.getName());<span class="hljs-comment">// 获取到所有方法的方法名</span>    List&lt;String&gt; methodName = Stream.of(methods).map(Method::getName).collect(Collectors.toList());    System.out.println(methodName);&#125;</code></pre></div><p>执行结果：</p><div class="code-wrapper"><pre><code class="hljs txt">validInfo[equals, toString, hashCode, getName, setName, instance, reflection, reflection, validInfo, canEqual, getAge, setAge]</code></pre></div><p>获取类中方法已经了解，接下一来尝试调用执行一下方法。</p><p>与Constructor不太一样，要想执行方法需要调用<code>invoke(Object obj, Object... args)</code>。该方法接受两个参数，第一个为目标对象(即拥有此方法的类对象)，第二为方法所需的参数。当调用私有方法时做法与Constructor一致。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInvokedMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;  Constructor&lt;ReflectionBean&gt; constructor = reflectionBeanClass.getDeclaredConstructor(String.class, Integer.class);  constructor.setAccessible(<span class="hljs-keyword">true</span>);  ReflectionBean object = constructor.newInstance(<span class="hljs-string">&quot;TEST&quot;</span>, <span class="hljs-number">1</span>);  Method method = reflectionBeanClass.getDeclaredMethod(<span class="hljs-string">&quot;validInfo&quot;</span>);  method.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// 执行方法，获取结果</span>  Object methodResult = method.invoke(object);  System.out.println(methodResult);&#125;</code></pre></div><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a><code>Field</code></h4><p>与Method类似，我们可以使用<code>getFields，getField(String name)</code>两个方法来获取类中所有非私有的字段。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;    Field[] fields = reflectionBeanClass.getFields();    <span class="hljs-keyword">for</span> (Field field : fields) &#123;        System.out.println(field);    &#125;&#125;<span class="hljs-comment">// 结果：public java.lang.Boolean io.better.jdk.reflection.ReflectionBean.sex</span></code></pre></div><p>这两个方法只能获取<code>公共字段(public修饰)</code>，<code>private，default，protected</code>都获取不到。</p><p>我们可以使用<code>getDeclaredFields</code>，<code>getDeclaredField</code>两个方法来获取所有的字段和指定字段，</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetDeclaredField</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;    Field[] fields = reflectionBeanClass.getDeclaredFields();    <span class="hljs-keyword">for</span> (Field field : fields) &#123;        System.out.println(field);    &#125;    Field age = reflectionBeanClass.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);    System.out.println(age);&#125;</code></pre></div><p>执行结果：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200506163353.png" alt="image-20200506150309477" style="zoom:50%;" /><p>如果想要获取某个字段对应的值，则需要调用<code>get(Object obj)</code>方法，传入包含此字段的目标类对象，私有字段需要调用<code>setAccessible()</code>方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFieldMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;    Constructor&lt;ReflectionBean&gt; constructor = reflectionBeanClass.getDeclaredConstructor(String.class, Integer.class);    constructor.setAccessible(<span class="hljs-keyword">true</span>);    ReflectionBean object = constructor.newInstance(<span class="hljs-string">&quot;TEST&quot;</span>, <span class="hljs-number">1</span>);    Field age = reflectionBeanClass.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);    age.setAccessible(<span class="hljs-keyword">true</span>);    System.out.println(age.getDeclaringClass());    System.out.println(age.get(object));&#125;<span class="hljs-comment">// 执行结果</span><span class="hljs-comment">// class io.better.jdk.reflection.ReflectionBean</span><span class="hljs-comment">// 1</span></code></pre></div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Constructor，Method，Field</code>三个类分别 对应类中 的<code>构造方法、方法、字段</code>，分别提供了<code>getDeclared</code>开头的方法来获取对应所有的信息。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance()"></a><code>newInstance()</code></h4><p>在获取到类的Class对象时，可以通过调用此方法来创建目标类对象，该方法会默认调用类的<code>无参构造方法</code>来创建对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNewInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  Class&lt;ReflectionBean&gt; reflectionBeanClass = ReflectionBean.class;  ReflectionBean reflectionBean = reflectionBeanClass.newInstance();  System.out.println(reflectionBean);&#125;</code></pre></div><h4 id="isInstance-Object-obj"><a href="#isInstance-Object-obj" class="headerlink" title="isInstance(Object obj)"></a><code>isInstance(Object obj)</code></h4><p>该方法用于断定指定Object是赋值兼容与此表示的对象Class ，等效<code>instanceof</code>运算符。</p><div class="code-wrapper"><pre><code class="hljs java">Class&lt;String&gt; stringClass = String.class;stringClass.isInstance(<span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// 结果=true，类型匹配</span>stringClass.isInstance(<span class="hljs-number">123456</span>); <span class="hljs-comment">// 结果=false，类型不匹配</span></code></pre></div><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="反射进行数组扩容"><a href="#反射进行数组扩容" class="headerlink" title="反射进行数组扩容"></a>反射进行数组扩容</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testArrayExtension</span><span class="hljs-params">()</span> </span>&#123;  String[] stringArray = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>&#125;;  System.out.println(<span class="hljs-string">&quot;原始数组长度: &quot;</span> + stringArray.length);  Object newStringArray = ArrayExtension(stringArray, stringArray.length * <span class="hljs-number">2</span>);  System.out.println(<span class="hljs-string">&quot;扩容后数组长度: &quot;</span> + Array.getLength(newStringArray));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">ArrayExtension</span><span class="hljs-params">(Object sourceArray, <span class="hljs-keyword">int</span> extensionLength)</span> </span>&#123;  <span class="hljs-keyword">if</span> (extensionLength &lt; Array.getLength(sourceArray))    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;扩展长度不合法&quot;</span>);  Class&lt;?&gt; componentType = sourceArray.getClass().getComponentType();  Object newStringArray = Array.newInstance(componentType, extensionLength);  System.arraycopy(sourceArray, <span class="hljs-number">0</span>, newStringArray, <span class="hljs-number">0</span>, Array.getLength(sourceArray));  <span class="hljs-keyword">return</span> newStringArray;&#125;</code></pre></div><h3 id="反射跳过泛型检查"><a href="#反射跳过泛型检查" class="headerlink" title="反射跳过泛型检查"></a>反射跳过泛型检查</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJumpTypeCheck</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  stringList.add(<span class="hljs-string">&quot;a&quot;</span>);  stringList.add(<span class="hljs-string">&quot;b&quot;</span>);  stringList.add(<span class="hljs-string">&quot;c&quot;</span>);  Class&lt;? extends List&gt; listClass = stringList.getClass();  Method addMethod = listClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);  <span class="hljs-comment">// 向集合中添加了一个int类型的值</span>  addMethod.invoke(stringList, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 结果为4</span>  System.out.println(stringList.size());&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Reflection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reflection</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-BeanDefinition注册</title>
    <link href="/2020/01/09/spring/05-spring-bean-definition-registry/"/>
    <url>/2020/01/09/spring/05-spring-bean-definition-registry/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-Bean注册"><a href="#Ioc-Bean注册" class="headerlink" title="Ioc-Bean注册"></a>Ioc-Bean注册</h1><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><blockquote><p>本文主要讲述BeanDefinitionRegistry接口是如何注册BeanDefinition？</p><p>主要讲解DefaultListableBeanFactory，AnnotationConfigApplicationContext，GenericApplicationContext三个上下文是如何对BeanDefinition进行注册的。</p></blockquote><h2 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上面讲到了BeanDefinition的读取方式，拿到BeanDefinition后需要将其注册到容器中，Spring是用什么将其注册到容器中的呢？</p><p>没错就是上面源代码中频繁提到的BeanDefinitionRegistry对象。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BeanDefinitionRegistry是包含BeanDefinition的注册的接口，这是Spring Bean工厂软件包中唯一封装Bean定义注册的接口。</p><p>标准BeanFactory接口仅涵盖对完全配置的工厂实例的访问。Spring的<code>BeanDefinitionReader</code>希望可以使用此接口的实现。</p><p>Spring核心中的已知实现者是<code>DefaultListableBeanFactory</code>和<code>GenericApplicationContext</code>。</p><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200517180016.png" alt="image-20200517161204618" style="zoom:50%;" /><p>我们看到了<code>DefaultListableBeanFactory</code>、<code>GenericApplicationContext</code>、<code>AnnotationConfigApplicationContext</code>等类。</p><p>重点关注上面几个类的实现。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AliasRegistry</span> </span>&#123;  <span class="hljs-comment">// 注册BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 根据指定的Bean名称删除BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;  <span class="hljs-comment">// 根据指定的Bean名称获取BeanDefinition</span>  <span class="hljs-function">BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;  <span class="hljs-comment">// 是否包含指定的Bean名称</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span></span>;  <span class="hljs-comment">// 返回注册器中所有的BeanDefinition名称</span>  String[] getBeanDefinitionNames(); <span class="hljs-comment">// 获取BeanDefinition的数量</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 指定的Bean名称是否被使用</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span></span>;&#125;</code></pre></div><p>接口中定义了BeanDefinition增删改查的接口，并继承了AliasRegistry接口。</p><h3 id="AliasRegistry"><a href="#AliasRegistry" class="headerlink" title="AliasRegistry"></a><code>AliasRegistry</code></h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>顾名思义AliasRegistry是一个别名注册器，用于注册别名。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnnotationConfigRegistry</span> </span>&#123;  <span class="hljs-comment">// 注册指定的Class数组</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span></span>;  <span class="hljs-comment">// 注册指定包路径下的Bean</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span></span>;&#125;</code></pre></div><h3 id="GenericApplicationContext"><a href="#GenericApplicationContext" class="headerlink" title="GenericApplicationContext"></a><code>GenericApplicationContext</code></h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>GenericApplicationContext是通用ApplicationContext实现，其内部引用了<code>DefaultListableBeanFactory</code>实例，实现BeanDefinitionRegistry接口，以便允许将任何Bean定义读取器应用于该接口。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>通用做法是通过BeanDefinitionRegistry接口注册各种Bean定义，然后调用<code>refresh()</code>以使用应用程序上下文语义来初始化这些Bean（处理org.springframework.context.ApplicationContextAware，自动检测BeanFactoryPostProcessors等）。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>与为每次刷新创建一个新的内部BeanFactory实例的其他ApplicationContext实现相反，此上下文的内部BeanFactory从一开始就可用，以便能够在其上注册BeanDefinition。<code>refresh()只能被调用一次</code>。</p><p>对于应该以可刷新方式读取特殊bean定义格式的自定义应用程序上下文实现，请考虑从<strong>AbstractRefreshableApplicationContext</strong>基类派生。</p><h4 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistry</span> </span>&#123;<span class="hljs-comment">// BeanFactory，此对象也实现了BeanDefinitionRegistry接口</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DefaultListableBeanFactory beanFactory;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericApplicationContext</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();  &#125;  <span class="hljs-comment">// 注册BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory.registerBeanDefinition(beanName, beanDefinition);  &#125;<span class="hljs-comment">// 删除BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory.removeBeanDefinition(beanName);  &#125;  <span class="hljs-comment">// 获取BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanFactory.getBeanDefinition(beanName);  &#125;<span class="hljs-comment">// Bean是否被使用</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanFactory.isBeanNameInUse(beanName);  &#125;  <span class="hljs-comment">// 注册bean别名</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String beanName, String alias)</span> </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory.registerAlias(beanName, alias);  &#125;<span class="hljs-comment">// 删除bean别名</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAlias</span><span class="hljs-params">(String alias)</span> </span>&#123;    <span class="hljs-keyword">this</span>.beanFactory.removeAlias(alias);  &#125;  <span class="hljs-comment">// 是否存在别名</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlias</span><span class="hljs-params">(String beanName)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanFactory.isAlias(beanName);  &#125;  <span class="hljs-comment">// 注册Bean</span>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanName, Class&lt;T&gt; beanClass,</span></span><span class="hljs-function"><span class="hljs-params">                               <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;    ClassDerivedBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> ClassDerivedBeanDefinition(beanClass);    <span class="hljs-keyword">if</span> (supplier != <span class="hljs-keyword">null</span>) &#123;      beanDefinition.setInstanceSupplier(supplier);    &#125;    <span class="hljs-keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;      customizer.customize(beanDefinition);    &#125;    String nameToUse = (beanName != <span class="hljs-keyword">null</span> ? beanName : beanClass.getName());    registerBeanDefinition(nameToUse, beanDefinition);  &#125;&#125;</code></pre></div><p><code>GenericApplicationContext</code>内部持有了<code>DefaultListableBeanFactory</code>引用，并简单的实现了<strong>BeanDefinitionRegistry</strong>的接口，不过最终操作还是交给了<code>DefaultListableBeanFactory</code>对象来进行完成。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGenericApplicationContext</span><span class="hljs-params">()</span> </span>&#123;  GenericApplicationContext applicationContext = <span class="hljs-keyword">new</span> GenericApplicationContext();  AnnotatedBeanDefinitionReader definitionReader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(applicationContext);  definitionReader.registerBean(IocBean.class);  applicationContext.refresh();  IocBean iocBean = applicationContext.getBean(IocBean.class);  System.out.println(iocBean);&#125;</code></pre></div><h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a><code>DefaultListableBeanFactory</code></h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>DefaultListableBeanFactory是Spring的ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现，基于BeanDefinition元数据的成熟bean工厂，可通过后处理器进行扩展。</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>典型的用法是在访问bean之前先注册所有bean定义（可能是从bean定义文件中读取）。因此，按名称查找Bean是对本地Bean定义表进行的廉价操作，该操作对预先解析的Bean定义元数据对象进行操作。对于<code>ListableBeanFactory</code>接口的替代实现，请看一下<code>StaticListableBeanFactory</code>，它管理现有的bean实例，而不是根据bean定义创建新的bean实例。</p><h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><p>代码中删除了无关的代码，因为我们关注的是<code>BeanDefinitionRegistry</code>相关的操作。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAutowireCapableBeanFactory</span></span><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigurableListableBeanFactory</span>, <span class="hljs-title">BeanDefinitionRegistry</span>, <span class="hljs-title">Serializable</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> allowBeanDefinitionOverriding = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 管理所有的BeanDefinition</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);  <span class="hljs-comment">// 管理所有的单例Bean或非单例名称，key=依赖的Class</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">64</span>);  <span class="hljs-comment">// 管理所有的单例Bean名称，key=依赖的Class</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">64</span>);  <span class="hljs-comment">// 根据注册的顺序，管理所有的BeanDefinition名称</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">256</span>);  <span class="hljs-comment">// 管理手动注册的单示例Bean</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Set&lt;String&gt; manualSingletonNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">16</span>);<span class="hljs-comment">// 构造函数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultListableBeanFactory</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>();  &#125;<span class="hljs-comment">// 注册BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<span class="hljs-comment">// 判断次BeanDefinition是否被加载过</span>    BeanDefinition existingDefinition = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 被加载过</span>      <span class="hljs-comment">// 是否允许BeanDefinition重写</span>      <span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);      &#125;      <span class="hljs-comment">// 新的BeanDefinition会覆盖就的BeanDefinition</span>      <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);    &#125;    <span class="hljs-comment">// 未被加载过</span>    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;<span class="hljs-comment">// 是否已经开始创建Bean</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) &#123;          <span class="hljs-comment">// 将BeanDefinition放入到beanDefinitionMap中</span>          <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);          List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);          updatedDefinitions.addAll(<span class="hljs-keyword">this</span>.beanDefinitionNames);          updatedDefinitions.add(beanName);          <span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;          removeManualSingletonName(beanName);        &#125;      &#125;      <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 将BeanDefinition放入到beanDefinitionMap中</span>        <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);        <span class="hljs-keyword">this</span>.beanDefinitionNames.add(beanName);        <span class="hljs-comment">// 删除</span>        removeManualSingletonName(beanName);      &#125;      <span class="hljs-keyword">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword">null</span>;    &#125;<span class="hljs-comment">// 已经存在此BeanDefinition或者此beanName已经存在</span>    <span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span> || containsSingleton(beanName)) &#123;      <span class="hljs-comment">// 重置此BeanDefinition</span>      resetBeanDefinition(beanName);    &#125;  &#125;<span class="hljs-comment">// 删除BeanDefinition</span>  <span class="hljs-comment">// ①：删除beanDefinitionNames中name，②：调用resetBeanDefinition从beanDefinitionMap中删除</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;<span class="hljs-comment">// 从Map中删除BeanDefinition</span>    BeanDefinition bd = <span class="hljs-keyword">this</span>.beanDefinitionMap.remove(beanName);    <span class="hljs-keyword">if</span> (bd == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 删除失败（不存在此BeanDefinition），抛出异常</span>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(beanName);    &#125;<span class="hljs-comment">// 是否有Bean已经被创建</span>    <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;      <span class="hljs-comment">// 加锁</span>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) &#123;        List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);       <span class="hljs-comment">// 删除</span>        updatedDefinitions.remove(beanName);        <span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;  <span class="hljs-comment">// 重新赋值</span>      &#125;    &#125;    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 直接删除</span>      <span class="hljs-keyword">this</span>.beanDefinitionNames.remove(beanName);    &#125;<span class="hljs-comment">// 重置BeanDefinition</span>    resetBeanDefinition(beanName);  &#125;<span class="hljs-comment">// 重置BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetBeanDefinition</span><span class="hljs-params">(String beanName)</span> </span>&#123;    <span class="hljs-comment">// 如果存在则删除指定Bean名称对应的合并的BeanDefinition</span>    clearMergedBeanDefinition(beanName);    destroySingleton(beanName);<span class="hljs-comment">// 执行过滤出的MergedBeanDefinitionPostProcessor</span>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;      <span class="hljs-keyword">if</span> (processor <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;        ((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);      &#125;    &#125;<span class="hljs-comment">// 遍历BeanDefinition名称Map</span>    <span class="hljs-keyword">for</span> (String bdName : <span class="hljs-keyword">this</span>.beanDefinitionNames) &#123;      <span class="hljs-keyword">if</span> (!beanName.equals(bdName)) &#123;        BeanDefinition bd = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(bdName);        <span class="hljs-keyword">if</span> (bd != <span class="hljs-keyword">null</span> &amp;&amp; beanName.equals(bd.getParentName())) &#123;          <span class="hljs-comment">// 重置BeanDefinition</span>          resetBeanDefinition(bdName);        &#125;      &#125;    &#125;  &#125;<span class="hljs-comment">// 获取BeanDefinition</span><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;    <span class="hljs-comment">// 调用beanDefinitionMap.get()</span>BeanDefinition bd = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);<span class="hljs-keyword">if</span> (bd == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 没有抛出异常</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(beanName);&#125;<span class="hljs-keyword">return</span> bd;&#125;  <span class="hljs-comment">// 是否存在BeanDefinition</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span> </span>&#123;Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);    <span class="hljs-comment">// 操作成员变量beanDefinitionMap</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanDefinitionMap.containsKey(beanName);&#125;&#125;</code></pre></div><p><code>DefaultListableBeanFactory</code>声明了多个<code>beanDefinitionNames（List类型）</code>，<code>beanDefinitionMap（Map类型）</code>等属性，它们分别用于存储<code>BeanDefinition名称</code>和<code>BeanDefinition</code>。</p><p>在对<code>BeanDefinitionRegistry</code>接口方法的实现中底层操作的都是这两个<code>beanDefinitionNames</code>，<code>beanDefinitionMap</code>属性。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDefaultListableBeanFactory</span><span class="hljs-params">()</span> </span>&#123;    DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();    BeanDefinition beanDefinition = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(IocBean.class);    beanFactory.registerBeanDefinition(IocBean.class.getName(), beanDefinition);    System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()));&#125;</code></pre></div><h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p><code>AnnotationConfigApplicationContext</code>是一个独立的应用程序上下文，接受组件类作为输入-特别是使用@Configuration注释的类，还可以使用javax.inject注释使用普通的@Component类型和符合JSR-330的类。</p><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>允许使用<code>register（Class ...）</code>方法一对一注册类，以及使用<code>scan（String ...）方法</code>进行类路径扫描，这两个方法定义在<code>AnnotationConfigRegistry</code>接口中。</p><p>如果有多个<code>@Configuration</code>类，则在<code>以后的类中定义的@Bean方法将覆盖在先前的类中定义的方法</code>。可以利用此属性通过额外的@Configuration类有意覆盖某些bean定义。</p><h4 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationConfigApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnnotationConfigRegistry</span> </span>&#123;<span class="hljs-comment">// 注解BeanDefinition的读取器和注册器</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AnnotatedBeanDefinitionReader reader;<span class="hljs-comment">// ClassPath下BeanDefinition扫描器，扫描Component，Service，Controller，Repository等注解标识的类 </span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassPathBeanDefinitionScanner scanner;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword">this</span>);  &#125;<span class="hljs-comment">// 使用指定类的Class数组进行初始化</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;    <span class="hljs-keyword">this</span>();    register(componentClasses);    refresh();  &#125;  <span class="hljs-comment">// 使用指定包路径数组进行初始化</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnnotationConfigApplicationContext</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;    <span class="hljs-keyword">this</span>();    scan(basePackages);    refresh();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;    Assert.notEmpty(componentClasses, <span class="hljs-string">&quot;At least one component class must be specified&quot;</span>);    <span class="hljs-comment">// 调用AnnotatedBeanDefinitionReader注册Bean</span>    <span class="hljs-keyword">this</span>.reader.register(componentClasses);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;    Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);    <span class="hljs-keyword">this</span>.scanner.scan(basePackages);  &#125;<span class="hljs-comment">// 重写父类的registerBean方法，因为reader拥有注册Bean的功能</span>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBean</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String beanName, Class&lt;T&gt; beanClass,</span></span><span class="hljs-function"><span class="hljs-params">                               <span class="hljs-meta">@Nullable</span> Supplier&lt;T&gt; supplier, BeanDefinitionCustomizer... customizers)</span> </span>&#123;    <span class="hljs-keyword">this</span>.reader.registerBean(beanClass, beanName, supplier, customizers);  &#125;&#125;</code></pre></div><p>AnnotationConfigApplicationContext引用了<code>ClassPathBeanDefinitionScanner</code>，<code>AnnotatedBeanDefinitionReader</code>属性。</p><p>并将最终的Bean注册交予了<code>AnnotatedBeanDefinitionReader</code>来处理，而<code>ClassPathBeanDefinitionScanner</code>则用于扫描类路径下所有带<code>Component，Service，Controller，Repository</code>注解的类。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAnnotationConfigApplicationContext</span><span class="hljs-params">()</span> </span>&#123;  AnnotationConfigApplicationContext applicationContext =     <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocBean.class);  IocBean bean = applicationContext.getBean(IocBean.class);  System.out.println(bean);&#125;</code></pre></div><p>可以看出AnnotationConfigApplicationContext的使用非常的简单，只需简单传递一个要初始化的Bean的Class即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>GenericApplicationContext</code>：对BeanDefinitionRegistry做了通用的实现，内部引用了DefaultListableBeanFactory，将操作转发给了DefaultListableBeanFactory。</p><p><code>DefaultListableBeanFactory</code>：该类封装了处理BeanDefinition的逻辑，底层操作了许多Map。</p><p><code>AnnotationConfigApplicationContext</code>：该类虽然继承了<code>GenericApplicationContext</code>类，但却每调用父类的方法，而是将注册Bean的操作转发给了内部的AnnotatedBeanDefinitionReader对象。</p><p><code>SimpleBeanDefinitionRegistry</code>：简单的BeanDefinitionRegistry，未内置工厂，可用作测试BeanDefinition 注册。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis Sql执行</title>
    <link href="/2019/12/09/mybatis/02-mybatis-sql-execute/"/>
    <url>/2019/12/09/mybatis/02-mybatis-sql-execute/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-语句执行"><a href="#Mybatis-语句执行" class="headerlink" title="Mybatis-语句执行"></a>Mybatis-语句执行</h1><h2 id="本章讲述的内容"><a href="#本章讲述的内容" class="headerlink" title="本章讲述的内容"></a>本章讲述的内容</h2><p>本章主要讲解Mybatis在启动后是如何执行Mapper文件中对应SQL语句的。带着下面几个问题我们正式进入Mybatis语句执行分析。</p><blockquote><p>1、Mybatis是如何实现一级缓存的？</p><p>2、Mybatis是如何执行SQL的？有几种执行器？</p><p>3、Mybatis是如何处理查询结果的？</p></blockquote><p>想知道如何使用Mybatis请参考<a href="https://mybatis.org/mybatis-3/zh/">Mybatis官方文档</a>。</p><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="配置XML"><a href="#配置XML" class="headerlink" title="配置XML"></a>配置XML</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;io.better.mybatis.mapper.UserMapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;io.better.mybatis.model.User&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span>        <span class="hljs-comment">&lt;!--@Table tbl_user--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;phone&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Name_Column&quot;</span>&gt;</span>            username    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span>        id,        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Name_Column&quot;</span>/&gt;</span>,        phone,        address    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByPrimaryKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--@mbg.generated--&gt;</span>        select        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span>/&gt;</span>        from tbl_user        where id = #&#123;id,jdbcType=BIGINT&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="全局配置XML"><a href="#全局配置XML" class="headerlink" title="全局配置XML"></a>全局配置XML</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BATCH&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.better.mybatis.model&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/source-code-analysis&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-comment">&lt;!--&lt;package name=&quot;io.better.mybatis.mapper&quot;/&gt;--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mybatis/mappers/UserMapper.xml&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> better create in 2020/4/19 10:30 上午</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisTest</span> </span>&#123;    SqlSessionFactory sqlSessionFactory;    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        String resource = <span class="hljs-string">&quot;mybatis/mybatis-config.xml&quot;</span>;        InputStream inputStream = Resources.getResourceAsStream(resource);        sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testList</span><span class="hljs-params">()</span> </span>&#123;        SqlSession sqlSession = sqlSessionFactory.openSession();        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        User user = mapper.selectByPrimaryKey(<span class="hljs-number">1L</span>);        System.out.println(user);    &#125;&#125;</code></pre></div><p>从代码可以看出一共执行了三个操作：</p><p>1、调用<code>SqlSessionFactory</code>创建<code>SqlSession</code>对象。</p><p>2、调用SqlSession获取Mapper代理对象。</p><p>3、调用Mapper代理对象执行目标方法获取结果。</p><h2 id="获取SqlSession"><a href="#获取SqlSession" class="headerlink" title="获取SqlSession"></a>获取SqlSession</h2><h3 id="调用openSession-创建SqlSession"><a href="#调用openSession-创建SqlSession" class="headerlink" title="调用openSession()创建SqlSession"></a>调用<code>openSession()</code>创建SqlSession</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSession <span class="hljs-title">openSession</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> SqlSession <span class="hljs-title">openSessionFromDataSource</span><span class="hljs-params">(ExecutorType execType, TransactionIsolationLevel level, <span class="hljs-keyword">boolean</span> autoCommit)</span> </span>&#123;  Transaction tx = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 获取环境配置</span>    <span class="hljs-keyword">final</span> Environment environment = configuration.getEnvironment();    <span class="hljs-comment">// 步骤①</span>    <span class="hljs-keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);    <span class="hljs-comment">// 步骤②</span>    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);    <span class="hljs-comment">// 步骤③</span>    <span class="hljs-keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);    <span class="hljs-comment">// 步骤④</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-comment">// 忽略部分代码</span>  &#125;&#125;</code></pre></div><p>上诉代码中我们需要重点关注一个点：1、<code>configuration.getDefaultExecutorType()：</code>它用于指定Executor的类型，默认即<code>ExecutorType.SIMPLE</code>。</p><p>在<code>openSessionFromDataSource</code>方法中，Mybatis做了下面几个操作：</p><ul><li>步骤①：创建TransactionFactory，类型为：<code>JdbcTransactionFactory</code>。<ul><li>对应Mybatis配置中 <transactionManager type="JDBC"/>标签。</li></ul></li><li>步骤②：创建Transaction事务对象，并对<code>autoCommit，IsolationLevel</code> 属性赋值。</li><li>步骤③：根据<code>execType</code>创建执行类型的<code>Executor</code>执行器。</li><li>步骤④：创建<code>DefaultSqlSession</code>对象。</li></ul><h4 id="创建Transaction"><a href="#创建Transaction" class="headerlink" title="创建Transaction"></a>创建<code>Transaction</code></h4><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Transaction <span class="hljs-title">newTransaction</span><span class="hljs-params">(DataSource ds, TransactionIsolationLevel level, <span class="hljs-keyword">boolean</span> autoCommit)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTransaction(ds, level, autoCommit);&#125;</code></pre></div><p>代码中直接调用<code>JdbcTransaction</code>构造器进行Transaction创建。那么JdbcTransaction将就能干什么事情呢？让我们来看看JdbcTransaction的类结构图。</p><p><img src="https://raw.githubusercontent.com/io-better-chen/better.io.images/master/images/image-20200428162608413.png" alt="image-20200428162608413"></p><p>从类图可以看出JdbcTransaction主要是负责<code>提交、回滚、关闭Transaction</code>，<code>打开、获取Connection</code>等操作。</p><h4 id="创建Executor"><a href="#创建Executor" class="headerlink" title="创建Executor"></a>创建<code>Executor</code></h4><p><code>Configuration#newExecutor(Transaction, ExecutorType)</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">newExecutor</span><span class="hljs-params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;  <span class="hljs-comment">// 判断 executorType </span>  executorType = executorType == <span class="hljs-keyword">null</span> ? defaultExecutorType : executorType;  executorType = executorType == <span class="hljs-keyword">null</span> ? ExecutorType.SIMPLE : executorType;  Executor executor;  <span class="hljs-keyword">if</span> (ExecutorType.BATCH == executorType) &#123;    <span class="hljs-comment">// 批量执行器</span>    executor = <span class="hljs-keyword">new</span> BatchExecutor(<span class="hljs-keyword">this</span>, transaction);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ExecutorType.REUSE == executorType) &#123;    <span class="hljs-comment">// 可重用执行器</span>    executor = <span class="hljs-keyword">new</span> ReuseExecutor(<span class="hljs-keyword">this</span>, transaction);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 默认执行器</span>    executor = <span class="hljs-keyword">new</span> SimpleExecutor(<span class="hljs-keyword">this</span>, transaction);  &#125;  <span class="hljs-keyword">if</span> (cacheEnabled) &#123;    <span class="hljs-comment">// 缓存执行器，类似于一个装饰器</span>    executor = <span class="hljs-keyword">new</span> CachingExecutor(executor);  &#125;  <span class="hljs-comment">// 将执行器传递给每个插件拦截器</span>  executor = (Executor) interceptorChain.pluginAll(executor);  <span class="hljs-keyword">return</span> executor;&#125;</code></pre></div><p>代码中可以看出，执行器的类型一共有三种：<code>批量-&gt;BatchExecutor，可重用-&gt;ReuseExecutor，简单-&gt;SimpleExecutor</code>。</p><p>而<code>CachingExecutor</code>是一个装饰类，包装了具体的Executor，主要用于做一些缓存操作。</p><p>默认为<code>SimpleExecutor</code>执行器，我们这里使用是<code>BatchExecutor</code>执行器。可以通过下面的配置修改：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BATCH&quot;</span>/&gt;</span></code></pre></div><p>最后将创建好的执行器交给<code>interceptorChain</code>，此处代码是为了扩展。</p><p>因为代码最终会走向<code>Plugin.wrap</code>方法中，并为其创建 <code>Plugin</code>这个代理对象（<code>如果有拦截器处理则创建，没有则无</code>）。</p><p><img src="https://raw.githubusercontent.com/io-better-chen/better.io.images/master/images/20200429161400.png" alt="image-20200429161316723"></p><h4 id="创建DefaultSqlSession"><a href="#创建DefaultSqlSession" class="headerlink" title="创建DefaultSqlSession"></a>创建<code>DefaultSqlSession</code></h4><p>源代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSqlSession</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SqlSession</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration configuration;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor executor;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> autoCommit;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> dirty;  <span class="hljs-keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultSqlSession</span><span class="hljs-params">(Configuration configuration, Executor executor, <span class="hljs-keyword">boolean</span> autoCommit)</span> </span>&#123;    <span class="hljs-keyword">this</span>.configuration = configuration;    <span class="hljs-keyword">this</span>.executor = executor;    <span class="hljs-keyword">this</span>.dirty = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">this</span>.autoCommit = autoCommit;  &#125;&#125;</code></pre></div><p>DefaultSqlSession的构造比较简单，仅仅是对类中部分属性进行赋值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在获取SqlSession阶段主要是初始化了<code>Transaction，Executor，SqlSession</code>三个对象。</p><h2 id="获取指定Mapper"><a href="#获取指定Mapper" class="headerlink" title="获取指定Mapper"></a>获取指定Mapper</h2><h3 id="调用getMapper-获取Mapper"><a href="#调用getMapper-获取Mapper" class="headerlink" title="调用getMapper()获取Mapper"></a>调用<code>getMapper()</code>获取Mapper</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// DefaultSqlSession.getMapper</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;  <span class="hljs-keyword">return</span> configuration.getMapper(type, <span class="hljs-keyword">this</span>);&#125;<span class="hljs-comment">// Configuration.getMapper</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;  <span class="hljs-keyword">return</span> mapperRegistry.getMapper(type, sqlSession);&#125;</code></pre></div><p>代码最终调用到了Configuration对象中。</p><p>因为Mybatis在启动加载阶段将所有的Mapper接口都注册到了<code>Configuration.mapperRegistry</code>对象中。</p><h3 id="创建MapperProxy"><a href="#创建MapperProxy" class="headerlink" title="创建MapperProxy"></a>创建MapperProxy</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;  <span class="hljs-comment">// 获取到MapperProxy工厂</span>  <span class="hljs-keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 创建MapperProxy对象</span>    <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  &#125;&#125;<span class="hljs-comment">// MapperProxyFactory</span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> </span>&#123;  <span class="hljs-comment">// 创建MapperProxy对象</span>  <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);  <span class="hljs-comment">// 调用JDK的Proxy.newProxyInstance() 创建实例</span>  <span class="hljs-keyword">return</span> newInstance(mapperProxy);&#125;</code></pre></div><p>从代码可以看出Mybatis在获取每一个Mapper接口时都为其创建了一个MapperProxy代理对象。最终调用JDK创建代理。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong><code>在获取Mapper接口阶段主要是操作是：为指定Mapper接口创建代理对象MapperProxy</code></strong>。</p><h2 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h2><h3 id="调用MapperProxy-invoke"><a href="#调用MapperProxy-invoke" class="headerlink" title="调用MapperProxy.invoke"></a>调用<code>MapperProxy.invoke</code></h3><p>当调用SqlSession返回Mapper接口中的方法时，会调用到MapperProxy对象的<code>invoke</code>方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  <span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;    <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// cachedInvoker会生成MapperMethodInvoker对象，并将其缓存</span>    <span class="hljs-comment">// 调用invoke执行方法</span>    <span class="hljs-keyword">return</span> cachedInvoker(method).invoke(proxy, method, args, sqlSession);  &#125;&#125;<span class="hljs-comment">// cachedInvoker方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> MapperMethodInvoker <span class="hljs-title">cachedInvoker</span><span class="hljs-params">(Method method)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  <span class="hljs-comment">// 被调用过的方法会被缓存起来，避免重复创建</span>  <span class="hljs-keyword">return</span> methodCache.computeIfAbsent(method, m -&gt; &#123;    <span class="hljs-keyword">if</span> (m.isDefault()) &#123;      <span class="hljs-keyword">if</span> (privateLookupInMethod == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultMethodInvoker(getMethodHandleJava8(method));      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultMethodInvoker(getMethodHandleJava9(method));      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 默认第一次都会创建PlainMethodInvoker。</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PlainMethodInvoker(<span class="hljs-keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));    &#125;  &#125;);&#125;</code></pre></div><p>Mybatis会先调用<code>cachedInvoker</code>方法，判断当前执行的方法是否已经创建过<code>MethodInvoker</code>：</p><p>1、如果没有则创建<code>MapperMethod</code>封装当前执行的方法：</p><p>​    1、如果执行的方法不是Default方法，则创建<code>PlainMethodInvoker</code> 并赋值。</p><p>​    2、如果执行的是Default方法，则创建<code>DefaultMethodInvoker</code>并赋值。</p><p>2、如果已经创建，则直接从<code>methodCache</code>中获取。</p><h3 id="调用MapperMethodInvoker-invoke"><a href="#调用MapperMethodInvoker-invoke" class="headerlink" title="调用MapperMethodInvoker.invoke"></a>调用<code>MapperMethodInvoker.invoke</code></h3><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  <span class="hljs-comment">// 调用上面cachedInvoker方法创建的MapperMethod对象，执行SQL</span>  <span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);&#125;</code></pre></div><p>调用上一步创建的<code>MapperMethod</code>对象执行目标Mapper方法。</p><h3 id="调用MapperMethod-execute"><a href="#调用MapperMethod-execute" class="headerlink" title="调用MapperMethod.execute"></a>调用<code>MapperMethod.execute</code></h3><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;  Object result;  <span class="hljs-comment">// 判断sql指令类型：insert，select，update，delete</span>  <span class="hljs-keyword">switch</span> (command.getType()) &#123;    Object param = method.convertArgsToSqlCommandParam(args);    <span class="hljs-comment">// 插入指令</span>    <span class="hljs-keyword">case</span> INSERT: &#123;      result = rowCountResult(sqlSession.insert(command.getName(), param));      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">// 更新指令</span>    <span class="hljs-keyword">case</span> UPDATE: &#123;      result = rowCountResult(sqlSession.update(command.getName(), param));      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">// 删除指令</span>    <span class="hljs-keyword">case</span> DELETE: &#123;      result = rowCountResult(sqlSession.delete(command.getName(), param));      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">// 查询指令</span>    <span class="hljs-keyword">case</span> SELECT:      <span class="hljs-comment">// </span>      <span class="hljs-keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;        executeWithResultHandler(sqlSession, args);        result = <span class="hljs-keyword">null</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMany()) &#123;<span class="hljs-comment">// List结果集</span>        result = executeForMany(sqlSession, args);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMap()) &#123;        <span class="hljs-comment">// Map结果集</span>        result = executeForMap(sqlSession, args);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsCursor()) &#123;        <span class="hljs-comment">// Cursor结果集</span>        result = executeForCursor(sqlSession, args);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 单个结果集</span>        result = sqlSession.selectOne(command.getName(), param);<span class="hljs-comment">// 忽略部分代码</span>      &#125;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> FLUSH:      result = sqlSession.flushStatements();      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Unknown execution method for: &quot;</span> + command.getName());  &#125;<span class="hljs-comment">// 忽略部分代码</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>我们可以看出<code>MapperMethod</code>类是执行Mapper方法的核心类。</p><p>在这个方法中我们分别看到了Mybatis对新增，更新，删除，查询所执行的操作。</p><p>通过判断<code>command</code>指令类型来断定SQL语句的类型。改对象(<code>command</code>)是在MapperMethod构造器中被初始化。</p><p><code>新增，更新，删除，查询</code>四个操作最终都调用了<code>sqlSession</code>中对应的方法。</p><p>而<code>executeForMany，executeForMap，executeForCursor</code>三个方法最终分别调用了<code>SqlSession</code>的<code>selectList，selectMap，selectCursor</code>方法。</p><p><strong><code>可以看出Mybatis的SQL执行最终是在SqlSession中完成的</code></strong>。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><h4 id="获取单个结果-selectList"><a href="#获取单个结果-selectList" class="headerlink" title="获取单个结果-selectList"></a>获取单个结果-<code>selectList</code></h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">selectOne</span><span class="hljs-params">(String statement, Object parameter)</span> </span>&#123;<span class="hljs-comment">// 调用同类的selectList方法</span>  List&lt;T&gt; list = <span class="hljs-keyword">this</span>.selectList(statement, parameter);  <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 返回第一个</span>    <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 抛出异常</span>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TooManyResultsException();  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;&#125;<span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    MappedStatement ms = configuration.getMappedStatement(statement);    <span class="hljs-comment">// 调用执行器执行查询</span>    <span class="hljs-keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);  &#125; <span class="hljs-keyword">finally</span> &#123;  &#125;&#125;</code></pre></div><p>在<code>selectOne</code>方法中调用了<code>selectList</code>方法。并对结果集进行了判断，超过一个抛出异常。</p><p>在<code>selectList</code>方法中<code>Mybatis</code>获取到了解析<code>Mapper</code>文件时生成的<code>MappedStatement</code>对象。并将其传递给了<code>Executor</code>。</p><p><strong>而上面的<code>executeForMany，executeForMap，executeForCursor</code>三个方法查询时最终都调用的是<code>selectList</code>方法</strong>。</p><h4 id="执行查询-Executor"><a href="#执行查询-Executor" class="headerlink" title="执行查询-Executor"></a>执行查询-<code>Executor</code></h4><p><code>CachingExecutor.query</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  BoundSql boundSql = ms.getBoundSql(parameterObject);  <span class="hljs-comment">// 调用包装的执行器创建缓存Key</span>  CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);  <span class="hljs-comment">// 继续调用同类Query方法</span>  <span class="hljs-keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&#125;</code></pre></div><p><code>CachingExecutor.query</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><span class="hljs-function">  <span class="hljs-keyword">throws</span> SQLException </span>&#123;  <span class="hljs-comment">// 获取缓存</span>  Cache cache = ms.getCache();  <span class="hljs-comment">// 默认第一次为空</span>  <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;    flushCacheIfRequired(ms);    <span class="hljs-keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="hljs-keyword">null</span>) &#123;      ensureNoOutParams(ms, boundSql);<span class="hljs-comment">// private final TransactionalCacheManager tcm = new TransactionalCacheManager();</span>      <span class="hljs-comment">// 从事务缓存管理器中获取，并判断是否已经存在执行过</span>      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);      <span class="hljs-comment">// 如果为空，说明没执行过</span>      <span class="hljs-keyword">if</span> (list == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 调用包装执行器执行</span>        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);        <span class="hljs-comment">// 将执行的结果放入缓存中</span>        tcm.putObject(cache, key, list); <span class="hljs-comment">// issue #578 and #116</span>      &#125;      <span class="hljs-keyword">return</span> list;    &#125;  &#125;  <span class="hljs-comment">// 调用包装执行器执行query</span>  <span class="hljs-keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&#125;</code></pre></div><p><code>BaseExecutor.query</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 父类BaseExecutor.query</span><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  List&lt;E&gt; list;  <span class="hljs-keyword">try</span> &#123;    queryStack++;    list = resultHandler == <span class="hljs-keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// </span>      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 执行查询,最终执行的结果会放入localCache对象中。</span>      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);    &#125;  &#125; <span class="hljs-keyword">finally</span> &#123;    queryStack--;  &#125;  <span class="hljs-keyword">return</span> list;&#125;</code></pre></div><p>可以看出三个方法中都是做了很多缓存操作，提高效率，</p><h4 id="核心查询-doQuery"><a href="#核心查询-doQuery" class="headerlink" title="核心查询-doQuery"></a>核心查询-<code>doQuery</code></h4><h5 id="BatchExecutor-doQuery-Core"><a href="#BatchExecutor-doQuery-Core" class="headerlink" title="BatchExecutor.doQuery (Core)"></a><code>BatchExecutor.doQuery (Core)</code></h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  Statement stmt = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">try</span> &#123;    flushStatements();    Configuration configuration = ms.getConfiguration();    <span class="hljs-comment">// 创建StatementHandler</span>    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, rowBounds, resultHandler, boundSql);    <span class="hljs-comment">// 获取Connection，如果没有则使用DataSource进行创建</span>    Connection connection = getConnection(ms.getStatementLog());    <span class="hljs-comment">// 创建Statement对象，并设置timeOut和fetchSize属性</span>    stmt = handler.prepare(connection, transaction.getTimeout());    <span class="hljs-comment">// 进行参数替换</span>    handler.parameterize(stmt);    <span class="hljs-comment">// 执行SQL查询，获取到结果集，调用ResultSetHandler.handleResultSets进行结果集处理。</span>    <span class="hljs-keyword">return</span> handler.query(stmt, resultHandler);  &#125; <span class="hljs-keyword">finally</span> &#123;    closeStatement(stmt);  &#125;&#125;</code></pre></div><p>该方法主要的作用是操作<code>Statement</code>对象。<code>1、创建StatementHandler处理对象。2、获取Connection连接。3、初始化Statement对象。4、进行参数替换。5、执行SQL完成查询</code>。</p><h4 id="处理查询结果"><a href="#处理查询结果" class="headerlink" title="处理查询结果"></a>处理查询结果</h4><h5 id="ResultSetHandler-handleResultSets"><a href="#ResultSetHandler-handleResultSets" class="headerlink" title="ResultSetHandler.handleResultSets"></a><code>ResultSetHandler.handleResultSets</code></h5><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">handleResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  <span class="hljs-keyword">final</span> List&lt;Object&gt; multipleResults = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-keyword">int</span> resultSetCount = <span class="hljs-number">0</span>;  ResultSetWrapper rsw = getFirstResultSet(stmt);<span class="hljs-comment">// 获取当前Mapper的ResultMap</span>  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();  <span class="hljs-keyword">int</span> resultMapCount = resultMaps.size();<span class="hljs-comment">// 遍历resultMaps</span>  <span class="hljs-keyword">while</span> (rsw != <span class="hljs-keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;    <span class="hljs-comment">// 获取resultMap</span>    ResultMap resultMap = resultMaps.get(resultSetCount);    <span class="hljs-comment">// 处理ResultSet</span>    handleResultSet(rsw, resultMap, multipleResults, <span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 获取下一个ResultSet</span>    rsw = getNextResultSet(stmt);    cleanUpAfterHandlingResultSet();    resultSetCount++;  &#125;<span class="hljs-comment">// 处理ResultSet</span>  String[] resultSets = mappedStatement.getResultSets();  <span class="hljs-keyword">if</span> (resultSets != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">while</span> (rsw != <span class="hljs-keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;      <span class="hljs-comment">// 获取ResultMapping</span>      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);      <span class="hljs-keyword">if</span> (parentMapping != <span class="hljs-keyword">null</span>) &#123;        String nestedResultMapId = parentMapping.getNestedResultMapId();        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);        handleResultSet(rsw, resultMap, <span class="hljs-keyword">null</span>, parentMapping);      &#125;      rsw = getNextResultSet(stmt);      cleanUpAfterHandlingResultSet();      resultSetCount++;    &#125;  &#125;  <span class="hljs-keyword">return</span> collapseSingleResultList(multipleResults);&#125;</code></pre></div><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Orm</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-核心接口</title>
    <link href="/2019/11/09/spring/02-spring-core-interface/"/>
    <url>/2019/11/09/spring/02-spring-core-interface/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc-Spring核心接口"><a href="#Ioc-Spring核心接口" class="headerlink" title="Ioc-Spring核心接口"></a>Ioc-Spring核心接口</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><ol><li>本章主要讲述Spring Ioc中几个比较重要的接口<ol><li>BeanFactory的含义及其使用</li><li>BeanFactoryPostProcessor的作用以及使用</li><li>BeanPostProcessor的作用以及使用</li><li>BeanDefinitionReader的作用以及使用</li><li>FactoryBean的作用以及使用</li></ol></li></ol></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们一般配置Bean的方式有两种：1、使用Xml进行Bean的配置，2、使用@Component，@Bean等注解进行Bean的配置。</p><p>当然Spring为了处理这些不同的配置定义了一个接口（<code>BeanDefinitionReader</code>）来统一将这些配置加载并生成BeanDefinition。</p><p>当BeanDefinition被加载后，我们出于某些因素需要修改BeanDefinition，Spring向我们提供了<code>BeanFactoryPostProcessor</code>回调接口来修改BeanDefinition（在BeanDefinition被加载进BeanFactory时进行回调）。</p><p>接着实例化具体的Bean并放入到BeanFactory中，实例化后我们可能需要对实例进行一些包装，比如 AOP。Spring向我们提供了BeanPostProcessor回调接口来对Bean实例进行包装（在Bean实例被创建后进行回调）。</p><p>此时Ioc容器已经加载完毕了，但是上面的步骤都是在Bean实例化这个步骤前后进行操作，那我们怎么在操作实例化这个步骤呢？</p><p>Spring为提供了FactoryBean这个接口，让开发人员自己实现创建Bean实例的步骤。</p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>Gradle 坐标</p><div class="code-wrapper"><pre><code class="hljs groovy">testCompile <span class="hljs-string">&#x27;junit:junit:4.13&#x27;</span>compile <span class="hljs-string">&#x27;org.aspectj:aspectjweaver:1.9.5&#x27;</span>compile <span class="hljs-string">&#x27;org.springframework:spring-beans:5.2.2.RELEASE&#x27;</span>compile <span class="hljs-string">&#x27;org.springframework:spring-aop:5.2.2.RELEASE&#x27;</span>compile <span class="hljs-string">&#x27;org.springframework:spring-context:5.2.2.RELEASE&#x27;</span></code></pre></div><p>Maven坐标</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><p>Spring 框架中</p><p><code>BeanDefinitionReader</code>：读取XML或注解配置的Bean并生成BeanDefinition</p><p><code>BeanFactoryPostProcesser</code>：BeanFactory加载BeanDefinition后增强的扩展接口，可以<code>新增/修改BeanDefinition</code>。</p><p><code>BeanPostProcesser</code>：BeanFactory实例化Bean后增强的扩展接口，可以包装Bean，例如AOP。</p><p><code>BeanFactory</code>：Spring Ioc的顶级接口，主要负责创建，实例化，管理Bean实例。</p><p><code>FactoryBean</code>：Spring提供给开发人员自定义实例化Bean的接口。</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>BeanFactory是访问Spring Bean容器的根接口。该接口由包含多个Bean定义的对象实现，每个定义均由String名称唯一标识。</p><p>它负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;  <span class="hljs-comment">// 用于区分FactoryBean实例，下面讲解FactoryBean接口时会讲到</span>  String FACTORY_BEAN_PREFIX = <span class="hljs-string">&quot;&amp;&quot;</span>;  <span class="hljs-comment">// 根据Bean名称查找并获取Bean</span>  <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 根据Bean名称和指定类型查找并获取Bean</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 返回名称查找并返回实例</span><span class="hljs-comment">// 允许在bean定义指定明确的构造器参数/工厂方法的参数，重写指定的默认参数（如果有的话）</span>  <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 根据类型返回指定实例</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 同上</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;  <span class="hljs-comment">// 返回一个提供者指定的Bean，允许懒按需检索的实例，包括可用性和唯一选择。</span>  &lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></span>;  <span class="hljs-comment">// 同上</span>  &lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span></span>;  <span class="hljs-comment">// 是否存在Bean</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;  <span class="hljs-comment">// 是否单例Bean</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>; <span class="hljs-comment">// 是否多例Bean</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;  <span class="hljs-comment">// 检查具有给定名称的Bean是否与指定的类型匹配。</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<span class="hljs-comment">// 同上</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;  <span class="hljs-comment">// 确定与给定名称的bean的类型。 更具体地讲，确定对象的该类型getBean将返回给定名称</span>  Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<span class="hljs-comment">// 同上</span>  Class&lt;?&gt; getType(String name, <span class="hljs-keyword">boolean</span> allowFactoryBeanInit) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;   <span class="hljs-comment">// 返回指定bean名字实例的所有别名，如果有的话.</span>  String[] getAliases(String name);&#125;</code></pre></div><p>我们常用的方法就是重载的<code>getBean()</code>。</p><h4 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h4><h5 id="初始生命周期"><a href="#初始生命周期" class="headerlink" title="初始生命周期"></a>初始生命周期</h5><ol><li><p><strong>BeanNameAware</strong>：将Bean在容器中的名称</p></li><li><p><strong>BeanClassLoaderAware</strong>：将加载Bean的类加载器提供给Bean的回调接口</p></li><li><p><strong>BeanFactoryAware</strong>：将管理当前Bean的BeanFactory返回给Bean的回调接口</p></li><li><p><strong>EnvironmentAware</strong>：返回当前Spring的环境变量的回调接口</p></li><li><p><strong>EmbeddedValueResolverAware</strong>：</p></li><li><p><strong>ResourceLoaderAware</strong>： 资源加载器的回调接口</p></li><li><p><strong>ApplicationEventPublisherAware</strong>：应用事件发送器获取的回调接口</p></li><li><p><strong>MessageSourceAware</strong>：MessageSource获取的回调接口</p></li><li><p><strong>ApplicationContextAware</strong>：Application Context获取的回调接口</p></li><li><p><strong>ServletContextAware</strong>：Servlet Context获取的</p></li><li><p><strong>BeanPostProcessor.postProcessBeforeInitialization</strong> ：在Bean初始化前执行</p></li><li><p><strong>InitializingBean</strong>：由BeanFactory设置完所有属性后执行</p></li><li><p><strong>自定义的初始化方法定义</strong>：<code>@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</code></p></li><li><p><strong>BeanPostProcessor.postProcessAfterInitialization</strong>：在Bean初始化后执行</p></li></ol><h5 id="销毁生命周期"><a href="#销毁生命周期" class="headerlink" title="销毁生命周期"></a>销毁生命周期</h5><ol><li><strong>DestructionAwareBeanPostProcessor.postProcessBeforeDestruction</strong></li><li><strong>DisposableBean.destroy</strong></li><li><strong>自定义的销毁方法</strong>：<code>@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</code></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>初始化流程：</p><ul><li>调用目标对象构造器创建对象</li><li>通过一系列Aware接口注入一些常用的属性</li><li>执行BeanPostProcessor.postProcessBeforeInitialization方法</li><li>执行InitializingBean.afterPropertiesSet方法</li><li>执行Bean自定义的初始化方法</li><li>执行BeanPostProcessor.postProcessAfterInitialization方法</li></ul><p>销毁流程：</p><ul><li>执行DestructionAwareBeanPostProcessors.postProcessBeforeDestruction方法</li><li>执行DisposableBean.destroy方法</li><li>执行Bean自定义的销毁方法</li></ul><h3 id="BeanFactoryPostBeanPostProcessor"><a href="#BeanFactoryPostBeanPostProcessor" class="headerlink" title="BeanFactoryPostBeanPostProcessor"></a>BeanFactoryPostBeanPostProcessor</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><code>BeanFactoryPostBeanPostProcessor</code>是一个回调接口，可以在BeanDefinition被加载到BeanFactory后如果想再次对BeanDefinition进行修改就可以实现此接口。Spring会在加载完BeanDefinition后回调此接口。</p><p>注意：再此接口实现中不能与Bean实例进行交互。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">  * 在标准初始化后修改ApplicationContext内的BeanFactory，所有的BeanDefinition都被加载，但没有被创建。</span><span class="hljs-comment">  * 可以覆盖或添加属性，甚至可以用于初始化bean</span><span class="hljs-comment">  */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException</span>;&#125;</code></pre></div><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>BeanFactoryPostProcessor主要用于当BeanDefinition被加载到BeanFactory中后，对BeanDefinition进行修改。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;io.better.spring.ioc&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocConfiguration</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IocBean <span class="hljs-title">iocBean</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IocBean();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBean</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IocBean</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;IocBean init&quot;</span>);  &#125;<span class="hljs-comment">// 忽略get/set方法</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;IocBean custom init&quot;</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;IocBean custom destroy&quot;</span>);  &#125;&#125;</code></pre></div><p>在IocConfiguration配置中我们并没有指定IocBean的初始化和销毁方法，以及懒加载</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBeanFactoryProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        System.out.println(<span class="hljs-string">&quot;BeanFactoryPostProcessor .....&quot;</span>);        BeanDefinition iocBeanDefinition = beanFactory.getBeanDefinition(<span class="hljs-string">&quot;iocBean&quot;</span>);        iocBeanDefinition.setInitMethodName(<span class="hljs-string">&quot;init&quot;</span>);        iocBeanDefinition.setDestroyMethodName(<span class="hljs-string">&quot;destroy&quot;</span>);        iocBeanDefinition.setLazyInit(<span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre></div><p>在BeanFactoryPostProcessor实现中我们为IocBean指定了初始化和销毁的方法，以及懒加载。</p><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIocBeanFactoryPostProcessor</span><span class="hljs-params">()</span> </span>&#123;    AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocConfiguration.class);    IocBean bean = (IocBean) applicationContext.getBean(<span class="hljs-string">&quot;iocBean&quot;</span>);    System.out.println(bean);    applicationContext.close();&#125;</code></pre></div><h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><div class="code-wrapper"><pre><code class="hljs txt">BeanFactoryPostProcessor .....IocBean ConstructorIocBean custom initio.better.spring.ioc.IocBean@9225652IocBean custom destroy</code></pre></div><p>从测试结果可以看出，我们在BeanFactoryPostProcessor中成功的操作了已经被BeanFactory加载的BeanDefinition并对其进行了修改。</p><p><strong>到这里你可能会想既然能修改BeanDefinition，那能不能注册一个BeanDefinition呢？</strong></p><p>要想往BeanFactory中注册一个BeanDefinition需要实现接口<code>BeanDefinitionRegistryPostProcessor</code>。</p><p>该接口是BeanFactoryPostProcessor的子接口。</p><h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a><code>BeanDefinitionRegistryPostProcessor</code></h4><h5 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;  <span class="hljs-comment">// </span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException</span>;&#125;</code></pre></div><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    System.out.println(<span class="hljs-string">&quot;BeanDefinitionRegistryPostProcessor&quot;</span>);        <span class="hljs-comment">// 创建IocRegistryTestBean的BeanDefinition</span>    BeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(IocRegistryTestBean.class)      .addPropertyValue(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;registry post processor inject&quot;</span>)      .getBeanDefinition();<span class="hljs-comment">// 注册进BeanFactory</span>    registry.registerBeanDefinition(<span class="hljs-string">&quot;iocRegistryTestBean&quot;</span>, beanDefinition);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    BeanDefinition iocRegistryTestBean = beanFactory.getBeanDefinition(<span class="hljs-string">&quot;iocRegistryTestBean&quot;</span>);    iocRegistryTestBean.setInitMethodName(<span class="hljs-string">&quot;init&quot;</span>);    iocRegistryTestBean.setDestroyMethodName(<span class="hljs-string">&quot;destroy&quot;</span>);    iocRegistryTestBean.setLazyInit(<span class="hljs-keyword">true</span>);  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;io.better.spring.ioc&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocConfiguration</span> </span>&#123;&#125;</code></pre></div><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIocBeanFactoryPostProcessor</span><span class="hljs-params">()</span> </span>&#123;  AnnotationConfigApplicationContext applicationContext =     <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocConfiguration.class);  IocRegistryTestBean iocRegistryTestBean =     (IocRegistryTestBean) applicationContext.getBean(<span class="hljs-string">&quot;iocRegistryTestBean&quot;</span>);  System.out.println(iocRegistryTestBean);  applicationContext.close();&#125;</code></pre></div><h5 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h5><div class="code-wrapper"><pre><code class="hljs txt">BeanDefinitionRegistryPostProcessorBeanFactoryPostProcessor .....IocRegistryTestBean custom initIocRegistryTestBean&#123;name=&#x27;registry post processor inject&#x27;&#125;IocRegistryTestBean custom destroy</code></pre></div><p>从执行结果看出在<code>BeanDefinitionRegistryPostProcessor</code>想BeanFactory中注册了一个IocRegistryTestBean实例，并指定了其初始化和销毁的方法以及懒加载。</p><p><code>BeanDefinitionRegistryPostProcessor</code>比<code>BeanFactoryPostProcessor</code>先执行。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>ConfigurationClassPostProcessor作用</p><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>BeanDefinitionReader是一个接口，主要是读取XML或注解标识的类并将其转成BeanDefinition，提供了使用<code>Resource</code>和<code>String location</code>参数指定加载方法。</p><p>此接口是个规范接口，具体的BeanDefinitionReader无需实现此接口。BeanDefinition读取的简单接口。</p><h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">    * 返回通过BeanDefinitionRegistry接口暴露的BeanFactory去注册BeanDefinition</span><span class="hljs-comment">    */</span>  <span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;  <span class="hljs-meta">@Nullable</span>  <span class="hljs-function">ResourceLoader <span class="hljs-title">getResourceLoader</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回用于Bean类的类加载器。</span>  <span class="hljs-comment">// null建议不要急于加载Bean类，而只是用类名注册Bean定义，并在以后解析（或永不解析）相应的类。</span>  <span class="hljs-meta">@Nullable</span>  <span class="hljs-function">ClassLoader <span class="hljs-title">getBeanClassLoader</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 返回BeanNameGenerator用于匿名Bean（未指定显式Bean名称）</span>  <span class="hljs-function">BeanNameGenerator <span class="hljs-title">getBeanNameGenerator</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 从指定的Resource中加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 从指定的Resource数组中加载BeanDefinition</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 同上</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;  <span class="hljs-comment">// 同上</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;&#125;</code></pre></div><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><p>我们以<code>XmlBeanDefinitionReader</code>为例</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;iocBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.better.spring.ioc.IocBean&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test-xml&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericXmlApplicationContext</span><span class="hljs-params">(String... resourceLocations)</span> </span>&#123;   load(resourceLocations);   refresh();&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load</span><span class="hljs-params">(String... resourceLocations)</span> </span>&#123;   <span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(resourceLocations);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> XmlBeanDefinitionReader reader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(<span class="hljs-keyword">this</span>);</code></pre></div><p>可以看出<code>GenericXmlApplicationContext</code>中持有了<code>XmlBeanDefinitionReader</code>的引用，并在初始化时调用了XmlBeanDefinitionReader的loadBeanDefinitions方法加载了BeanDefinition。</p><h4 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIocBeanDefinitionReader</span><span class="hljs-params">()</span> </span>&#123;    GenericXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> GenericXmlApplicationContext(<span class="hljs-string">&quot;Ioc.xml&quot;</span>);    System.out.println(applicationContext.getBean(<span class="hljs-string">&quot;iocBean&quot;</span>));&#125;</code></pre></div><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>BeanPostProcessor为一个接口，用于在BeanFactory实例化Bean后对Bean进行扩展需要实现的接口，Spring会在初始化每个Bean后会回调这个接口。</p><p>如果有多个<code>BeanPostProcessor</code>实例，我们可以通过设置<code>order</code>属性或实现<code>Ordered</code>接口来控制执行顺序。</p><p>BeanPostProcessor接口由两个回调方法组成，即<code>postprocessbeforeinitialize()</code>和<code>postprocessafterinitialize()</code>。</p><p>我们可以对实例化的Bean进行包装或修改，例如<code>Aop</code>（使用的是<code>AbstractAdvisingBeanPostProcessor</code>类）就是一个很好的例子。</p><h4 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;  <span class="hljs-comment">// 在InitializingBean.afterPropertiesSet或自定义初始化方法之前应用这个BeanPostProcessor</span>  <span class="hljs-comment">// 此时该Bean已经填充了属性值。</span>  <span class="hljs-comment">// 这个方法可以对原始实例进行包装，默认实现按原样返回给定的bean。</span>  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">return</span> bean;  &#125;  <span class="hljs-comment">// 在InitializingBean.afterPropertiesSet或自定义初始化方法之后应用这个BeanPostProcessor</span>  <span class="hljs-comment">// 此时该Bean已经填充了属性值。</span>  <span class="hljs-comment">// 对于FactoryBean，将为FactoryBean实例和由FactoryBean创建的对象（从Spring 2.0开始）调用此回调。 </span>  <span class="hljs-comment">// post-processor可以通过FactoryBean检查的相应bean实例来决定是应用到FactoryBean还是创建的对象，还是两者都应用。</span>  <span class="hljs-comment">// 与所有其他BeanPostProcessor回调相反，此回调还将在</span>  <span class="hljs-comment">// InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation方法触发短路后被调用。</span>  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">return</span> bean;  &#125;&#125;</code></pre></div><p>我们利用BeanPostProcessor来实现一个简单的Aop代理功能，示例代码如下：</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> IocBean) &#123;      IocBean iocBean = (IocBean) bean;      <span class="hljs-comment">// 设置Name属性</span>      iocBean.setName(<span class="hljs-string">&quot;test-BeanPostProcessor&quot;</span>);      System.out.println(<span class="hljs-string">&quot;IocBeanPostProcessor Before &quot;</span> + beanName);    &#125;    <span class="hljs-keyword">return</span> bean;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> IocBean) &#123;      System.out.println(<span class="hljs-string">&quot;IocBeanPostProcessor After &quot;</span> + beanName);            <span class="hljs-comment">// 为IocBean创建代理对象</span>      IocBean iocBean = (IocBean) bean;      Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();      enhancer.setSuperclass(IocBean.class);      enhancer.setCallback(<span class="hljs-keyword">new</span> CglibProxy(iocBean));      <span class="hljs-keyword">return</span> enhancer.create();    &#125;    <span class="hljs-keyword">return</span> bean;  &#125;&#125;<span class="hljs-comment">// Cglib执行程序</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;  <span class="hljs-keyword">private</span> Object proxyTarget;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CglibProxy</span><span class="hljs-params">(Object proxyTarget)</span> </span>&#123;    <span class="hljs-keyword">this</span>.proxyTarget = proxyTarget;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    System.out.println(<span class="hljs-string">&quot;BeanPostProcessor Cglib 代理执行前&quot;</span>);    Object invoke = method.invoke(proxyTarget, objects);    System.out.println(<span class="hljs-string">&quot;BeanPostProcessor Cglib 代理执行后&quot;</span>);    <span class="hljs-keyword">return</span> invoke;  &#125;&#125;</code></pre></div><p>代码中在Before中为IocBean的Name属性进行了赋值，在After中为IocBean创建了代理对象。</p><h4 id="测试代码-3"><a href="#测试代码-3" class="headerlink" title="测试代码"></a>测试代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIocBeanPostProcessor</span><span class="hljs-params">()</span> </span>&#123;    AnnotationConfigApplicationContext applicationContext =       <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocConfiguration.class);    IocBean bean = applicationContext.getBean(IocBean.class);    bean.say();&#125;</code></pre></div><p>当我们从Application Context获取的Bean实例是在BeanPostProcessor中创建的代理对象。</p><h4 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h4><div class="code-wrapper"><pre><code class="hljs txt">IocBean Constructor   // 初始化beanIocBeanPostProcessor Before iocBean  // 设置name属性IocBeanPostProcessor After iocBean // 创建Cglib代理IocBean Constructor // cglib代理类调用// 执行Say方法BeanPostProcessor Cglib 代理执行前IocBean  Say :test-BeanPostProcessorBeanPostProcessor Cglib 代理执行后</code></pre></div><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>FactoryBean是一个接口，如果Bean实现此接口，则它将用作对象公开的工厂，而不是直接用作将自身公开的bean实例。</p><p>FactoryBeans可以支持单例和原型，并且可以按需延迟创建对象，也可以在启动时急于创建对象。 </p><p>注意：实现此接口的Bean不能用作普通Bean。 FactoryBean以Bean样式定义（名称，别名和普通Bean一致），但是为Bean引用公开的对象始终是由<code>Factory.getObject()</code>方法创建的对象。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>在Spring中我们注册实例化Bean的方式一般都是使用<code>@Component，@Bean</code>等注解将Bean注册到容器中，整个过程对于开发人员来说是不可见的（除非阅读源码）。Spring为了更好的扩展提供了<code>FactoryBean</code>这个接口让开发人员可以自定义Bean的实例化和注册过程。</p><p>实现了<code>FactoryBean&lt;T&gt;</code>接口的Bean，Spring会向容器中注册两个Bean，一个是FactoryBean实例本身，一个是<code>FactoryBean.getObject()</code>方法返回值所代表的Bean。</p><p>根据该Bean的ID从BeanFactory中获取的实际上是<code>FactoryBean.getObject()</code>返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个<code>&amp;</code>符号来获取（和BeanFactory中的静态变量<code>FACTORY_BEAN_PREFIX</code>对应）。</p><h4 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  String OBJECT_TYPE_ATTRIBUTE = <span class="hljs-string">&quot;factoryBeanObjectType&quot;</span>;  <span class="hljs-comment">// 调用获取对象，可以是任意类型的对象</span>  <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;  <span class="hljs-comment">// 获取对象类型</span>  Class&lt;?&gt; getObjectType();  <span class="hljs-comment">// 是否是单例</span>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;&#125;</code></pre></div><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IocBean</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;IocBean init&quot;</span>);    System.out.println(<span class="hljs-keyword">this</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;IocBean custom init&quot;</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;IocBean custom destroy&quot;</span>);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    System.out.println(<span class="hljs-string">&quot;FactoryBean Create IocBean Instance&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IocBean();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;    <span class="hljs-keyword">return</span> IocBean.class;  &#125;&#125;</code></pre></div><h5 id="测试代码-4"><a href="#测试代码-4" class="headerlink" title="测试代码"></a>测试代码</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIoc</span><span class="hljs-params">()</span> </span>&#123;  AnnotationConfigApplicationContext applicationContext =     <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IocConfiguration.class);  IocBean bean = (IocBean) applicationContext.getBean(<span class="hljs-string">&quot;iocBean&quot;</span>);  IocBean factoryBean = (IocBean) applicationContext.getBean(<span class="hljs-string">&quot;&amp;iocBean&quot;</span>);  System.out.println(bean);  System.out.println(factoryBean);  applicationContext.close();&#125;</code></pre></div><h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><div class="code-wrapper"><pre><code class="hljs txt">// 第一次初始化IocBean initio.better.spring.ioc.IocBean@159f197// BeanFactory.getObject()执行FactoryBean Create IocBean Instance// 第二次初始化IocBean initio.better.spring.ioc.IocBean@6fe7aac8// sout输出内容io.better.spring.ioc.IocBean@6fe7aac8io.better.spring.ioc.IocBean@159f197</code></pre></div><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>从执行结果可以看出IocBean的实例对象是由<code>FactoryBean.getObject()</code>方法创建的。</p><p>通过打印从<code>容器获取FactoryBean实例</code>和<code>构造器中打印语句</code>得出：IocBean类被实例化了两次</p><ul><li>第一次实例化的是FactoryBean实例</li><li>第二次实例化的是IocBean实例（是通过FactoryBean.getObject方法创建的）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybaits 启动加载</title>
    <link href="/2019/10/09/mybatis/01-mybatis-init-load/"/>
    <url>/2019/10/09/mybatis/01-mybatis-init-load/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-启动加载"><a href="#Mybatis-启动加载" class="headerlink" title="Mybatis-启动加载"></a>Mybatis-启动加载</h1><h2 id="本章节讲述的内容"><a href="#本章节讲述的内容" class="headerlink" title="本章节讲述的内容"></a>本章节讲述的内容</h2><blockquote><p>本章节主要分析Mybatis在启动时做了那些操作。带着以下疑问去阅读本章内容。本章内容涉及了大量的mybatis源码。</p><p>1、Mybaits是如何解析配置文件（mybatis-config.xml）？</p><p>2、Mybaits是如何解析Mapper文件（mapper.xml）？</p><p>3、Mybatis是如何设计</p></blockquote><p>想知道如何使用Mybatis请参考<a href="https://mybatis.org/mybatis-3/zh/">Mybatis官方文档</a>。</p><h2 id="相关配置依赖"><a href="#相关配置依赖" class="headerlink" title="相关配置依赖"></a>相关配置依赖</h2><p>本文使用的Mybatis版本：<code>3.5.4</code>，不依赖任何Spring的环境。</p><h3 id="坐标依赖"><a href="#坐标依赖" class="headerlink" title="坐标依赖"></a>坐标依赖</h3><p>Maven坐标：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>Gradle坐标：</p><div class="code-wrapper"><pre><code class="hljs groovy">compile <span class="hljs-string">&#x27;org.mybatis:mybatis:3.5.4&#x27;</span></code></pre></div><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logPrefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;source-code-analysis&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.better.mybatis.model&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/source-code-analysis&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mybatis/mappers/UserMapper.xml&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p><strong>Mybatis的启动时主要分为两个阶段：<code>配置文件加载解析阶段，Mapper文件加载解析阶段</code>。</strong></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisTest</span> </span>&#123;    SqlSessionFactory sqlSessionFactory;    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        String resource = <span class="hljs-string">&quot;mybatis/mybatis-config.xml&quot;</span>;        InputStream inputStream = Resources.getResourceAsStream(resource);        sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSqlSessionFactoryInit</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(sqlSessionFactory);    &#125;&#125;</code></pre></div><h2 id="配置文件加载解析阶段"><a href="#配置文件加载解析阶段" class="headerlink" title="配置文件加载解析阶段"></a>配置文件加载解析阶段</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在这个阶段我们会去了解Mybatis是如何解析配置文件的？</p><h3 id="构建开始"><a href="#构建开始" class="headerlink" title="构建开始"></a>构建开始</h3><p>从官网文档我们知道使用Mybatis第一步就是使用<code>SqlSessionFactoryBuilder</code>来构建<code>SqlSessionFactory</code>。</p><p>而<code>SqlSessionFactoryBuilder</code>类提供了多个重载的<code>build</code>方法：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164710.png" alt="image-20200430102857721" style="zoom:50%;" /><p>这里我们使用的是<code>build(InputStream)</code>方法。进入该方法的源代码：</p><h3 id="执行-SqlSessionFactoryBuilder-build"><a href="#执行-SqlSessionFactoryBuilder-build" class="headerlink" title="执行-SqlSessionFactoryBuilder.build()"></a>执行-<code>SqlSessionFactoryBuilder.build()</code></h3><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 创建XMLConfigBuilder，该对象用于解析Mybatis配置文件</span>    XMLConfigBuilder parser = <span class="hljs-keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);    <span class="hljs-comment">// build会用解析配置文件的结果来创建SqlSessionFactory</span>    <span class="hljs-keyword">return</span> build(parser.parse());  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  &#125; <span class="hljs-keyword">finally</span> &#123;&#125;&#125;</code></pre></div><p>其中 <code>build</code>方法比较简单，就是使用<code>XMLConfigBuilder.parse</code>生成的<code>Configuration</code>对象创建<code>SqlSessionFactory</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(Configuration config)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSessionFactory(config);&#125;</code></pre></div><p>而<code>XMLConfigBuilder.parse</code>方法主要描述了Mybatis解析配置文件并生成Configuration对象的过程。</p><p>成员变量：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164704.png" alt="image-20200430103839043"></p><ul><li><code>parsed：</code>标识了配置是否已经解析。</li><li><code>parser：</code>用于解析XML配置文件</li><li><code>environment：</code>Mybatis的环境配置</li><li><code>localReflectorFactory：</code>反射工厂</li></ul><p>构造器：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164659.png" alt="image-20200430104004899"></p><p><code>org.apache.ibatis.builder.xml.XMLConfigBuilder#parse</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (parsed) &#123;<span class="hljs-comment">// 已经解析过直接抛出异常</span>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);  &#125;  parsed = <span class="hljs-keyword">true</span>;<span class="hljs-comment">// 将parsed置为true，避免重复解析。</span><span class="hljs-comment">// 调用parser获取配置文件中的configuration节点</span>  <span class="hljs-comment">// 调用parseConfiguration方法继续解析</span>  parseConfiguration(parser.evalNode(<span class="hljs-string">&quot;/configuration&quot;</span>));  <span class="hljs-keyword">return</span> configuration;&#125;</code></pre></div><h3 id="执行-XMLConfigBuilder-parseConfiguration"><a href="#执行-XMLConfigBuilder-parseConfiguration" class="headerlink" title="执行-XMLConfigBuilder.parseConfiguration()"></a>执行-<code>XMLConfigBuilder.parseConfiguration()</code></h3><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 解析properties标签配置</span>    propertiesElement(root.evalNode(<span class="hljs-string">&quot;properties&quot;</span>));    <span class="hljs-comment">// 解析settings标签配置</span>    Properties settings = settingsAsProperties(root.evalNode(<span class="hljs-string">&quot;settings&quot;</span>));<span class="hljs-comment">// 使用setting配置日志实现类</span>    loadCustomLogImpl(settings);    <span class="hljs-comment">// 解析typeAliases标签配置</span>    typeAliasesElement(root.evalNode(<span class="hljs-string">&quot;typeAliases&quot;</span>));    <span class="hljs-comment">// 解析plugins标签配置</span>    pluginElement(root.evalNode(<span class="hljs-string">&quot;plugins&quot;</span>));    <span class="hljs-comment">// 使用settings配置对configuration对象中的属性进行赋值</span>    settingsElement(settings);    <span class="hljs-comment">// 解析environments标签配置</span>    environmentsElement(root.evalNode(<span class="hljs-string">&quot;environments&quot;</span>));    <span class="hljs-comment">// 解析mappers标签配置, 开启Mapper文件解析阶段</span>    mapperElement(root.evalNode(<span class="hljs-string">&quot;mappers&quot;</span>));  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);  &#125;&#125;</code></pre></div><p>在<code>parseConfiguration</code>方法中，Mybatis对配置中的不同标签分别进行了处理，这里只列举常用的标签配置，例如：<code>properties，settings，typeAliases，plugins，environments，mappers</code>等标签进行了处理。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 解析properties标签配置</span>    propertiesElement(root.evalNode(<span class="hljs-string">&quot;properties&quot;</span>));    <span class="hljs-comment">// 解析settings标签配置</span>    Properties settings = settingsAsProperties(root.evalNode(<span class="hljs-string">&quot;settings&quot;</span>));<span class="hljs-comment">// 使用setting配置日志实现类</span>    loadCustomLogImpl(settings);    <span class="hljs-comment">// 解析typeAliases标签配置</span>    typeAliasesElement(root.evalNode(<span class="hljs-string">&quot;typeAliases&quot;</span>));    <span class="hljs-comment">// 解析plugins标签配置</span>    pluginElement(root.evalNode(<span class="hljs-string">&quot;plugins&quot;</span>));    <span class="hljs-comment">// 使用settings配置对configuration对象中的属性进行赋值</span>    settingsElement(settings);    <span class="hljs-comment">// 解析environments标签配置</span>    environmentsElement(root.evalNode(<span class="hljs-string">&quot;environments&quot;</span>));    <span class="hljs-comment">// 解析mappers标签配置, 开启Mapper文件解析阶段</span>    mapperElement(root.evalNode(<span class="hljs-string">&quot;mappers&quot;</span>));  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);  &#125;&#125;</code></pre></div><h4 id="解析Properties标签"><a href="#解析Properties标签" class="headerlink" title="解析Properties标签"></a>解析<code>Properties</code>标签</h4><p>从上面代码可以看出<code>propertiesElement</code>方法是解析Properties标签的核心方法，源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">propertiesElement</span><span class="hljs-params">(XNode context)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 获取properties标签中resource和url配置</span>    String resource = context.getStringAttribute(<span class="hljs-string">&quot;resource&quot;</span>);    String url = context.getStringAttribute(<span class="hljs-string">&quot;url&quot;</span>);    <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 使用resource路径加载properties</span>      defaults.putAll(Resources.getResourceAsProperties(resource));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 使用url加载properties</span>      defaults.putAll(Resources.getUrlAsProperties(url));    &#125;    <span class="hljs-comment">// 获取到configuration中已有的属性</span>    Properties vars = configuration.getVariables();    <span class="hljs-keyword">if</span> (vars != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 合并</span>      defaults.putAll(vars);    &#125;     parser.setVariables(defaults);    <span class="hljs-comment">// 重新赋值</span>    configuration.setVariables(defaults);  &#125;&#125;</code></pre></div><p>可以看出解析出来的<code>Properties</code>属性，最终被赋值到了<code>Configuration</code>中的<code>variables</code>对象中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Configuration的成员变量</span><span class="hljs-keyword">protected</span> Properties variables = <span class="hljs-keyword">new</span> Properties();</code></pre></div><h4 id="解析Settings标签"><a href="#解析Settings标签" class="headerlink" title="解析Settings标签"></a>解析<code>Settings</code>标签</h4><p>使用类似的方式查看<code>settingsAsProperties</code>方法中处理<code>Setting</code>标签的逻辑。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Properties <span class="hljs-title">settingsAsProperties</span><span class="hljs-params">(XNode context)</span> </span>&#123;  <span class="hljs-keyword">if</span> (context == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Properties();  &#125;  <span class="hljs-comment">// 获取所有setting子节点，并将其转成properties</span>  Properties props = context.getChildrenAsProperties();<span class="hljs-comment">// 通过反射获取Configuration类的元数据信息</span>  MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);  <span class="hljs-comment">// 判断配置的属性在Configuration是否存在</span>  <span class="hljs-keyword">for</span> (Object key : props.keySet()) &#123;    <span class="hljs-comment">// 判断Configuration对象是否存在此配置的Setter方法。</span>    <span class="hljs-keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;此配置无效：&quot;</span> + key);    &#125;  &#125;  <span class="hljs-keyword">return</span> props;&#125;</code></pre></div><p><code>MetaClass.forClass</code>方法作用是使用<code>localReflectorFactory</code>创建一个<code>Reflector</code>实例，该实例中包含了Configuration类所有的<code>构造器，方法，属性</code>等。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164650.png" alt=""></p><h4 id="使用Settings标签"><a href="#使用Settings标签" class="headerlink" title="使用Settings标签"></a>使用<code>Settings</code>标签</h4><p>上面我们知道了<code>Settings</code>配置时如何解析的，但却没有使用到<code>Settings</code>配置。</p><p><code>loadCustomVfs(settings)：</code>忽略</p><p> <code>loadCustomLogImpl(settings)：</code>设置Mybatis的日志实现。</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164645.png" alt="image-20200430111703591"  /><p><code>settingsElement(settings)：</code>设置Mybatis所有全局配置，Settings没有则使用默认配置。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164633.png" alt="image-20200430111538374"></p><h4 id="解析typeAliasesElement标签"><a href="#解析typeAliasesElement标签" class="headerlink" title="解析typeAliasesElement标签"></a>解析<code>typeAliasesElement</code>标签</h4><p>源代码如下:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">typeAliasesElement</span><span class="hljs-params">(XNode parent)</span> </span>&#123;  <span class="hljs-comment">// 获取到typeAliases标签下所有的子标签</span>  <span class="hljs-keyword">for</span> (XNode child : parent.getChildren()) &#123;    <span class="hljs-comment">// 如果标签以package开头，说明配置的是整个包的别名</span>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;package&quot;</span>.equals(child.getName())) &#123;      String typeAliasPackage = child.getStringAttribute(<span class="hljs-string">&quot;name&quot;</span>);      <span class="hljs-comment">// registerAliases方法会扫描整个包下的类，并生成其对应的Class对象</span>      <span class="hljs-comment">// 最后添加到configuration.typeAliasRegistry属性对象中</span>      configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);    &#125;     <span class="hljs-comment">// 否则就是以typeAlias开头的标签，配置的是单个别名</span>    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 获取到别名</span>      String alias = child.getStringAttribute(<span class="hljs-string">&quot;alias&quot;</span>);      <span class="hljs-comment">// 获取别名对应的class</span>      String type = child.getStringAttribute(<span class="hljs-string">&quot;type&quot;</span>);      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 根据type解析出其真实的class对象</span>        Class&lt;?&gt; clazz = Resources.classForName(type);        <span class="hljs-keyword">if</span> (alias == <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">// 别名为空，默认使用类名做为别名</span>          typeAliasRegistry.registerAlias(clazz);        &#125; <span class="hljs-keyword">else</span> &#123;          typeAliasRegistry.registerAlias(alias, clazz);        &#125;      &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;      &#125;    &#125;  &#125;&#125;</code></pre></div><p>从代码可以看出配置<code>typeAliases</code>有两种方式：</p><p>1、使用package标签配置整个包下的别名。</p><p>2、使用typeAlias标签配置单个别名。</p><p>获取到<code>别名对应的Class对象</code>后，最终调用了<code>typeAliasRegistry.registerAlias</code>方法注册了别名。而<code>typeAliasRegistry</code>对象引用之Configuration对象。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164624.png" alt="image-20200430112247768"></p><p>让我们进入<code>typeAliasRegistry.registerAlias</code>方法查看具体注册逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String alias, Class&lt;?&gt; value)</span> </span>&#123;  <span class="hljs-keyword">if</span> (alias == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeException(<span class="hljs-string">&quot;The parameter alias cannot be null&quot;</span>);  &#125;  <span class="hljs-comment">// issue #748</span>  String key = alias.toLowerCase(Locale.ENGLISH);  <span class="hljs-comment">// 判断alias是否已经存在，且对应的class不一致，抛出异常。</span>  <span class="hljs-keyword">if</span> (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != <span class="hljs-keyword">null</span> &amp;&amp; !typeAliases.get(key).equals(value)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeException(<span class="hljs-string">&quot;&quot;</span>);  &#125;  <span class="hljs-comment">// 放入typeAliases中</span>  typeAliases.put(key, value);&#125;</code></pre></div><p>让我们看一下该类的结构图：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164616.png" alt="image-20200430112955479"></p><p>从类结构图能看出<code>TypeAliasRegistry</code>类中重载了很多<code>registerAliases</code>方法，同时<code>typeAliases</code>保存了所有注册的别名信息。并且在初始化时默认添加了很多基础类型对应的别名。</p><p>结论：Mybatis将解析的别名配置，最终放入了<code>Configuration</code>中的<code>TypeAliasRegistry</code>对象中。</p><h4 id="解析plugins标签"><a href="#解析plugins标签" class="headerlink" title="解析plugins标签"></a>解析<code>plugins</code>标签</h4><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pluginElement</span><span class="hljs-params">(XNode parent)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">for</span> (XNode child : parent.getChildren()) &#123;      <span class="hljs-comment">// 获取配置的interceptor对应的class信息</span>      String interceptor = child.getStringAttribute(<span class="hljs-string">&quot;interceptor&quot;</span>);      <span class="hljs-comment">// 获取plugin标签下的属性</span>      Properties properties = child.getChildrenAsProperties();      <span class="hljs-comment">// resolveClass方法解析具体interceptor的class</span>      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();      <span class="hljs-comment">// 将属性赋值给Interceptor</span>      interceptorInstance.setProperties(properties);      <span class="hljs-comment">// 添加到Configuration中</span>      configuration.addInterceptor(interceptorInstance);    &#125;  &#125;&#125;</code></pre></div><p>可以看出解析Interceptor最终通过反射初始化被添加到了Configuration中 。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164611.png" alt="image-20200430141031684"></p><h4 id="解析environmentsElement标签"><a href="#解析environmentsElement标签" class="headerlink" title="解析environmentsElement标签"></a>解析<code>environmentsElement</code>标签</h4><p>参考Xml：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/source-code-analysis&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></code></pre></div><p>源代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">environmentsElement</span><span class="hljs-params">(XNode context)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span> (environment == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 获取默认的environment，即上面的development</span>      environment = context.getStringAttribute(<span class="hljs-string">&quot;default&quot;</span>);    &#125;    <span class="hljs-comment">// 获取到所有的environment子标签</span>    <span class="hljs-keyword">for</span> (XNode child : context.getChildren()) &#123;      String id = child.getStringAttribute(<span class="hljs-string">&quot;id&quot;</span>);      <span class="hljs-comment">// environment是否和默认配置的一致</span>      <span class="hljs-keyword">if</span> (isSpecifiedEnvironment(id)) &#123;        <span class="hljs-comment">// 创建事务管理器，即上面的JDBC事务管理器</span>        TransactionFactory txFactory = transactionManagerElement(child.evalNode(<span class="hljs-string">&quot;transactionManager&quot;</span>));        <span class="hljs-comment">// 创建数据源工厂</span>        DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class="hljs-string">&quot;dataSource&quot;</span>));        <span class="hljs-comment">// 并获取到数据源</span>        DataSource dataSource = dsFactory.getDataSource();        <span class="hljs-comment">// 构建Environment</span>        Environment.Builder environmentBuilder = <span class="hljs-keyword">new</span> Environment.Builder(id)          .transactionFactory(txFactory)          .dataSource(dataSource);        <span class="hljs-comment">// 赋值给configuration对象</span>        configuration.setEnvironment(environmentBuilder.build());      &#125;    &#125;  &#125;&#125;</code></pre></div><p>从代码可以看出，Mybatis获取环境变量后创建了两个核心对象：1、TransactionFactory。2、DataSource，其对应的方法是</p><p><code>transactionManagerElement()</code>， <code>dataSourceElement()</code>两个方法。底层实现都是通过反射进行实例化。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164602.png" alt="image-20200430142709538"></p><p>我们以<code>PooledDataSourceFactory</code>子类为例。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164552.png" alt="image-20200430142750298"></p><p>至此Mybatis的第一阶段配置文件的解析到此结束，这里还有Mapper文件的解析（下面讲解）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>解析出来的<code>Properties</code>配置，最终被赋值到了<code>Configuration</code>中的<code>variables</code>对象中。</li><li>解析出来的<code>typeAliases</code>配置，最终放入了<code>Configuration</code>中的<code>typeAliasRegistry</code>对象中。</li><li>解析出来的<code>Plugins</code>配置，最终放入了Configuration中的<code>interceptorChain</code>对象中。</li><li>解析出来的<code>environments</code>配置，用于<code>创建了数据源和事务工厂</code>。最终构建<code>Environment</code>对象赋值给Configuration中。</li></ul><p>从上面处理流程可以看出Configuration非常的重要，几乎所有的配置最终都会汇聚到Configuration对象中。</p><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><div class="code-wrapper"><pre><code class="hljs txt">&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream) -&gt; Mybatis构建入口   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration -&gt; 解析configuration标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#propertiesElement -&gt; 解析properties标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#settingsAsProperties -&gt; 解析settings标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#typeAliasesElement -&gt; 解析typeAliases标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#pluginElement -&gt; 解析plugins标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#environmentsElement -&gt; 解析environments标签配置   &gt; org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement -&gt; 解析mappers标签配置</code></pre></div><h2 id="Mapper文件加载解析阶段"><a href="#Mapper文件加载解析阶段" class="headerlink" title="Mapper文件加载解析阶段"></a>Mapper文件加载解析阶段</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在这个阶段我们将深入了解Mybatis是如何解析Mapper文件。如何绑定Mapper接口和文件的关系。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>在进入分析之前我们先思考几个问题：</p><p>1、Mybatis是如何<code>Select，Insert，Delete，Update</code>标签的？</p><p>2、Mybatis是如何处理<code>Include</code>标签的？</p><p>3、Mybatis是如何处理动态SQL标签（<code>set，foreach，if</code>）？</p><p>4、Mybatis是如何处理<code>resultMap</code>标签的？</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>在上个阶段的最后一行方法：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164546.png" alt="image-20200430144550431"></p><p>红圈内的方法就是解析Mapper文件流程的入口方法。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164537.png" alt="image-20200430151542891"></p><p>从图中可以看出解析Mapper文件有两种方式：</p><ol><li><p>使用Package标签扫描整个包下的Mapper接完成注册。</p></li><li><p>使用Mapper标签配置单个Mapper。</p><ol><li>Mapper标签支持三种方式 ：<code>resource（路径），url（网络），class（class类）</code>来加载Mapper。</li></ol></li></ol><h3 id="使用Package解析"><a href="#使用Package解析" class="headerlink" title="使用Package解析"></a>使用<code>Package</code>解析</h3><p>进入 <code>configuration.addMappers(mapperPackage)</code>方法，源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addMappers</span><span class="hljs-params">(String packageName)</span> </span>&#123;  mapperRegistry.addMappers(packageName);&#125;</code></pre></div><p>从<code>mapperRegistry</code>对象的命名可以看出，该对象主要是负责注册Mapper的。</p><p>进入<code>addMappers</code>方法：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164530.png" alt="image-20200430163542757"  /><p>代码会获取到包下所有Mapper对应的Class信息，并进行遍历调用 <code>addMapper</code>方法。</p><p>我们可以看出Mapper解析是在MapperRegistry类中完成的，那么MapperRegistry是如何存储注册的Mapper的，来看看其类结构图：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164524.png" alt="image-20200430163959992"></p><p><code>knownMappers</code>充当了一个重要的角色，它存储了注册过的Mapper。而<code>MapperProxyFactory</code>对象则用于创建MapperProxy对象，此对象会对Mapper进行代理。</p><p>接着进入<code>addMapper</code>方法查看添加细节。</p><h4 id="执行MapperRegistry-addMapper添加Mapper"><a href="#执行MapperRegistry-addMapper添加Mapper" class="headerlink" title="执行MapperRegistry.addMapper添加Mapper"></a>执行<code>MapperRegistry.addMapper</code>添加<code>Mapper</code></h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;  <span class="hljs-keyword">if</span> (type.isInterface()) &#123;<span class="hljs-comment">// 接口才处理</span>    <span class="hljs-keyword">if</span> (hasMapper(type)) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;此Mapper已经存在&quot;</span>);    &#125;    <span class="hljs-keyword">boolean</span> loadCompleted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">try</span> &#123;      knownMappers.put(type, <span class="hljs-keyword">new</span> MapperProxyFactory&lt;&gt;(type));      <span class="hljs-comment">// 创建MapperAnnotationBuilder构建起</span>      MapperAnnotationBuilder parser = <span class="hljs-keyword">new</span> MapperAnnotationBuilder(config, type);      <span class="hljs-comment">// 构建Mapper</span>      parser.parse();      loadCompleted = <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;&#125;  &#125;&#125;</code></pre></div><p>该方法主要做了以下几个操作：</p><ul><li>将Mapper对应的Class对象放入knownMappers对象中。</li><li>创建MapperAnnotationBuilder构建器构建Mapper。</li></ul><h4 id="执行MapperAnnotationBuilder-parse解析Mapper"><a href="#执行MapperAnnotationBuilder-parse解析Mapper" class="headerlink" title="执行MapperAnnotationBuilder.parse解析Mapper"></a>执行<code>MapperAnnotationBuilder.parse</code>解析<code>Mapper</code></h4><p>源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;  String resource = type.toString();  <span class="hljs-keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;<span class="hljs-comment">// 判断当前资源是否加载过</span>    <span class="hljs-comment">// 步骤①</span>    loadXmlResource();    configuration.addLoadedResource(resource);<span class="hljs-comment">// 添加到Configuration对象中，标识已经加载过</span>    assistant.setCurrentNamespace(type.getName());    parseCache();    parseCacheRef();    <span class="hljs-keyword">for</span> (Method method : type.getMethods()) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (!method.isBridge()) &#123;          <span class="hljs-comment">// 步骤②</span>          parseStatement(method);        &#125;      &#125; <span class="hljs-keyword">catch</span> (IncompleteElementException e) &#123;&#125;    &#125;  &#125;  parsePendingMethods();&#125;</code></pre></div><p>代码中我们看到了最为重要的两个方法：<code>loadXmlResource()：</code>用于加载Mapper对应的Xml文件，<code>parseStatement()</code>：解析Mapper方法中的注解信息。</p><p>解析过的<code>resource</code>最终会添加到Configuration中的<code>loadedResources</code>（Set类型）对象中。</p><h5 id="loadXmlResource"><a href="#loadXmlResource" class="headerlink" title="loadXmlResource"></a><code>loadXmlResource</code></h5><p>从上面可以得知该方法主要用于解析Mapper对应的xml文件。源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadXmlResource</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (!configuration.isResourceLoaded(<span class="hljs-string">&quot;namespace:&quot;</span> + type.getName())) &#123;    <span class="hljs-comment">// 将全类名中的.替换成/,以方便下面Resources获取输入流</span>    <span class="hljs-comment">// io.better.mybatis.mapper.UserMapper -&gt; io/better/mybatis/mapper/UserMapper.xml</span>    String xmlResource = type.getName().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-string">&quot;.xml&quot;</span>;    <span class="hljs-comment">// 获取到Mapper对应的Xml文件输入流</span>    InputStream inputStream = type.getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span> + xmlResource);    <span class="hljs-keyword">if</span> (inputStream == <span class="hljs-keyword">null</span>) &#123;        inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);    &#125;    <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// 步骤①</span>      XMLMapperBuilder xmlParser = <span class="hljs-keyword">new</span> XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());      <span class="hljs-comment">// 步骤②</span>      xmlParser.parse();    &#125;  &#125;&#125;</code></pre></div><p>从代码中可以看出，Mybatis通过替换<code>Mapper全路径</code>获取到<code>xml对应resource中的目录层级</code>，并获取到InputStream流。</p><p>举例：<code>io.better.mybatis.mapper.UserMapper -&gt; resource/io/better/mybatis/mapper/UserMapper.xml</code>。</p><p><strong>所以使用原生Mybatis需要注意xml放置的位置</strong>。</p><p>紧接着Mybatis创建了<code>XMLMapperBuilder</code>对象，调用其parse方法进一步的解析xml文件。</p><p>关于上面步骤①和步骤②的流程下面<code>Resource解析方式</code>会复用到，如果需要了解请直接跳转至Resource解析方法。</p><h5 id="parseStatement"><a href="#parseStatement" class="headerlink" title="parseStatement"></a><code>parseStatement</code></h5><p>新版Mybatis支持注解执行SQL语句，通过<code>@SELECT，@INSERT，@UPDATE，@DELETE</code>注解来执行SQL语句。此方法就是解析这些注解并生成<code>MappedStatement</code>对象。</p><p>源代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parseStatement</span><span class="hljs-params">(Method method)</span> </span>&#123;  <span class="hljs-comment">// 获取参数来类型</span>  Class&lt;?&gt; parameterTypeClass = getParameterType(method);  LanguageDriver languageDriver = getLanguageDriver(method);  <span class="hljs-comment">// 获取到注解中编写的SQL语句</span>  SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);  <span class="hljs-keyword">if</span> (sqlSource != <span class="hljs-keyword">null</span>) &#123;    Options options = method.getAnnotation(Options.class);    <span class="hljs-comment">// 生成statementId</span>    <span class="hljs-keyword">final</span> String mappedStatementId = type.getName() + <span class="hljs-string">&quot;.&quot;</span> + method.getName();    Integer fetchSize = <span class="hljs-keyword">null</span>;    Integer timeout = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 默认为PreparedStatement类型</span>    StatementType statementType = StatementType.PREPARED;    ResultSetType resultSetType = configuration.getDefaultResultSetType();    <span class="hljs-comment">//  获取到SQL指令类型，新增? 更新? 查询? 删除?</span>    SqlCommandType sqlCommandType = getSqlCommandType(method);    <span class="hljs-keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;    <span class="hljs-keyword">boolean</span> flushCache = !isSelect;    <span class="hljs-keyword">boolean</span> useCache = isSelect;<span class="hljs-comment">// 获取主键生成器</span>    KeyGenerator keyGenerator;    String keyProperty = <span class="hljs-keyword">null</span>;    String keyColumn = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">if</span> (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) &#123;      <span class="hljs-comment">// first check for SelectKey annotation - that overrides everything else</span>      SelectKey selectKey = method.getAnnotation(SelectKey.class);      <span class="hljs-keyword">if</span> (selectKey != <span class="hljs-keyword">null</span>) &#123;        keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);        keyProperty = selectKey.keyProperty();      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options == <span class="hljs-keyword">null</span>) &#123;        keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;      &#125; <span class="hljs-keyword">else</span> &#123;        keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;        keyProperty = options.keyProperty();        keyColumn = options.keyColumn();      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      keyGenerator = NoKeyGenerator.INSTANCE;    &#125;    <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (FlushCachePolicy.TRUE.equals(options.flushCache())) &#123;        flushCache = <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (FlushCachePolicy.FALSE.equals(options.flushCache())) &#123;        flushCache = <span class="hljs-keyword">false</span>;      &#125;      useCache = options.useCache();      fetchSize = options.fetchSize() &gt; -<span class="hljs-number">1</span> || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : <span class="hljs-keyword">null</span>; <span class="hljs-comment">//issue #348</span>      timeout = options.timeout() &gt; -<span class="hljs-number">1</span> ? options.timeout() : <span class="hljs-keyword">null</span>;      statementType = options.statementType();      <span class="hljs-keyword">if</span> (options.resultSetType() != ResultSetType.DEFAULT) &#123;        resultSetType = options.resultSetType();      &#125;    &#125;    String resultMapId = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 获取ResultMap对象</span>    ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);    <span class="hljs-keyword">if</span> (resultMapAnnotation != <span class="hljs-keyword">null</span>) &#123;      resultMapId = String.join(<span class="hljs-string">&quot;,&quot;</span>, resultMapAnnotation.value());    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isSelect) &#123;      resultMapId = parseResultMap(method);    &#125;    <span class="hljs-comment">// 忽略参数</span>    <span class="hljs-comment">// 构建MappedStatement</span>    assistant.addMappedStatement();  &#125;&#125;</code></pre></div><p>方法内部创建的对象和Mapper标签几乎一致，并且这种方式代码阅读行较差，简单的SQL语句还行，但是复杂的不行。此处不做细致讲解。（后期可能补上）。</p><h3 id="使用Mapper标签解析"><a href="#使用Mapper标签解析" class="headerlink" title="使用Mapper标签解析"></a>使用<code>Mapper</code>标签解析</h3><p>入口：</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164159.png" alt="image-20200430183533866"></p><p>可以看出一共有三种方式，分别是<code>resource，url，class</code> 。前两种最终都创建了XMLMapperBuilder对象，而最后一种和Package解析方式类似。</p><p>我们重点关注<code>XMLMapperBuilder</code>这个对象。到这里与Package解析中的<code>loadXmlResource</code>方法处理一致。</p><h4 id="执行XMLMapperBuilder-parse"><a href="#执行XMLMapperBuilder-parse" class="headerlink" title="执行XMLMapperBuilder.parse"></a>执行<code>XMLMapperBuilder.parse</code></h4><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501112922.png" alt="image-20200501112922353" style="zoom:50%;" /><p>重点关注两个方法，分别是：<code>configurationElement：</code>用于解析XML中各个标签，<code>bindMapperForNamespace：</code>将Mapper接口绑定到Configuration上。</p><h4 id="执行XMLMapperBuilder-configurationElement"><a href="#执行XMLMapperBuilder-configurationElement" class="headerlink" title="执行XMLMapperBuilder.configurationElement"></a>执行<code>XMLMapperBuilder.configurationElement</code></h4><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501113148.png" alt="image-20200501113147828"></p><p>红圈中我们能够看到Mybatis对XML中的各个标签都进行了处理。</p><ul><li><div class="code-wrapper"><pre><code>parameterMapElement -&gt; 处理parameterMap标签。<pre><code class="hljs xl">- ```  <span class="hljs-function"><span class="hljs-title">resultMapElements</span> -&gt;</span> 处理resultMap标签</code></pre></div></code></pre></li><li><div class="code-wrapper"><pre><code>sqlElement -&gt; 处理sql标签<pre><code class="hljs mathematica"><span class="hljs-operator">-</span> <span class="hljs-operator">```</span>  <span class="hljs-variable">buildStatementFromContext</span> <span class="hljs-operator">-&gt;</span> 处理<span class="hljs-built_in">Select</span>，<span class="hljs-built_in">Insert</span>，<span class="hljs-built_in">Delete</span>，<span class="hljs-built_in">Update</span>标签</code></pre></div></code></pre></li></ul><p>接下来让我们逐个分析这些方法是如何处理标签的。</p><h4 id="执行bindMapperForNamespace方法"><a href="#执行bindMapperForNamespace方法" class="headerlink" title="执行bindMapperForNamespace方法"></a>执行<code>bindMapperForNamespace</code>方法</h4><p>该方法主要作用是将解析后的XML和Mapper接口绑定到Configuration对象中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindMapperForNamespace</span><span class="hljs-params">()</span> </span>&#123;  String namespace = builderAssistant.getCurrentNamespace();  <span class="hljs-keyword">if</span> (namespace != <span class="hljs-keyword">null</span>) &#123;    Class&lt;?&gt; boundType = Resources.classForName(namespace);    <span class="hljs-keyword">if</span> (boundType != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (!configuration.hasMapper(boundType)) &#123;        <span class="hljs-comment">// 标识当前XML已经解析过</span>        configuration.addLoadedResource(<span class="hljs-string">&quot;namespace:&quot;</span> + namespace);        <span class="hljs-comment">// 添加到Configuration中</span>        configuration.addMapper(boundType);      &#125;    &#125;  &#125;&#125;</code></pre></div><h4 id="解析ResultMap标签"><a href="#解析ResultMap标签" class="headerlink" title="解析ResultMap标签"></a>解析<code>ResultMap</code>标签</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ResultMap <span class="hljs-title">resultMapElement</span><span class="hljs-params">(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType)</span> </span>&#123;  String type = resultMapNode.getStringAttribute(<span class="hljs-string">&quot;type&quot;</span>); <span class="hljs-comment">// 这里删除了一些代码</span>  Class&lt;?&gt; typeClass = resolveClass(type);<span class="hljs-comment">// 解析type获取对应的Class对象</span>  <span class="hljs-keyword">if</span> (typeClass == <span class="hljs-keyword">null</span>) &#123;    typeClass = inheritEnclosingType(resultMapNode, enclosingType);  &#125;  Discriminator discriminator = <span class="hljs-keyword">null</span>;  List&lt;ResultMapping&gt; resultMappings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(additionalResultMappings);  List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();  <span class="hljs-keyword">for</span> (XNode resultChild : resultChildren) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;constructor&quot;</span>.equals(resultChild.getName())) &#123;      processConstructorElement(resultChild, typeClass, resultMappings);  <span class="hljs-comment">// 步骤④：处理constructor标签</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;discriminator&quot;</span>.equals(resultChild.getName())) &#123;      <span class="hljs-comment">// 步骤③: 处理discriminator标签</span>      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 处理其他标签，例如：id，result标签</span>      List&lt;ResultFlag&gt; flags = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;id&quot;</span>.equals(resultChild.getName())) &#123;        flags.add(ResultFlag.ID);      &#125;      <span class="hljs-comment">// 步骤①：调用buildResultMappingFromContext构建ResultMapping</span>      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));    &#125;  &#125;  <span class="hljs-comment">// 获取到标签中的id，extends，autoMapping属性</span>  String id = resultMapNode.getStringAttribute(<span class="hljs-string">&quot;id&quot;</span>,          resultMapNode.getValueBasedIdentifier());  String extend = resultMapNode.getStringAttribute(<span class="hljs-string">&quot;extends&quot;</span>);  Boolean autoMapping = resultMapNode.getBooleanAttribute(<span class="hljs-string">&quot;autoMapping&quot;</span>);  <span class="hljs-comment">// 初始化ResultMapResolver对象，用于解析生成ResultMap对象</span>  ResultMapResolver resultMapResolver = <span class="hljs-keyword">new</span> ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 步骤②： 执行解析</span>    <span class="hljs-keyword">return</span> resultMapResolver.resolve();  &#125; <span class="hljs-keyword">catch</span> (IncompleteElementException  e) &#123;  &#125;&#125;</code></pre></div><p>图中步骤③和步骤④最终都会 调用步骤①的方法，所以我们重点关注步骤①和步骤② 这两个方法。</p><h5 id="生成ResultMapping"><a href="#生成ResultMapping" class="headerlink" title="生成ResultMapping"></a>生成<code>ResultMapping</code></h5><p>进入<code>buildResultMappingFromContext</code>方法，源代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ResultMapping <span class="hljs-title">buildResultMappingFromContext</span><span class="hljs-params">(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags)</span> </span>&#123;  String property;  <span class="hljs-keyword">if</span> (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;    property = context.getStringAttribute(<span class="hljs-string">&quot;name&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    property = context.getStringAttribute(<span class="hljs-string">&quot;property&quot;</span>);  &#125;  String column = context.getStringAttribute(<span class="hljs-string">&quot;column&quot;</span>);  String javaType = context.getStringAttribute(<span class="hljs-string">&quot;javaType&quot;</span>);  String jdbcType = context.getStringAttribute(<span class="hljs-string">&quot;jdbcType&quot;</span>);  String nestedSelect = context.getStringAttribute(<span class="hljs-string">&quot;select&quot;</span>);  String nestedResultMap = context.getStringAttribute(<span class="hljs-string">&quot;resultMap&quot;</span>, () -&gt;    processNestedResultMappings(context, Collections.emptyList(), resultType));  String notNullColumn = context.getStringAttribute(<span class="hljs-string">&quot;notNullColumn&quot;</span>);  String columnPrefix = context.getStringAttribute(<span class="hljs-string">&quot;columnPrefix&quot;</span>);  String typeHandler = context.getStringAttribute(<span class="hljs-string">&quot;typeHandler&quot;</span>);  String resultSet = context.getStringAttribute(<span class="hljs-string">&quot;resultSet&quot;</span>);  String foreignColumn = context.getStringAttribute(<span class="hljs-string">&quot;foreignColumn&quot;</span>);  <span class="hljs-keyword">boolean</span> lazy = <span class="hljs-string">&quot;lazy&quot;</span>.equals(context.getStringAttribute(<span class="hljs-string">&quot;fetchType&quot;</span>, configuration.isLazyLoadingEnabled() ? <span class="hljs-string">&quot;lazy&quot;</span> : <span class="hljs-string">&quot;eager&quot;</span>));  Class&lt;?&gt; javaTypeClass = resolveClass(javaType);  Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler);  JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);  <span class="hljs-comment">// 最终调用buildResultMapping生成了ResultMapping对象</span>  <span class="hljs-keyword">return</span> builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);&#125;</code></pre></div><p>可以看出这个方法逻辑比较简单，将子节点中配置的属性获取出来，最终组装了ResultMapping对象。</p><h5 id="生成ResultMap"><a href="#生成ResultMap" class="headerlink" title="生成ResultMap"></a>生成<code>ResultMap</code></h5><p><code>org.apache.ibatis.builder.ResultMapResolver#resolve</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultMap <span class="hljs-title">resolve</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 调用工具类的</span>  <span class="hljs-keyword">return</span> assistant.addResultMap(<span class="hljs-keyword">this</span>.id, <span class="hljs-keyword">this</span>.type, <span class="hljs-keyword">this</span>.extend, <span class="hljs-keyword">this</span>.discriminator, <span class="hljs-keyword">this</span>.resultMappings, <span class="hljs-keyword">this</span>.autoMapping);&#125;</code></pre></div><p><code>addResultMap</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultMap <span class="hljs-title">addResultMap</span><span class="hljs-params">(String id,Class&lt;?&gt; type,String extend,Discriminator discriminator,</span></span><span class="hljs-function"><span class="hljs-params">    List&lt;ResultMapping&gt; resultMappings,Boolean autoMapping)</span> </span>&#123;    id = applyCurrentNamespace(id, <span class="hljs-keyword">false</span>);  extend = applyCurrentNamespace(extend, <span class="hljs-keyword">true</span>);<span class="hljs-comment">// 如果当前resultMap存在父resultMap</span>  <span class="hljs-keyword">if</span> (extend != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// configuration是否已经加载过父resultMap</span>    <span class="hljs-keyword">if</span> (!configuration.hasResultMap(extend)) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncompleteElementException(<span class="hljs-string">&quot;Could not find a parent resultmap with id &#x27;&quot;</span> + extend + <span class="hljs-string">&quot;&#x27;&quot;</span>);    &#125;   <span class="hljs-comment">// 根据父resultMap的Id获取出父resultMap对象</span>    ResultMap resultMap = configuration.getResultMap(extend);    <span class="hljs-comment">// 去除父resultMap的resultMapping集合</span>    List&lt;ResultMapping&gt; extendedResultMappings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(resultMap.getResultMappings());    <span class="hljs-comment">// 去重</span>    extendedResultMappings.removeAll(resultMappings);    <span class="hljs-keyword">boolean</span> declaresConstructor = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 遍历当前resultMap的resultMapping，判断其是否包含Constructor</span>    <span class="hljs-keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;      <span class="hljs-keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;        declaresConstructor = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    <span class="hljs-comment">// 如果当前resultMap声明了Constructor标签，则删除父resultMap中声明的Constructor标签</span>    <span class="hljs-keyword">if</span> (declaresConstructor) &#123;      extendedResultMappings.removeIf(        resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR));    &#125;    <span class="hljs-comment">// 将父resultMap的resultMapping添加到当前resultMap的resultMapping集合中</span>    resultMappings.addAll(extendedResultMappings);  &#125;  <span class="hljs-comment">// 构建ResultMap对象</span>  ResultMap resultMap = <span class="hljs-keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)      .discriminator(discriminator).build();  <span class="hljs-comment">// 将构建好的ResultMap对象添加到Configuration中</span>  configuration.addResultMap(resultMap);  <span class="hljs-keyword">return</span> resultMap;&#125;</code></pre></div><p>因为resultMap标签可以继承其他的resultMap标签，而这个方法主要就是为了处理resultMap继承的问题。可以得出结论：<strong>XML中的<code>resultMap标签</code>最终会被解析成<code>ResultMap对象</code>并复制给了Configuration</strong>。</p><h4 id="解析SQL标签"><a href="#解析SQL标签" class="headerlink" title="解析SQL标签"></a>解析<code>SQL</code>标签</h4><p>resultMap标签解析完，继续看<code>sql标签</code>的解析过程：</p><p>方法入口：</p><div class="code-wrapper"><pre><code class="hljs java">sqlElement(context.evalNodes(<span class="hljs-string">&quot;/mapper/sql&quot;</span>));</code></pre></div><p>获取到XML中所有的sql标签节点对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sqlElement</span><span class="hljs-params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;  <span class="hljs-keyword">for</span> (XNode context : list) &#123;    String databaseId = context.getStringAttribute(<span class="hljs-string">&quot;databaseId&quot;</span>);    <span class="hljs-comment">// 获取到sql标签的ID</span>    String id = context.getStringAttribute(<span class="hljs-string">&quot;id&quot;</span>);    <span class="hljs-comment">// 和namespace进行拼接</span>    id = builderAssistant.applyCurrentNamespace(id, <span class="hljs-keyword">false</span>);    <span class="hljs-comment">// 判断是否已经存在次sql标签</span>    <span class="hljs-keyword">if</span> (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;      <span class="hljs-comment">// 不存在，添加到sqlFragments中</span>      <span class="hljs-comment">// sqlFragments存在于configuration中</span>      sqlFragments.put(id, context);    &#125;  &#125;&#125;</code></pre></div><p>该方法功能很简单，就是将<code>sql标签的id和对应的XNode节点对象</code>放入到<code>sqlFragments</code>中。</p><p><code>sqlFragments</code>对象在后面解析<code>select|insert|update|delete</code>标签中的include标签时会使用到。</p><h4 id="解析Crud标签"><a href="#解析Crud标签" class="headerlink" title="解析Crud标签"></a>解析<code>Crud</code>标签</h4><p>方法入口 ：</p><div class="code-wrapper"><pre><code class="hljs java">buildStatementFromContext(context.evalNodes(<span class="hljs-string">&quot;select|insert|update|delete&quot;</span>));</code></pre></div><p>获取的所有的CRUD标签。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildStatementFromContext</span><span class="hljs-params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;  <span class="hljs-comment">// 获取到所有的select，insert，delete，update标签节点</span>  <span class="hljs-keyword">for</span> (XNode context : list) &#123;    <span class="hljs-comment">// 为每一个crud标签创建XMLStatementBuilder对象，用于构建每个标签所对应的MapperStatement对象</span>    <span class="hljs-keyword">final</span> XMLStatementBuilder statementParser = <span class="hljs-keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);    <span class="hljs-comment">// 解析并生成MapperStatement对象</span>    statementParser.parseStatementNode();  &#125; <span class="hljs-comment">// 忽略了异常处理</span>&#125;</code></pre></div><p>该方法对获取到的<code>insert，select，update，delete</code>节点进行了遍历，并实例化了<code>XMLStatementBuilder</code>构建器来构建<code>MapperdStatement</code>。</p><p><code>XMLStatementBuilder</code>会将每个<code>crud标签</code>构建成一个<code>MapperdStatement对象</code>。它两是一对一的关系，后面调用方法执行SQL时就会获取到方法对应的MapperdStatement对象。</p><p>进入<code>parseStatementNode</code>方法：</p><p>重点关注标记的步骤</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseStatementNode</span><span class="hljs-params">()</span> </span>&#123;  String id = context.getStringAttribute(<span class="hljs-string">&quot;id&quot;</span>);  String databaseId = context.getStringAttribute(<span class="hljs-string">&quot;databaseId&quot;</span>);  <span class="hljs-keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="hljs-keyword">this</span>.requiredDatabaseId)) &#123;    <span class="hljs-keyword">return</span>;  &#125;  String nodeName = context.getNode().getNodeName();  SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));  <span class="hljs-keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;  <span class="hljs-keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="hljs-string">&quot;flushCache&quot;</span>, !isSelect);  <span class="hljs-keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="hljs-string">&quot;useCache&quot;</span>, isSelect);  <span class="hljs-keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="hljs-string">&quot;resultOrdered&quot;</span>, <span class="hljs-keyword">false</span>);  <span class="hljs-comment">// 步骤①</span>  XMLIncludeTransformer includeParser = <span class="hljs-keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);  includeParser.applyIncludes(context.getNode());  String parameterType = context.getStringAttribute(<span class="hljs-string">&quot;parameterType&quot;</span>);  Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);  String lang = context.getStringAttribute(<span class="hljs-string">&quot;lang&quot;</span>);  LanguageDriver langDriver = getLanguageDriver(lang);  <span class="hljs-comment">// 步骤②</span>  processSelectKeyNodes(id, parameterTypeClass, langDriver);  <span class="hljs-comment">// </span>  KeyGenerator keyGenerator;  String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;  keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="hljs-keyword">true</span>);  <span class="hljs-keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;    keyGenerator = configuration.getKeyGenerator(keyStatementId);  &#125; <span class="hljs-keyword">else</span> &#123;    keyGenerator = context.getBooleanAttribute(<span class="hljs-string">&quot;useGeneratedKeys&quot;</span>,        configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))        ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;  &#125;<span class="hljs-comment">// 步骤③</span>  SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);  StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="hljs-string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));  Integer fetchSize = context.getIntAttribute(<span class="hljs-string">&quot;fetchSize&quot;</span>);  Integer timeout = context.getIntAttribute(<span class="hljs-string">&quot;timeout&quot;</span>);  String parameterMap = context.getStringAttribute(<span class="hljs-string">&quot;parameterMap&quot;</span>);  String resultType = context.getStringAttribute(<span class="hljs-string">&quot;resultType&quot;</span>);  Class&lt;?&gt; resultTypeClass = resolveClass(resultType);  String resultMap = context.getStringAttribute(<span class="hljs-string">&quot;resultMap&quot;</span>);  String resultSetType = context.getStringAttribute(<span class="hljs-string">&quot;resultSetType&quot;</span>);  ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);  <span class="hljs-keyword">if</span> (resultSetTypeEnum == <span class="hljs-keyword">null</span>) &#123;    resultSetTypeEnum = configuration.getDefaultResultSetType();  &#125;  String keyProperty = context.getStringAttribute(<span class="hljs-string">&quot;keyProperty&quot;</span>);  String keyColumn = context.getStringAttribute(<span class="hljs-string">&quot;keyColumn&quot;</span>);  String resultSets = context.getStringAttribute(<span class="hljs-string">&quot;resultSets&quot;</span>);  <span class="hljs-comment">// 步骤④</span>  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,      resultSetTypeEnum, flushCache, useCache, resultOrdered,      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);&#125;</code></pre></div><p>这段代码很长，无需全部阅读，只需查看标记的核心步骤即可。</p><ul><li>步骤①：处理curd标签中的的Include标签。</li><li>步骤②：处理insert标签中的selectKey标签。</li><li>步骤③：处理curd标签中的动态标签 。</li><li>步骤④：将使用最终的crud标签生成MappedStatement对象。</li></ul><h5 id="处理Include标签"><a href="#处理Include标签" class="headerlink" title="处理Include标签"></a>处理<code>Include</code>标签</h5><p>在分析<code>XMLIncludeTransformer.applyIncludes</code>方法前，我们先来看几个问题，以便我们更好的理解Mybatis对 <code>&lt;include/&gt;</code>的处理逻辑：</p><ul><li>Mybatis是如何拆分含有<code>&lt;include/&gt;</code>标签的SQL？拆分各部分SQL关系如何维护？</li><li>Mybatis是如何处理嵌套<code>&lt;include/&gt;</code>标签？</li></ul><p>带着这两个问题，我们进入<code>applyIncludes</code>方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyIncludes</span><span class="hljs-params">(Node source, <span class="hljs-keyword">final</span> Properties variablesContext, <span class="hljs-keyword">boolean</span> included)</span> </span>&#123;<span class="hljs-comment">//  步骤②</span>  <span class="hljs-keyword">if</span> (source.getNodeName().equals(<span class="hljs-string">&quot;include&quot;</span>)) &#123;    <span class="hljs-comment">// 步骤⑤ 从sqlFragments中获取include所引用的id，即sql标签中编写的SQL语句。</span>    Node toInclude = findSqlFragment(getStringAttribute(source, <span class="hljs-string">&quot;refid&quot;</span>), variablesContext);    Properties toIncludeContext = getVariablesContext(source, variablesContext);    <span class="hljs-comment">// 步骤⑥ 递归，处理toInclude中嵌套的include标签</span>    applyIncludes(toInclude, toIncludeContext, <span class="hljs-keyword">true</span>);    <span class="hljs-comment">// 如果（toInclude节点）和 source（引入toInclude节点）不在同一个document下</span>    <span class="hljs-keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;      <span class="hljs-comment">// 将（toInclude节点）导入到 source 节点中去</span>      toInclude = source.getOwnerDocument().importNode(toInclude, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">// 步骤⑦ 将 source 节点替换成（toInclude节点）</span>    source.getParentNode().replaceChild(toInclude, source);    <span class="hljs-comment">// 为了方便阅读对源代码进行了修改</span>    Node toIncludeParentNode = toInclude.getParentNode()；    <span class="hljs-comment">// （toInclude节点）含有子节点，可能是嵌套的include标签</span>    <span class="hljs-keyword">while</span> (toInclude.hasChildNodes()) &#123;      <span class="hljs-comment">// 将（toInclude节点）下的子节点添加到父节点的集合中，并在（toInclude节点）前面</span>      toIncludeParentNode.insertBefore(toInclude.getFirstChild(), toInclude);    &#125;    <span class="hljs-comment">// 步骤⑧ 从父节点中删除（toInclude节点）</span>    toIncludeParentNode.removeChild(toInclude);  &#125;   <span class="hljs-comment">// 步骤①</span>  <span class="hljs-comment">// source对象为DeferredElementImpl类型，即include，select，insert，update，delete等标签</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) &#123;    <span class="hljs-comment">// 步骤③</span>    NodeList children = source.getChildNodes();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.getLength(); i++) &#123;      <span class="hljs-comment">// 步骤④</span>      applyIncludes(children.item(i), variablesContext, included);    &#125;  &#125;   <span class="hljs-comment">// source对象为DeferredTextImpl类型，</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (included &amp;&amp; (source.getNodeType() == Node.TEXT_NODE || source.getNodeType() == Node.CDATA_SECTION_NODE) &amp;&amp; !variablesContext.isEmpty()) &#123;    <span class="hljs-comment">// 步骤⑨ 最终替换对象里的data属性</span>    source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));  &#125;&#125;</code></pre></div><p>这段代码大量使用了递归调用，来处理嵌套标签。</p><p>执行流程：</p><ul><li>判断节点类型是否为元素节点<ul><li>是 <code>--&gt; 步骤①</code><ul><li>获取到子节点，根据<code>include</code>标签进行拆分。<code>--&gt; 步骤③</code></li><li>遍历子节点，递归处理子节点。 <code>--&gt; 步骤④</code></li></ul></li><li>否 <code>--&gt; 步骤②</code>  <ul><li>从<code>sqlFragments</code>中获取到引入SQL节点。 <code>--&gt;步骤⑤</code></li><li>递归处理引入的SQL节点，防止引入的SQL中存在嵌套的Include节点。 <code>--&gt; 步骤⑥</code></li><li>逐层将<code>include标签</code>替换成<code>include中实际的SQL</code>。 <code>--&gt;步骤⑦</code> </li><li>最终删除<code>include标签</code>。 <code>--&gt; 步骤⑧</code></li></ul></li></ul></li><li>直接设置节点值 <code>--&gt;步骤⑨</code></li></ul><p>讲述了大致流程，这里会有一个小疑问，Mybatis到底是如何获取子节点的？是如何拆分的？为了更好的理解这个问题， 引入一张<code>select标签</code>引入<code>&lt;include/&gt;</code>标签的XML解析Debug图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164132.png" alt="include解析" style="zoom:50%;" /><p>从上图画红圈的地方可以，整个<code>select</code>语句被拆分成了三个部分，每个对象中都有：</p><ul><li><code>select</code> 一行产生了一个<code>DeferredTextImpl</code>类型的 对象，简称对象A。</li><li><code>include</code>一行产生了一个<code>DeferredElementImpl</code>类型的对象，简称对象B。</li><li><code>form</code> 和<code>where</code>两行产生了一个<code>DeferredTextImpl</code>类型的对象，简称对象C。</li></ul><p>每个对象中都含有以下三个属性：</p><ul><li><p><code>data</code>标识了当前对象所对应的<code>sql</code>语句内容。</p></li><li><p><code>previousSibling</code>标识了当前对象的前一个对象。</p></li><li><p><code>nextSibling</code>标识来当前对象的下一个对象 。</p></li></ul><p>三个对象前后之前的关系：</p><div class="code-wrapper"><pre><code class="hljs tex">对象A.previousSibling -&gt; 对象C对象B.previousSibling -&gt; 对象A对象C.previousSibling -&gt; 对象B</code></pre></div><p><strong>这里我们可以看出Mybatis使用了类似  <code>双向链表</code> 的结构来管理标签被拆分后形成的对象。</strong></p><p><strong>这里有一个疑问，为什么<code>select</code>被拆分成了一行，而<code>from</code>和<code>where</code>为什么没被拆分成两行，而是拆分成了一行 ？</strong></p><p>为了验证这个问题，将<code>&lt;include/&gt;</code>替换掉，生成的对象属性如下图。未引入Include的XML解析Debug图：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501164004.png" style="zoom:50%;" /><p><strong>这里可以得出的结论就是：Mybatis会以<code>&lt;include/&gt;</code>标签为分割线进行SQL语句的切分。</strong></p><p>步骤②处理SelectKey标签代码不做分析，感兴趣的可以自行查看源代码。</p><h5 id="处理dynamic标签"><a href="#处理dynamic标签" class="headerlink" title="处理dynamic标签"></a>处理<code>dynamic</code>标签</h5><p>在进入<code>langDriver.createSqlSource</code>方法前我们先来思考两个问题？</p><ul><li>Mybatis是如何区分动态SQL和静态SQL？</li><li>Mybatis是如何处理包含动态标签的SQL？</li></ul><p>带着这两个问题我们继续分析：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title">createSqlSource</span><span class="hljs-params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;  <span class="hljs-comment">// 创建XMLScriptBuilder构建起</span>  XMLScriptBuilder builder = <span class="hljs-keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);  <span class="hljs-comment">// 构建script节点</span>  <span class="hljs-keyword">return</span> builder.parseScriptNode();&#125;</code></pre></div><p>我们可以看出Mybatis创建了<code>XMLScriptBuilder</code>构建器来构建<code>动态标签</code>。我们先来看看XMLScriptBuilder类结构：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501154915.png" alt="image-20200501154915783" style="zoom:50%;" /><p>从类结构图可以看出有8个处理动态标签的处理类，使用<code>isDynamic()</code>判断是否为动态标签 ，使用<code>nodeHandlerMap</code>来存储动态标签处理器。</p><p>让我进入<code>parseScriptNode</code>方法一探究竟：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title">parseScriptNode</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 解析动态标签</span>  MixedSqlNode rootSqlNode = parseDynamicTags(context);  SqlSource sqlSource;  <span class="hljs-keyword">if</span> (isDynamic) &#123;    <span class="hljs-comment">// 动态SQL源</span>    sqlSource = <span class="hljs-keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 静态SQL源</span>    sqlSource = <span class="hljs-keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);  &#125;  <span class="hljs-keyword">return</span> sqlSource;&#125;</code></pre></div><p>从代码中可以看出Mybatis为动态SQL创建了<code>DynamicSqlSource</code>子类，为静态SQL创建了<code>RawSqlSource</code>子类。到这里我们的第一个问题就比较清晰了，<strong>Mybatis使用了不同的SqlSource子类来区分动态SQL和静态SQL</strong>。</p><p>进入<code>parseDynamicTags</code>方法，查看解析动态标签的具体方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> MixedSqlNode <span class="hljs-title">parseDynamicTags</span><span class="hljs-params">(XNode node)</span> </span>&#123;  List&lt;SqlNode&gt; contents = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">// 步骤①</span>  NodeList children = node.getNode().getChildNodes();  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.getLength(); i++) &#123;    XNode child = node.newXNode(children.item(i));    <span class="hljs-comment">// 步骤②</span>    <span class="hljs-keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;      <span class="hljs-comment">// 步骤③</span>      String data = child.getStringBody(<span class="hljs-string">&quot;&quot;</span>);      TextSqlNode textSqlNode = <span class="hljs-keyword">new</span> TextSqlNode(data);      <span class="hljs-keyword">if</span> (textSqlNode.isDynamic()) &#123;        contents.add(textSqlNode);        isDynamic = <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 步骤③</span>        contents.add(<span class="hljs-keyword">new</span> StaticTextSqlNode(data));      &#125;    &#125;     <span class="hljs-comment">// 步骤④</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="hljs-number">8</span>      String nodeName = child.getNode().getNodeName();      <span class="hljs-comment">// 步骤⑤</span>      NodeHandler handler = nodeHandlerMap.get(nodeName);      <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="hljs-string">&quot;&gt; in SQL statement.&quot;</span>);      &#125;      <span class="hljs-comment">// 步骤⑤</span>      handler.handleNode(child, contents);      isDynamic = <span class="hljs-keyword">true</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MixedSqlNode(contents);&#125;</code></pre></div><p>配合着源代码梳理一下执行流程，以便更好的理解Mybatis处理逻辑：</p><ul><li>获取到<code>crud标签</code>下所有的<code>子节点</code>，并进行遍历 –&gt; 步骤①</li><li>判断子节点的类型是否是元素节点（即动态标签节点）<ul><li>是 –&gt; <code>动态标签</code> <code>--&gt; 步骤④</code><ul><li>根据动态标签名称从nodeHandlerMap获取出对应的处理器  <code>--&gt; 步骤⑤</code></li><li>调用处理器的handleNode方法处理  <code>--&gt; 步骤⑤</code></li></ul></li><li>否 –&gt; <code>txt文本类型的普通SQL语句</code><ul><li>获取到节点中的<code>Body</code>即SQL语句，创建<code>StaticTextSqlNode</code>对象包装 <code>--&gt; 步骤③</code></li></ul></li></ul></li></ul><p>从上面的类图我们已经知道<code>各自动态标签都对应各自的Handle</code>，那Handle是如何添加到<code>nodeHandlerMap</code>中的呢？</p><p>答案就在<code>XMLScriptBuilder</code>的构造方法中 。</p><p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501161032.png" alt="image-20200501161032311"></p><p>接着我们来看看各个Handle对各自标签的处理过程，我们以<code>TrimHandler</code>为准，进入<code>handleNode</code>方法一探究竟：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleNode</span><span class="hljs-params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;  <span class="hljs-comment">// 递归处理当前动态标签里包含的其他动态标签，即嵌套动态标签。</span>  MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);  String prefix = nodeToHandle.getStringAttribute(<span class="hljs-string">&quot;prefix&quot;</span>);  String prefixOverrides = nodeToHandle.getStringAttribute(<span class="hljs-string">&quot;prefixOverrides&quot;</span>);  String suffix = nodeToHandle.getStringAttribute(<span class="hljs-string">&quot;suffix&quot;</span>);  String suffixOverrides = nodeToHandle.getStringAttribute(<span class="hljs-string">&quot;suffixOverrides&quot;</span>);  <span class="hljs-comment">// 构建TrimSqlNode对象</span>  TrimSqlNode trim = <span class="hljs-keyword">new</span> TrimSqlNode(configuration, mixedSqlNode, prefix, prefixOverrides, suffix, suffixOverrides); <span class="hljs-comment">// 添加到集合中</span>  targetContents.add(trim);&#125;</code></pre></div><p>上诉代码将<code>&lt;trim/&gt;</code>签配置的属性都读取出来，并最终生成了一个<code>TrimSqlNode</code>对象。<strong>这里我们可以猜测：是不是每一个标签都会对应拥有一个<code>SqlNode</code>呢？</strong></p><p>是的你没猜错，Mybatis为每种动态标签都生成了对应的SqlNode。下面为SqlNode的继承图 ：</p><img src="https://better-io-blog.oss-cn-beijing.aliyuncs.com/20200501163950.png" alt="image-20200424174851998" style="zoom:50%;" /><p><strong>到这里，我们上述的第二个问题就非常清晰了：</strong></p><p><strong>Mybatis使用不同的<code>NodeHandler</code>来处理不同的动态标签，使用不同的<code>SqlNode</code>来接收不同动态标签的配置。</strong></p><p>到此SQL解析完成了吗？其实并没有，Mybatis对静态SQL做了进一步的操作，替换<code>#&#123;&#125;</code>为<code>?</code>。我们知道Mybatis会为静态SQL创建<code>RawSqlSource</code>对象。而这个替换操作就是在这里面发生的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RawSqlSource</span><span class="hljs-params">(Configuration configuration, String sql, Class&lt;?&gt; parameterType)</span> </span>&#123;  SqlSourceBuilder sqlSourceParser = <span class="hljs-keyword">new</span> SqlSourceBuilder(configuration);  Class&lt;?&gt; clazz = parameterType == <span class="hljs-keyword">null</span> ? Object.class : parameterType;  <span class="hljs-comment">// 解析SqlSource</span>  sqlSource = sqlSourceParser.parse(sql, clazz, <span class="hljs-keyword">new</span> HashMap&lt;&gt;());&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSource <span class="hljs-title">parse</span><span class="hljs-params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;  ParameterMappingTokenHandler handler = <span class="hljs-keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);  <span class="hljs-comment">// 将 #&#123;&#125; 替换成 ?</span>  GenericTokenParser parser = <span class="hljs-keyword">new</span> GenericTokenParser(<span class="hljs-string">&quot;#&#123;&quot;</span>, <span class="hljs-string">&quot;&#125;&quot;</span>, handler);  String sql = parser.parse(originalSql);  <span class="hljs-comment">// 最后创建StaticSqlSource的sqlSource</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());&#125;</code></pre></div><p>至此步骤 ③执行完成，动态SQL和静态SQL解析完成。</p><h4 id="构建MappedStatement"><a href="#构建MappedStatement" class="headerlink" title="构建MappedStatement"></a>构建<code>MappedStatement</code></h4><p>一切准备工作都已完成，到了最后步骤④，在这个步骤中会将前面几个步骤产生的结果组装到一个叫MappedStatement对象中。</p><p>最终将这个对象添加到Configuration中，可自行查看。</p><div class="code-wrapper"><pre><code class="hljs java">builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,    fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,    resultSetTypeEnum, flushCache, useCache, resultOrdered,    keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</code></pre></div><p>此致Mybatis整个启动加载的过程分析完毕。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在这个阶段我们清楚的认知了Mybatis对Mapper解析的过程，使用了<code>XMLStatementBuilder</code>来解析Mapper中的标签，<code>XMLScriptBuilder</code>来解析Mapper中的动态标签。</p><p>使用<code>ResultMapResolver</code>来解析<code>ResultMap</code>标签，并将其每一个子节点映射成了<code>ResultMapping</code>对象。</p><p>使用不同的<code>NodeHandler</code>来处理不同的动态标签，为不同动态标签创建不同的<code>SqlNode</code>对象。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Orm</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ioc-Spring-简介</title>
    <link href="/2019/09/09/spring/01-spring-introduction/"/>
    <url>/2019/09/09/spring/01-spring-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="Ioc容器"><a href="#Ioc容器" class="headerlink" title="Ioc容器"></a>Ioc容器</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><p>本文主要讲述Ioc容器和DI相关的概念以及区别</p><p>Ioc是什么?</p><p>DI是什么？</p><p>Ioc为什么叫控制反转？控制了什么？反转了什么？</p><p>Di为什么叫依赖注入？依赖了什么？注入了什么？</p></blockquote><h2 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IoC</strong>），是<a href="https://zh.wikipedia.org/wiki/面向对象编程">面向对象编程</a>中的一种<strong>设计原则</strong>，可以用来减低计算机代码之间的<a href="https://zh.wikipedia.org/wiki/耦合度_(計算機科學)">耦合度</a>。其中最常见的方式叫做<strong>依赖注入</strong>（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。</p><p><strong>IOC不是什么技术，而是一种设计思想</strong>。</p><p>既然IOC是控制反转，那<strong>控制了什么</strong>？<strong>反转了什么</strong>？ </p><p><strong>控制</strong>：传统Java开发中，我们都是主动在类中创建依赖的对象，是程序主动去创建依赖对象；而在IoC中有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建。<strong>即创建和查找依赖对象的控制权交给了IoC容器</strong>。</p><p><strong>反转</strong>：类获取依赖对象的方式不在是主动<code>new</code>，而是想IoC容器获取，即<strong>获得依赖对象的过程被反转</strong>。</p><p>实现方法</p><p>实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><code>DI—Dependency Injection</code>，即<strong>依赖注入</strong>：<strong>组件之间依赖关系</strong>由容器在运行期决定，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>参考 <a href="https://www.martinfowler.com/articles/injection.html">Martin Fowler文章</a></p><p>理解DI的关键是：<strong>谁依赖谁，为什么需要依赖，谁注入谁，注入了什么</strong>。</p><ul><li><p>谁依赖谁：当然是<strong>应用程序依赖于IoC容器</strong>；</p></li><li><p>为什么需要依赖：<strong>应用程序需要IoC容器来提供对象需要的外部资源</strong>；</p></li><li><p>谁注入谁：很明显是<strong>IoC容器注入应用程序某个对象</strong>，应用程序依赖的对象；</p></li><li><p>注入了什么：就是注入<strong>某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>；</p></li></ul><p>IoC和DI之间有什么关系呢？Ioc着重强调的是对象创建和获取的控制，而DI着重强调的是</p><p>依赖注入实现方式：</p><ul><li>基于接口。实现特定接口以供外部容器注入所依赖类型的对象。</li><li>基于<code>set</code>方法。实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。</li><li>基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。</li><li>基于注解。基于<a href="https://zh.wikipedia.org/wiki/Java注解">Java的注解功能</a>，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而并不希望其他依赖此类的对象访问）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Ioc</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
